---
title:  "《理解 UNIX 进程》学习笔记"
date:   2016-08-12 20:20:00
description: '《理解 UNIX 进程》'
---

# 《理解 UNIX 进程》学习笔记

@(学习笔记)

## 系统调用/命令/库函数


1. 用户在shell环境中可以操作的命令或可执行文件
2. 系统内核可调用的函数与工具等
3. 一些常用的函数（function）与函数库（library），大部分为C的函数库（libc）
4. 设备文件的说明，通常是在/dev下的文件
5. 配置文件或者是某些文件的格式
6. 游戏（games）
7. 惯例与协议等，例如Linux文件系统、网络协议、ASCII code等说明
8. 系统管理员可用的管理命令
9. 跟kernel有关的文件

| 系统调用      |    ruby | 描述  |
| :-------- | :--------| :--: |
| `select(2)`  |  |     |
| `getpid(2)` | `Process.pid` 或 全局变量 `$$`  |   获取当前进程的 pid  |
| `getppid(2)`  |`Process.ppid`  |   获取当前父进程的 pid  |
| `ps(1)`  |  |  进程状态   |
| `open(2)`  |  | 打开或创建一个文件   |
| `close(2)`  |  | 删除一个描述符(关闭一个打开的文件)   |
| `read(2)`  |  |  |
| `write(2)`  |  |  |
| `pipe(2)`  |  |  |
| `fsync(2)`  |  |  |
| `stat(2)`  |  |  |
| `getrlimit(2)`  | `Process.getrlimit`  | 查询资源限制，比如 `Process.getrlimit(:NOFILE)` 查询进程可以打开的最大文件数|   
| `setrlimit(2)`  | `Process.setrlimit` | 修改资源限制，比如 `Process.setrlimit(:NOFILE, 10000)` 修改可以打开的最大文件数到 10000|
| `stat(2)`  |  |  |
| `setenv(3)`,`getenv(3)`  |  | 设置或获取环境变量 |
| `fork(2)`  | `Kenel#fork` | 允许运行中的进程已编程的方式衍生(forking)子进程，子进程和原进程一模一样 |
| `waitpid(2)`  | `Process.wait`及其表亲 | 阻塞并等待随机或指定子进程退出 |

## 理解 UNIX 进程（2）：基础知识
 
### 2.4 系统调用

- UNIX 系统的组成：用户空间(userland) 和内核。
- 程序不可以直接访问内核，所有通信都是通过系统调用来完成
- 所有的程序都运行在用户空间。
- 系统调用允许你的用户空间程序通过内核间接地与计算机硬件进行交互

### 2.5 命名法，wtf(2)

Linux 系统手册常用的节：
- 节1：一般命令
- 节2： 系统调用
- 节3：C 库函数
- 节4：特殊文件

```
man 2 getpid # 从节2 查看 getpid 使用说明
man find # 等同于 man 1 find
```

### 2.6 Unix 进程之本

- 所有的代码都是在进程中执行的。
- 一个进程可以生成并管理其他多个进程

## 理解 UNIX 进程（3）：进程皆有标识

- 进程都有一个唯一的进程标识符，称为 `pid`
- `pid` 是一个顺序数字标识，不传达进程本身的任何信息
- 查看进程命令: ` ps -p <pid-of-irb-process>`
- ruby 的 `Process.pid` 对应于系统调用 `getpid(2)`

## 理解 UNIX 进程（4）：进程皆有父
- 系统中运行的每一个进程都有对应的父进程
- 每个进程都知道其父进程标识符（称为 ppid）

ruby 获取父进程：

```ruby
puts Process.ppid
```

**实践领域**

- ppid 一般用于检测守护进程
- ruby 的 `Process.ppid` 对应系统调用 `getppid(2)`


## 理解 UNIX 进程（5）：进程皆有文件描述符

文件描述符代表打开的文件

### 5.1 万物皆为文件

- UNIX 中一切皆为文件，包括（设备、管道、套接字等），书中用 `资源` 表示
- 传统定义（文件系统中的文件）的时候，将使用 `文件` 表示

### 5.2 描述符代表资源

- 在进程中打开一个资源，会获得一个文件描述符编号（`file descriptor number`）
- 文件描述符不会在无关进程之间共享，它只存在于其所属的进程之中。
- 进程结束后，文件描述符会和进程打开的资源一同被关闭
- ruby 中，任何一个 IO 对象都有一个相关联的文件描述符编号，用 `IO#fileno` 访问
- 进程打开的所有资源都会获得一个用于标识的唯一数字。这是内核跟踪进程所用资源的方法


### 5.3 标准流

在通常情况下，UNIX每个程序在开始运行的时刻，都会有3个已经打开的 stream. 分别用来输入，输出，打印诊断和错误信息。通常他们会被连接到用户终端（tty(4)）. 但也可以改变到其它文件或设备。这取决于双亲进程的选择和设置。

每个 UNIX 进程都有三个打开的资源：标准输入（STDIN）、标准输出(STDOUT) 和标准错误(STDERR)

**STDIN**:
提供了一种从键盘或管道中读取输入的通用方法

**STDOUT** 和 **STDERR**
提供了一种向显示器、文件、打印机等输出写入内容的通用方法

每个进程的 `0,1,2` 三个文件描述符编号分别属于 `STDIN,STDOUT,STDERR`


## 理解 UNIX 进程（6）：进程皆有资源限制
@(学习笔记)

- 文件描述符编号一直处理递增状态
- 内核为进程施加了某些资源限制

### 6.1 找出限制

```
p Process.getrlimit(:NOFILE) # 查询可打开的最大文件数
# => [4864, 9223372036854775807]
```
- 返回值第一个元素是文件描述符数量的软限制(soft limit)，超过软限制将会产生异常
- 第二个元素是文件描述符数量的硬限制(hard limit),实际上表示无限制

### 6.3 提高软限制

``` ruby
 Process.setrlimit(:NOFILE, 5886)
 p Process.getrlimit(:NOFILE)
 #=> [5886, 5886]
```
- 软限制和硬限制都被设置成了 5886
- 可以给 ` Process.setrlimit` 传递第 3 个参数来制定新的硬限制

```
P  Process.setrlimit(:NOFILE, Process.getrlimit(:NOFILE)[1])
```
设置文件描述符数量限制为最大，其实我本机只能设置到 `10000` 左右

### 6.4 超出限制

打开 irb 输入：
```
Process.setrlimit(:NOFILE, 8)
# 会出现 `output=': Too many open files - dup (Errno::EMFILE)
```
因为进程打开时默认已经使用了 8个文件描述符编号，这时再操作会有错误出现


打开 irb 输入：
```
Process.setrlimit(:NOFILE, 9)
 f = File.open('/dev/null')
# 会出现 Errno::EMFILE: Too many open files @ rb_sysopen - /dev/null
```

### 6.5 其它资源限制

```ruby
# 当前用户所允许的最大并发进程数
Process.getrlimit(:NPROC)

# 可以创建的最大的文件
Process.getrlimit(:FSIZE)

# 用于进程栈的最大段的大小
Process.getrlimit(:STACK)
```
请查看 Process.getrlimit 文档查看完整的可用选项列表

### 6.6 实践领域

- `httperf` 是一款多并发测试工具，需要提高系统的软限制才可以创建更多的并发
- 我们还可以在执行第三方代码的时候，对代码所属进程进行设置限制，并取消修改限制的权限，确保其无法超出徐克范围的资源数量


### 6.6 系统调用

`Process.getrlimit` 对应系统调用的 `getrlimit(2)`
`Process.setrlimit` 对应系统调用的 `setrlimit(2)`

## 理解 UNIX 进程（7）：进程皆有环境

- 环境变量是包含进程数据的键-值对(`key-value pairs`)
- 每个进程都有环境变量，由父进程设置并由子进程继承

### 7.1 环境变量是散列吗？

- ENV 使用了散列式的存取器 API，但并非 HASH
- 它实现了 `Enumerable` 和部分 `Hash API`, 但不是全部，`merge` 就没有实现
- 系统调用不能直接操作环境变量，但 C 库函数 `setenv(3)` 和 `getenv(3)` 可以

## 理解 UNIX 进程（8）：进程皆有参数

- 所有进程都可以访问 `ARGV` 的特殊数组
- argv 是 argumant vector 的缩写，表示参数向量或数组
- 有些库会读取 `ARGV` 来解析命令行选项，我们可以在读取前修改它

### 实践领域

- ARGV 常用于将文件名作为参数传入程序

## 理解 UNIX 进程（9）：进程皆有名

进程的非自身通信方式：
- 通过文件系统，写入日志信息的方式来了解彼此的状态
- 借助网络来打开套接字通其它进程进行通过

进程自身的通信机制：一个是进程名称，另一个是退出码

### 9.1 进程命名
- 每个进程都要一个名称
- 进程可以在运行期间被修改作为一种通信手段
- ruby 中用全局变量 `$PROGRAM_NAME` 或 `$0` 获得当前进程名称

## 理解 UNIX 进程（10）：进程皆有退出码

- 进程在结束的时候都带有数字退出码(0~255), 用于指明进程是否顺利结束
- 退出码为 0 表示顺利结束，其它的表示各种错误
- 退出码也是一种进程的通信途径

### 如何退出进程

- ruby 中用 `kernel#exit` 来退出进程，退出码是 0，但是亦可以定制 `exit 22
- `kernel#exit`  被调用，退出之前，会调用 `at_exit` 定义的语句块
- - `kernel#exit！`  被调用，退出码设置为 1，不会调用 `at_exit` 
- `kernel#abort` 从错误进程中退出的通用方法，会将当前进程的退出码设置为 1
- `kernel#abort` 退出码设置为 1， 也会调用 `at_exit`
- `kernel#raise` 不会立即结束进程，只是抛出异常，会沿着调用栈向上传递，如果不处理，那么异常会终结该进程
- `kernel#raise` 退出码设置为 1，也会调用 `at_exit`

## 理解 UNIX 进程（11）：进程皆可衍生
 
### 11.1 Luke,使用 fork(2)
- 衍生(forking) 是 Unix 编程中最强大的概念之一
- `fork(2)` 系统调用，允许运行中的进程以编程的形式创建新的进程，这个新进程和原始进程一模一样

fork 工作原理：
- 调用 `fork(2)` 的进程是 “父进程”，新创建的进程是 “子进程”
- 子进程从父进程出集成了其所占用内存中的所有内容，以及所有属于父进程的已打开的文件描述符
- 子进程的 ppid 是父进程的 pid
- 子进程获得了父进程所有的文件描述符的编号，两个进程可以共享打开的文件、套接字等
- 子进程继承了父进程内存中的所有内容
- fork 调用几乎瞬间就可以返回，速度很快，比分别载入 3 个应用程序实例要快的多
- 子进程可以随意更改其内存内容的副本，而不会对父进程造成任何影响

``` ruby
if fork
  puts "#{Process.pid} entered the if block"
else
  puts "#{Process.pid} entered the else block"
end
```
- 以上 if 和 else 都会被执行
- 在父进程中，fork 范湖新创建的子进程的 pid，整数值为真，执行 if 语句块
- 在子进程中，fork 返回 nil ，所以子进程执行了 else 语句块

### 11.2 多核编程

- 通过生成新的进程，你的代码可以(不能完全保证)被分配到多个 CPU 核心中,实现多核并发
- 如果系统繁忙，可能 4 个进程都由一个 CPU 来处理

**`注意：`**

   `fork(2)` 创建了一个和旧进程一模一样的新进程，如果父进程使用了 500M 内存进行了衍生，那么就会有 1GB 的内存被占用了，重复同样的操作 10 次，很快会耗尽所有的内容，这通常被称为 "fork 炸弹"(for bomb)

### 11.3 使用 block

- 将一个 block 传递给 fork 方法，那么 block 会在新的子进程中执行，而父进程会跳过 block 中的内容
- 子进程执行完 block 之后就会推出，不会像父进程那样执行随后的代码

``` ruby
fork do
  # 此处的代码仅在子进程中执行
end
# 此处的代码仅在父进程中执行
```

### 11.5 系统调用

`kenel#fork` 对应系统调用 `fork(2)`


## 理解 UNIX 进程（12）：孤儿进程

``` ruby
fork do 
  100.times do
    sleep 1
    puts "I'm an orphan! #{Process.pid}"
  end
end

abort "Parent process died..."
```
示例代码，父进程退出之后，子进程还没有退出，称为孤儿进程

管理孤儿：

- 守护进程：守护进程是一种长期运行的进程，为了能够一直保持运行，他们有意作为孤儿进程存在
- 使用 Unix 信号来与脱离终端会话的进程进行通信


