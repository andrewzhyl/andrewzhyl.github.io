---
title:  "编程基础七(切片)"
date:   2016-06-18 18:40:00
description: 'GO 编程基础五(控制语句)'
---

# GO 编程基础七(切片)

@(学习笔记)
- 其本身并不是数组，它指向底层的数组
- 作为变长数组的替代方案，可以管理底层数组的局部或全部
- 为引用类型
- 可以直接创建或从底层数组获取生成
- 使用 len() 获取元素个数， cap()获取容量
- 一般使用 make() 创建
- 如果多个 slice 指向相同底层数组，其中一个的值改变会影响全部
- make([]T,len,cap)
- 其中 cap 可以省略,则和 len 的值相同
- len 表示存数的元素个数， cap 表示容量

``` go
var s1 []int # slice 定义
```


```go
  a := [10]int{1, 2, 3, 4, 5, 6, 7, 8, 9}
  l := len(a)
  s1 := a[5 : l-1] # 截取数组的 slice
  s2 := a[:5] # 从 0 到 5 截取
  fmt.Println(s1)
```

**make**
  make([]T,len,cap)


``` go
s1 := make([]int, 3, 9)
```

**Reslice**
- Reslice 时索引以被 slice 的切片为准
- 索引不可以超过被 slice 的切片的容量 cap() 值
- 索引越界不会导致底层数组的重新分配而是引发错误

``` go
  a := [...]byte{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k'}
  sa := a[2:5]
  sab := sa[1:5]
  fmt.Println(string(sab))
  fmt.Println(len(sa), cap(sa))
  fmt.Println(len(sab), cap(sab))
  // 输出：
//  defg
//   3 9
//   4 8
```

**Append**
- 可以在 slice 尾部追加元素
- 可以讲一个 slice 追加在另一个 slice 尾部
- 如果最终长度未超过追加到 slice 的容量则返回原始 slice
- 如果唱过追加到的 slice 的容量，则将重新分配数组并拷贝原始数据(新版不会)

``` go
s1 := make([]int, 3, 6)
fmt.Printf("%p\n", s1)
s1 = append(s1, 1, 2, 3)
fmt.Printf("%v %p\n", s1, s1)
s1 = append(s1, 4, 5, 6)
fmt.Printf("%v %p\n", s1, s1)

// 0xc20803a180
//  [0 0 0 1 2 3] 0xc20803a180
//  [0 0 0 1 2 3 4 5 6] 0xc208048000
```

``` go
a := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
  s1 := a[2:5]
  s2 := a[1:3]
  fmt.Println(s1, s2)
  s2 = append(s2, 1, 23, 4, 5)
  s1[0] = 9
  fmt.Println(s1, s2)
//输出
//  [3 4 5] [2 3]
//  [9 1 23] [2 9 1 23 4 5] # go 1.5.3 s2 还指向 a
```

**Copy**

- 拷贝 slice

```go
s1 := []int{1, 2, 3, 4, 5, 6}
s2 := []int{7, 8, 9, 10, 11, 12, 13}
fmt.Printf("%p\n", s1)
copy(s1[1:3], s2[1:3]) # 拷贝 s2的 8,9 到 s1 的 2,3 的位置
输出：

```
