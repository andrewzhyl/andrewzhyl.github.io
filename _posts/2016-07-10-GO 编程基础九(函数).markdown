---
title:  "GO 编程基础九(函数)"
date:   2016-07-10 08:10:00
description: '学习 函数function'
---

# GO 编程基础九(函数)

函数 function
- Go 函数不支持嵌套、重载和默认参数
- 但支持以下特性：
  无需声明原型、不定长度变参、多返回值、命名返回值参数匿名函数、闭包
- 定义函数使用关键字 `func`,且左大括号不能另起一行
- 函数也可以作为一种类型使用

**参数定义和返回值定义**

``` go
func main() {
  a, _ := A(1, 2, 3)
  fmt.Println(a)
}

func A(a, b, c int) (e, f int) { //第一个()内是参数，第二个是返回值
  return b, c
}
```

**不定长度参数**

``` go
func main() {
  a, _ := A(1, 2, 3)
  fmt.Println(a)
}

func A(a ...int) (e, f int) {
  return a[0], a[1]
}
```

**值类型指针参数**
- 引用类型不同，直接传递就可以修改

``` go
func main() {
  a := 1
  A(&a)
  fmt.Println(a)
}

func A(a *int) {
  *a = 2
  fmt.Println(*a)
}
```

**匿名函数**

``` go
a = func(){
    fmt.Println("Func A")
  }
```

**闭包**

``` go
func main() {
  f := closure(10)
  fmt.Println(f(1))
  fmt.Println(f(2))
}

func closure(x int) func(int) int {
  return func(y int) int {
    return x + y
  }
}

//========
//11
//12
```

## defer 和 panic/recover
- defer 的执行方式类似其它语言中的析构函数，在函数体执行结束后按照调用顺序的`相反顺序`逐个执行
  - 即使函数发生`严重错误`也会执行
  - 支持匿名函数的调用
  - 常用语资源清理、文件关闭、解锁以及记录时间等操作
  - 通过与匿名函数配合可在 `return` 之后修改函数计算结果
  - 如果函数体内某个变量座位 `defer` 时匿名函数的参数，则在定义 `defer` 时即已经获得了拷贝，否则则是引用某个变量的地址

- Go 没有异常机制，但有 panic/recover 模式来处理错误
- panic 可以在任何地方引发，但 recover 只有在 defer 调用的函数中有效

**defer 例子**

``` go
func main() {
  var fs = [4]func(){}

  for i := 0; i < 4; i++ {
    defer fmt.Println("defer i = ", i)
    defer func() { fmt.Println("defer_closure i =", i) }()
    fs[i] = func() {
      fmt.Println("closure i =", i)
    }
  }

  for _, f := range fs {
    f()
  }
}

//输出
// closure i = 4
// closure i = 4
// closure i = 4
// closure i = 4
// defer_closure i = 4
// defer i =  3
// defer_closure i = 4
// defer i =  2
// defer_closure i = 4
// defer i =  1
// defer_closure i = 4
// defer i =  0
```

**异常 panic 和恢复 recover 用法**

``` go
func main() {
  A()
  B()
  C()
}

func A() {
  fmt.Println(("Func A"))
}

func B() {
  defer func() {
    if err := recover(); err != nil {
      fmt.Println("Recover in B")
    }
  }()
  panic("Panic in B")
}

func C() {
  fmt.Println(("Func C"))
}

//输出
// Func A
// Recover in B
// Func C
```