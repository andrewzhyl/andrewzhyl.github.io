<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<title></title>
	<link href="http://127.0.0.1/atom.xml" rel="self" />
	<link href="http://127.0.0.1/" />
	<updated>2021-07-21T23:19:01+08:00</updated>
	<id>http://127.0.0.1/</id>
	<author>
		<name></name>
		<email></email>
	</author>
	
	<entry>
		<title>Docker 入门学习</title>
		<link href="http://127.0.0.1/notes/2017/03/29/Docker%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0.html" />
		<updated>2017-03-29T17:06:00+08:00</updated>
		<id>http://127.0.0.1/notes/2017/03/29/Docker%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0.html</id>
		<content type="html"><![CDATA[<h3 id="docker-的基本概念">Docker 的基本概念：</h3>

<ul>
  <li>镜像(Image)</li>
  <li>容器(Container)</li>
  <li>仓库(Repository)</li>
</ul>

<h3 id="用户权限">用户权限</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo groupadd docker # 增加 docker 用户组
sudo gpasswd -a ${USER} docker  # 当前用户加入 docker
sudo service docker restart # 重启 docker
</code></pre></div></div>

<h3 id="镜像">镜像</h3>

<p>Docker Hub 仓库下载一个 Ubuntu 14.04 操作系统的镜像</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker pull ubuntu:14.04
docker pull dl.dockerpool.com:5000/ubuntu:12.04 #指定服务器地址
</code></pre></div></div>

<p>列出镜像</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker images
</code></pre></div></div>

<p>通过镜像启动容器</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run -t -i training/sinatra /bin/bash
</code></pre></div></div>

<p>修改容器，提交更新后的副本</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker commit -m 'Added json gem' -a 'Docker Newbee' 44ced85d1270 andrew/sinatra:v2
</code></pre></div></div>
<p>-m 用来指定提交的说明信息
-a 指定更新的用户信息
44ced85d1270 是容器的 ID
andrew/sinatra:v2 是仓库名以及 tag 信息</p>

<p>移除镜像</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker rmi training/sinatra
</code></pre></div></div>

<p>清理所有未打标签的镜像</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker rmi $(docker images -q -f "dangling=true")
# docker rmi $(docker images --quiet --filter "dangling=true" # 完整命令
</code></pre></div></div>

<p>不能连接 https://index.docker.io</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker-machine restart default      # Restart the environment
eval $(docker-machine env default)  # Refresh your environment settings
</code></pre></div></div>

<p>利用 Dockerfile 来创建镜像</p>

<h3 id="容器">容器</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run -t -i ubuntu:14.04 /bin/bash
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">-t</code>  选项让 Docker 分配一个伪终端(pseudo-tty)并绑定到容器的标准输入 上
<code class="language-plaintext highlighter-rouge">-i</code>   则让容器的标准输入保持打开</p>

<p>当利用 docker run 来创建容器时,Docker 在后台运行的标准操作包括:</p>

<ul>
  <li>检查本地是否存在指定的镜像,不存在就从公有仓库下载</li>
  <li>利用镜像创建并启动一个容器 分配一个文件系统,并在只读的镜像层外面挂载一层可读写层</li>
  <li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
  <li>从地址池配置一个 ip 地址给容器</li>
  <li>执行用户指定的应用程序</li>
  <li>执行完毕后容器被终止</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker run <span class="nt">-d</span> ubuntu:14.04 /bin/sh <span class="nt">-c</span> <span class="s2">"while true; do echo
</span></code></pre></div></div>

<p>会在后台运行并不会把输出的结果(STDOUT)打印到宿主机上面(输出结果 可以用 <code class="language-plaintext highlighter-rouge">docker logs</code> 查看)</p>

<h4 id="进入容器">进入容器</h4>

<p>1 bashrc_docker</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget <span class="nt">-P</span> ~ https://github.com/yeasy/docker_practice/raw/master/_local/.bashrc_docker<span class="p">;</span>
<span class="nb">echo</span> <span class="s2">"[ -f ~/.bashrc_docker ] &amp;&amp; . ~/.bashrc_docker"</span> <span class="o">&gt;&gt;</span> ~/.bashrc<span class="p">;</span> <span class="nb">source</span> ~/.bashrc

docker-enter &lt;容器id&gt;
</code></pre></div></div>

<p>2 nsenter</p>

<p>$ docker inspect -f {{.State.Pid}} b62a42c75ce2
25234</p>

<p>nsenter –target 25234 –mount –uts –ipc –net –pid</p>

<p>3 exec, 这个简单好用</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> 316f9f5ee7c9  /bin/bash
root@316f9f5ee7c9:/srv/rorapps/rmovie# bash <span class="nt">--login</span>
</code></pre></div></div>

<h4 id="导出容器">导出容器</h4>

<p><code class="language-plaintext highlighter-rouge">docker export</code> 导出容器快照到本地文件</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker ps <span class="nt">-a</span>
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                    PORTS               NAMES
7691a814370e        ubuntu:14.04        <span class="s2">"/bin/bash"</span>         36 hours ago        Exited <span class="o">(</span>0<span class="o">)</span> 21 hours ago                       <span class="nb">test</span>
<span class="nv">$ </span>docker <span class="nb">export </span>7691a814370e <span class="o">&gt;</span> ubuntu.tar
</code></pre></div></div>

<h4 id="导入容器">导入容器</h4>

<p>使用 <code class="language-plaintext highlighter-rouge">docker import</code> 从容器快照文件中再导入为镜像</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cat </span>ubuntu.tar | docker import - <span class="nb">test</span>/ubuntu:v1.0
<span class="nv">$ </span>docker images
REPOSITORY          TAG                 IMAGE ID            CREATED              VIRTUAL SIZE
<span class="nb">test</span>/ubuntu         v1.0                9d37a6082e97        About a minute ago   171.3 MB
</code></pre></div></div>

<h4 id="清除容器">清除容器</h4>

<p>清理所有处于终止状态的容器</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker <span class="nb">rm</span> <span class="si">$(</span>docker ps <span class="nt">-a</span> <span class="nt">-q</span><span class="si">)</span>
</code></pre></div></div>

<h4 id="删除容器">删除容器</h4>

<p><code class="language-plaintext highlighter-rouge">docker rm</code> 来删除一个处于终止状态的容器</p>

<h3 id="网络配置">网络配置</h3>

<h4 id="网络端口映射">网络端口映射</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">-d</span> <span class="nt">-p</span> 127.0.0.1::5000 training/webapp python app.py
</code></pre></div></div>

<p>绑定端口 5000 容器动态端口，并且让 localhost 访问</p>

<h3 id="仓库">仓库</h3>

<p>仓库（Repository）是集中存放镜像的地方</p>

<h4 id="登录">登录</h4>

<p>可以通过执行 <code class="language-plaintext highlighter-rouge">docker login</code> 命令来输入用户名、密码和邮箱来完成注册和登录。 注册成功后，本地用户目录的 <code class="language-plaintext highlighter-rouge">.dockercfg</code> 中将保存用户的认证信息。</p>

<h4 id="基本操作">基本操作</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker search centos <span class="c"># 搜索镜像</span>
docker pull centos <span class="c"># 下载官方镜像到本地</span>
docker push andrewzhyl/rmovie_base:v1  <span class="c"># 上传镜像到公共仓库 Docker Hub</span>
docker tag IMAGE[:TAG] <span class="o">[</span>REGISTRYHOST/][USERNAME/]NAME[:TAG] <span class="c"># 标记镜像，复制一份</span>
</code></pre></div></div>

<h2 id="数据管理">数据管理</h2>

<p>容器中管理数据主要有两种方式:</p>

<ul>
  <li>数据卷（Data volumes）</li>
  <li>数据卷容器（Data volume containers）</li>
</ul>

<h3 id="数据卷">数据卷</h3>

<h4 id="删除数据卷">删除数据卷</h4>

<ul>
  <li>数据卷是被设计用来持久化数据的，它的生命周期独立于容器</li>
  <li>删除容器的时候使用 <code class="language-plaintext highlighter-rouge">docker rm -v</code> 才会删除数据卷，不然不会删除</li>
  <li>Docker 挂载数据卷的默认权限是读写，用户也可以通过 :ro 指定为只读</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker run <span class="nt">-d</span> <span class="nt">-P</span> <span class="nt">--name</span> web <span class="nt">-v</span> /src/webapp:/opt/webapp:ro
training/webapp python app.py
</code></pre></div></div>

<h4 id="挂载一个主机目录作为数据卷">挂载一个主机目录作为数据卷</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run -itd -P --name web -v /home/zhangyulong/rmovie_dev/gems:/srv/rorapps/gems rmovie_dev:v1 /bin/bash
</code></pre></div></div>
<p>挂在主机的 gems 作为 rmovie_dev 的数据卷</p>

<h4 id="查看数据卷的具体信息">查看数据卷的具体信息</h4>

<p>在主机里使用以下命令可以查看指定容器的信息:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker inspect web
</code></pre></div></div>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w"> </span><span class="nl">"Mounts"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
            </span><span class="p">{</span><span class="w">
                </span><span class="nl">"Source"</span><span class="p">:</span><span class="w"> </span><span class="s2">"/home/zhangyulong/rmovie_dev/gems"</span><span class="p">,</span><span class="w">
                </span><span class="nl">"Destination"</span><span class="p">:</span><span class="w"> </span><span class="s2">"/srv/rorapps/gems"</span><span class="p">,</span><span class="w">
                </span><span class="nl">"Mode"</span><span class="p">:</span><span class="w"> </span><span class="s2">""</span><span class="p">,</span><span class="w">
                </span><span class="nl">"RW"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
                </span><span class="nl">"Propagation"</span><span class="p">:</span><span class="w"> </span><span class="s2">"rprivate"</span><span class="w">
            </span><span class="p">}</span><span class="w">
        </span><span class="p">]</span><span class="err">,</span><span class="w">
</span></code></pre></div></div>

<h4 id="挂载一个本地主机文件作为数据卷">挂载一个本地主机文件作为数据卷</h4>

<p>-v 标记也可以从主机挂载单个文件到容器中</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$docker</span> run <span class="nt">--rm</span> <span class="nt">-it</span> <span class="nt">-v</span> ~/.bash_history:/.bash_history ubuntu /bin/bash
</code></pre></div></div>

<p>这样就可以记录在容器输入过的命令了。</p>

<h3 id="数据卷容器">数据卷容器</h3>

<p>持续更新的数据需要在容器之间共享，最好创建数据卷容器</p>

<p>创建 dbdata 数据卷容器</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> docker run -d -v /dbdata --name dbdata training/postgres echo Data-only container for postgres
</code></pre></div></div>

<p>使用 –volumes-from 来挂载 dbdata 容器中的数据卷</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> docker run -d --volumes-from dbdata --name db1 training/postgres
</code></pre></div></div>

<p>然后用 <code class="language-plaintext highlighter-rouge">docker inspect db1</code> 查看容器信息</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     "Mounts": [
            {
                "Name": "04d67060f52ffb5d7604d90f0e453f347dc7b002414a5c3283adf33be9a99d5c",
                "Source": "/var/lib/docker/volumes/04d67060f52ffb5d7604d90f0e453f347dc7b002414a5c3283adf33be9a99d5c/_data",
                "Destination": "/dbdata",
                "Driver": "local",
                "Mode": "",
                "RW": true,
                "Propagation": ""
            }
        ],
</code></pre></div></div>
<p>使用 –volumes-from 参数所挂载数据卷的容器自己并不需要保持在运行状态</p>

<h2 id="使用网络">使用网络</h2>

<p>Docker 允许通过外部访问容器或容器互联的方式来提供网络服务。</p>

<h3 id="外部访问容器">外部访问容器</h3>

<p>使用 -P 标记时，Docker 会随机映射一个 <code class="language-plaintext highlighter-rouge">49000~49900</code> 的端口到内部容器开放的网络端口。
本地主机的 <code class="language-plaintext highlighter-rouge">49155</code> 被映射到了容器的 <code class="language-plaintext highlighter-rouge">5000</code> 端口。此时访问本机的 <code class="language-plaintext highlighter-rouge">49155</code> 端口即可访问容器内  <code class="language-plaintext highlighter-rouge">5000</code> 端口</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker run <span class="nt">-d</span> <span class="nt">-P</span> training/webapp python app.py
<span class="nv">$ </span>docker ps <span class="nt">-l</span>
CONTAINER ID  IMAGE                   COMMAND       CREATED        STATUS        PORTS                    NAMES
bc533791f3f5  training/webapp:latest  python app.py 5 seconds ago  Up 2 seconds  0.0.0.0:49155-&gt;5000/tcp  nostalgic_morse
</code></pre></div></div>

<p>查看日志:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker logs <span class="nt">-f</span> condescending_goldwasser
</code></pre></div></div>

<h4 id="映射所有接口地址">映射所有接口地址</h4>

<p>使用 <code class="language-plaintext highlighter-rouge">hostPort:containerPort</code> 格式本地的 5433 端口映射到容器的 5432 端口，可以执行:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">-it</span> <span class="nt">-p</span> 5433:5432  <span class="nt">--name</span> rmovie_db_dev rmovie_db_dev:9.4
</code></pre></div></div>

<h4 id="映射到指定地址的指定端口">映射到指定地址的指定端口</h4>

<p>可以使用 <code class="language-plaintext highlighter-rouge">ip:hostPort:containerPort</code>格式指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">-it</span> <span class="nt">-p</span> 127.0.0.1:5433:5432  <span class="nt">--name</span> rmovie_db_dev rmovie_db_dev:9.4
</code></pre></div></div>

<h4 id="映射到指定地址的任意端口">映射到指定地址的任意端口</h4>

<p>使用 ip::containerPort 绑定 localhost 的任意端口到容器的 5000 端口，本地主机会自动分配一个端口。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">-it</span> <span class="nt">-p</span> 127.0.0.1::5432  <span class="nt">--name</span> rmovie_db_dev rmovie_db_dev:9.4
</code></pre></div></div>

<p>还可以使用 udp 标记来指定 udp 端口:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker run <span class="nt">-d</span> <span class="nt">-p</span> 127.0.0.1:5000:5000/udp training/webapp python app.py
</code></pre></div></div>

<h5 id="查看端口映射">查看端口映射</h5>

<p>docker port 来查看当前映射的端口配置:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> docker port condescending_goldwasser 5432
0.0.0.0:5433
</code></pre></div></div>

<ul>
  <li>容器有自己的内部网络和 ip 地址（使用 <code class="language-plaintext highlighter-rouge">docker inspect</code> 可以获取所有的变量，Docker 还可以有一个可变的网络配置。）</li>
  <li><code class="language-plaintext highlighter-rouge">-p</code> 标记可以多次使用来绑定多个端口</li>
</ul>

<h3 id="容器互联">容器互联</h3>

<ul>
  <li>容器的连接（linking）系统是除了端口映射外，另一种跟容器中应用交互的方式。</li>
  <li>该系统会在源和接收容器之间创建一个隧道，接收容器可以看到源容器指定的信息。</li>
</ul>

<h4 id="自定义容器命名">自定义容器命名</h4>

<p><code class="language-plaintext highlighter-rouge">--name</code> 标记可以为容器自定义命名:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">-itd</span> <span class="nt">-p</span> 5433:5432  <span class="nt">--name</span> rmovie_db_dev rmovie_db_dev:9.4
</code></pre></div></div>

<p>docker inspect 来查看容器的名字:</p>

<p>docker inspect -f “{{ .Name }}” aed84ee21bde</p>

<p>创建一个数据容器，通过 -v 制定主机目录挂载到:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run  <span class="nt">-v</span> /home/zhangyulong/pgdata:/data <span class="nt">--name</span> dbdata postgres:9.4 <span class="nb">echo</span> <span class="s2">"Data-only container for postgres"</span>
</code></pre></div></div>

<ul>
  <li>容器的名称是唯一的</li>
  <li>在执行 docker run 的时候如果添加 –rm 标记，则容器在终止后会立刻删除</li>
  <li>注意，–rm 和 -d 参数不能同时使用。</li>
</ul>

<h4 id="容器互联-1">容器互联</h4>

<h3 id="常用命令">常用命令</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker rmi <span class="si">$(</span>docker images <span class="nt">-q</span> <span class="nt">-f</span> <span class="s2">"dangling=true"</span><span class="si">)</span>
docker <span class="nb">rm</span> <span class="si">$(</span>docker ps <span class="nt">-a</span> <span class="nt">-q</span><span class="si">)</span>
</code></pre></div></div>
]]></content>
	</entry>
	
	<entry>
		<title>ruby 几个版本的 CPU-bound 实际测试统计</title>
		<link href="http://127.0.0.1/default/2016/10/28/ruby-%E5%87%A0%E4%B8%AA%E7%89%88%E6%9C%AC%E7%9A%84-CPU-bound-%E5%AE%9E%E9%99%85%E6%B5%8B%E8%AF%95%E7%BB%9F%E8%AE%A1.html" />
		<updated>2016-10-28T21:24:00+08:00</updated>
		<id>http://127.0.0.1/default/2016/10/28/ruby-%E5%87%A0%E4%B8%AA%E7%89%88%E6%9C%AC%E7%9A%84-CPU-bound-%E5%AE%9E%E9%99%85%E6%B5%8B%E8%AF%95%E7%BB%9F%E8%AE%A1.html</id>
		<content type="html"><![CDATA[<p>ruby代码：</p>

<ul>
  <li>为了适用于 ree-1.8.7， 这里没有选择 1.9.3 及之后版本标准库的 <code class="language-plaintext highlighter-rouge">prime</code>, 因为那样速度会更快，比较的统计结果会没有意义</li>
</ul>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'benchmark'</span>

<span class="k">def</span> <span class="nf">prime_sieve_upto</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
  <span class="n">all_nums</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">n</span><span class="p">).</span><span class="nf">to_a</span>
  <span class="n">all_nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">all_nums</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kp">nil</span>
  <span class="n">all_nums</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="nb">p</span><span class="o">|</span>

    <span class="c1">#jump over nils</span>
    <span class="k">next</span> <span class="k">unless</span> <span class="nb">p</span>

    <span class="c1">#stop if we're too high already</span>
    <span class="k">break</span> <span class="k">if</span> <span class="nb">p</span> <span class="o">*</span> <span class="nb">p</span> <span class="o">&gt;</span> <span class="n">n</span>

    <span class="c1">#kill all multiples of this number</span>
    <span class="p">(</span><span class="nb">p</span><span class="o">*</span><span class="nb">p</span><span class="p">).</span><span class="nf">step</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">p</span><span class="p">){</span> <span class="o">|</span><span class="n">m</span><span class="o">|</span> <span class="n">all_nums</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="kp">nil</span> <span class="p">}</span>
  <span class="k">end</span>

  <span class="c1">#remove unwanted nils</span>
  <span class="n">all_nums</span><span class="p">.</span><span class="nf">compact</span>
<span class="k">end</span>


<span class="n">primes</span> <span class="o">=</span> <span class="mi">1_000_000</span>
<span class="n">iterations</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">num_threads</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">iterations_per_thread</span> <span class="o">=</span> <span class="n">iterations</span> <span class="o">/</span> <span class="n">num_threads</span>

<span class="no">Benchmark</span><span class="p">.</span><span class="nf">bm</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span>
  <span class="n">x</span><span class="p">.</span><span class="nf">report</span><span class="p">(</span><span class="s1">'single-threaded'</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">iterations</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span>
      <span class="n">prime_sieve_upto</span><span class="p">(</span><span class="n">primes</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="n">x</span><span class="p">.</span><span class="nf">report</span><span class="p">(</span><span class="s1">'multi-threaded'</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">num_threads</span><span class="p">.</span><span class="nf">times</span><span class="p">.</span><span class="nf">map</span> <span class="k">do</span>
      <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
        <span class="n">iterations_per_thread</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span>
          <span class="n">prime_sieve_upto</span><span class="p">(</span><span class="n">primes</span><span class="p">)</span>
        <span class="k">end</span>
      <span class="k">end</span>
    <span class="k">end</span><span class="p">.</span><span class="nf">each</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:join</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

</code></pre></div></div>

<hr />

<p>以下为统计输出结果：</p>

<p>ree-1.8.7-2012.02</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                     user     system      total        real
single-threaded  5.660000   0.060000   5.720000 (  5.725174)
multi-threaded   6.110000   0.110000   6.220000 (  6.228208)
</code></pre></div></div>

<p>MRI ruby  1.9.3-p551</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                      user     system      total        real
single-threaded   3.450000   0.060000   3.510000 (  3.531772)
multi-threaded    3.660000   0.080000   3.740000 (  3.760532)
</code></pre></div></div>

<p>MRI ruby 2.0.0-p598</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                      user     system      total        real
single-threaded   3.630000   0.080000   3.710000 (  3.726324)
multi-threaded    3.680000   0.090000   3.770000 (  3.808694)
</code></pre></div></div>

<p>MRI ruby 2.0.0-p648</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                      user     system      total        real
single-threaded   3.210000   0.060000   3.270000 (  3.276048)
multi-threaded    3.330000   0.080000   3.410000 (  3.402474)
</code></pre></div></div>

<p>MRI ruby  2.1.0</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                      user     system      total        real
single-threaded   2.360000   0.070000   2.430000 (  2.422242)
multi-threaded    2.390000   0.070000   2.460000 (  2.462325)
</code></pre></div></div>

<p>MRI ruby  2.2.3：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                      user     system      total        real
single-threaded   2.300000   0.070000   2.370000 (  2.361750)
multi-threaded    2.410000   0.080000   2.490000 (  2.482332)
</code></pre></div></div>

<p>jruby-9.0.4.0：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                      user     system      total        real
single-threaded   7.740000   0.280000   8.020000 (  2.676519)
multi-threaded   11.760000   0.230000  11.990000 (  3.064823)
</code></pre></div></div>
]]></content>
	</entry>
	
	<entry>
		<title>《Working With Ruby Threads》学习笔记</title>
		<link href="http://127.0.0.1/notes/2016/09/21/Working-With-Ruby-Threads-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html" />
		<updated>2016-09-21T17:08:00+08:00</updated>
		<id>http://127.0.0.1/notes/2016/09/21/Working-With-Ruby-Threads-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</id>
		<content type="html"><![CDATA[<h2 id="introduction">Introduction</h2>

<h3 id="why-care">why care?</h3>

<ul>
  <li>在多核 CPU上，代码必须构建在充分利用多核的架构上才能跑的更快</li>
</ul>

<h3 id="the-promise-of-multi-threading">The promise of multi-threading</h3>

<ul>
  <li>多进程 copy 内存，多线程共享内存</li>
  <li>多线程比多进程开销更小，多线程可以有更多的并发单元</li>
  <li>多线程必须基于线程安全</li>
</ul>

<h2 id="第1章-youre-always-in-a-thread">第1章: You’re Always in a Thread</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>irb
<span class="o">&gt;</span> Thread.main
<span class="o">=&gt;</span> <span class="c">#&lt;Thread:0x007fdc830677c0 run&gt;</span>
<span class="o">&gt;</span> Thread.current <span class="o">==</span> Thread.main <span class="o">=&gt;</span> <span class="nb">true</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Thread.main</code> 总是指向主线程</li>
  <li>主线程退出，其它线程也会终止，并且 ruby 进程会退出</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>irb
<span class="o">&gt;</span> Thread.main
<span class="o">=&gt;</span> <span class="c">#&lt;Thread:0x007fdc830677c0 run&gt;</span>
<span class="o">&gt;</span> Thread.current <span class="o">==</span> Thread.main <span class="o">=&gt;</span> <span class="nb">true</span>
</code></pre></div></div>

<h2 id="第2章threads-of-execution">第2章：Threads of Execution</h2>

<h3 id="shared-address-space">Shared address space</h3>

<ul>
  <li>线程共享一个作用域</li>
  <li>所有 ruby 的线程会映射为一个 native，操作系统线程</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>top <span class="nt">-l1</span> <span class="nt">-pid</span> 8409 <span class="nt">-stats</span> pid,th
</code></pre></div></div>
<p>以上命令可以查看进程 id 为 8409 的线程数量</p>

<h3 id="non-deterministic-context-switching非确定的环境切换">Non-deterministic context switching(非确定的环境切换)</h3>

<p>In order to provide fair access, the thread scheduler can ‘pause’ a thread at any time, suspending its current state
为了提供公平的访问，线程调度能在任意时间 “暂停” 一个线程，暂停它的当前状态</p>

<p><code class="language-plaintext highlighter-rouge">||=</code> 语句不是线程安全的，因为线程可能在任何时间被阻止，如果 A 线程运行 <code class="language-plaintext highlighter-rouge">||=</code> 获得了初始值并且暂停，可能会出现失去 B 线程赋值的情况</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># This statement</span>
<span class="n">results</span> <span class="o">||=</span> <span class="no">Queue</span><span class="p">.</span><span class="nf">new</span>

<span class="c1"># when broken down, becomes something like</span>
<span class="k">if</span> <span class="vi">@results</span><span class="p">.</span><span class="nf">nil?</span> 
 <span class="n">temp</span> <span class="o">=</span> <span class="no">Queue</span><span class="p">.</span><span class="nf">new</span> 
 <span class="vi">@results</span> <span class="o">=</span> <span class="n">temp</span>
<span class="k">end</span>
</code></pre></div></div>

<p>A race condition involves two threads racing to perform an operation on some shared state.
一个竞争条件是在共享状态下，包含两个线程竞争去执行一个同样的操作</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">重要原则：</code></strong>Any time that you have two or more threads trying to modify the same thing at the same time, you’re going to have issues.</li>
  <li>This is because the thread scheduler can interrupt a thread at any time.</li>
</ul>

<p>针对重要原则的两个策略：</p>

<p>1) don’t allow concurrent modification
2) protect concurrent modification</p>

<h2 id="第三章lifecycle-of-a-thread">第三章：Lifecycle of a Thread</h2>

<h3 id="threadnew">Thread.new</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="no">Thread</span><span class="p">.</span><span class="nf">fork</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span> 
<span class="no">Thread</span><span class="p">.</span><span class="nf">start</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">|</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="p">}</span>
</code></pre></div></div>
<p>Thread.new 及其别名方法</p>

<h3 id="threadjoin">Thread#join</h3>

<ul>
  <li>Once you’ve spawned a thread, you can use #join to wait for it to finish</li>
  <li>Without #join, the main thread would exit before the sub-thread can execute its block. Using #join provides a guarantee in this situation.</li>
  <li>Calling #join on the spawned thread will join the current thread of execution with the spawned one</li>
  <li>使用 #join 的时候，异常会在 #join 的时候才抛出，主线程也会执行但不会立即输出</li>
</ul>

<h3 id="threadstatus">Thread#status</h3>

<p><code class="language-plaintext highlighter-rouge">Thread#value</code> 的几个可能值:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">run</code>: Threads currently running have this status.</li>
  <li><code class="language-plaintext highlighter-rouge">sleep</code>: Threads currently sleeping, blocked waiting for a mutex, or waiting on
IO, have this status.(线程当前睡眠状态，阻塞等待一个同步锁，或者 IO)</li>
  <li><code class="language-plaintext highlighter-rouge">false</code>: Threads that finished executing their block of code, or were successfully killed, have this status.(线程已经执行完毕，或者成功被杀掉)</li>
  <li>
    <table>
      <tbody>
        <tr>
          <td><code class="language-plaintext highlighter-rouge">nil</code>: Threads that raised an unhandled exception have this status. wwrt</td>
          <td>33(线程抛出一个未处理的异常，会有返回状态)</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li><code class="language-plaintext highlighter-rouge">aborting</code>: Threads that are currently running, yet dying, have this status(线程当前运行中，但是死掉了了)</li>
</ul>

<h3 id="threadstop">Thread.stop</h3>

<ul>
  <li>这个方法会使线程进入 sleep 状态，然后告诉线程调度器去执行另一个线程</li>
  <li>线程会一直处于 sleep 状态，直到调用 <code class="language-plaintext highlighter-rouge">Thread#wakeup</code></li>
</ul>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'thread'</span>

<span class="n">thread</span> <span class="o">=</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
  <span class="no">Thread</span><span class="p">.</span><span class="nf">stop</span>
  <span class="nb">puts</span> <span class="s2">"Hello there"</span>
<span class="k">end</span>

<span class="c1"># wait for the thread trigger its stop</span>
<span class="nb">puts</span> <span class="s2">"----"</span> <span class="k">until</span> <span class="n">thread</span><span class="p">.</span><span class="nf">status</span> <span class="o">==</span> <span class="s1">'sleep'</span>

<span class="n">thread</span><span class="p">.</span><span class="nf">wakeup</span>
<span class="n">thread</span><span class="p">.</span><span class="nf">join</span>

<span class="c1"># 输出------</span>
<span class="c1"># ----</span>
<span class="c1"># ----</span>
<span class="o">...</span>
<span class="c1"># ----</span>
<span class="c1"># ----</span>
<span class="c1"># ----</span>
<span class="c1"># Hello there</span>
<span class="c1"># [Finished in 1.6s]</span>
</code></pre></div></div>

<h3 id="threadpass">Thread.pass</h3>

<p><code class="language-plaintext highlighter-rouge">Thread.pass</code> 类似于 <code class="language-plaintext highlighter-rouge">Thread.stop</code> 但是他仅仅是让线程调度器去调度另一个线程，不会使当前线程处于 sleep</p>

<h3 id="avoid-threadraise">Avoid Thread#raise</h3>

<ul>
  <li>不推荐使用这个方法，因为会有严重的问题</li>
</ul>

<h3 id="avoid-threadkill">Avoid Thread#kill</h3>

<ul>
  <li>不推荐使用这个方法，跟 <code class="language-plaintext highlighter-rouge">Thread#raise</code> 一样，会有严重的问题</li>
</ul>

<h2 id="第四章concurrent--parallel">第四章：Concurrent != Parallel</h2>

<ul>
  <li>concurrent and parallel are not the same thing
    <ol>
      <li>Do multiple threads run your code concurrently? Yes.</li>
      <li>Do multiple threads run your code in parallel? Maybe.</li>
    </ol>
  </li>
  <li>单核 CPU 执行多个任务是并发的，但是并不一定有顺序执行快</li>
  <li>多核 CPU 执行多个任务是并行的，但是也可以因为某个任务出现问题，然后由其它的线程或进程接管</li>
  <li>并行一定是并发的，并发不一定是并行</li>
</ul>

<h3 id="you-cant-guarantee-anything-will-be-parallel">You can’t guarantee anything will be parallel</h3>

<ul>
  <li>making it execute in parallel is out of your hands. That responsibility is left to the underlying thread scheduler(你亲手让程序并行执行，但是具体的并行的责任是交给底层的调度器来执行的)</li>
  <li>多核 CPU 系统中执行多线程程序，也有可能会在一个 CPU 内核执行，这是由线程调度器决定的</li>
  <li>线程采用公平排队的方式，所有的线程都可以或多或少的使用可用的资源，但是不能有代码来决定</li>
</ul>

<p>扩展阅读</p>
<ul>
  <li>https://blog.golang.org/concurrency-is-not-parallelism</li>
  <li>https://blog.engineyard.com/2011/ruby-concurrency-and-you</li>
</ul>

<h2 id="第五章the-gil-and-mri">第五章：The GIL and MRI</h2>

<ul>
  <li>MRI allows concurrent execution of Ruby code, but prevents parallel execution of Ruby code</li>
</ul>

<h3 id="the-global-lock">The global lock</h3>

<p><code class="language-plaintext highlighter-rouge">GIT</code> 别名：<code class="language-plaintext highlighter-rouge">Global Interpreter Lock</code>， <code class="language-plaintext highlighter-rouge">GVL (Global VM Lock)</code>，  <code class="language-plaintext highlighter-rouge">Global Lock</code></p>

<ul>
  <li>每个 MRI 进程都仅有一个 <code class="language-plaintext highlighter-rouge">GIL</code>,多个进程都有它自己的 <code class="language-plaintext highlighter-rouge">GIL</code></li>
  <li>进程中产生多个线程，这些线程会共享 <code class="language-plaintext highlighter-rouge">GIL</code></li>
  <li>ruby 多线程中，单一线程会在任意给定时间获得 <code class="language-plaintext highlighter-rouge">GIL</code>，其它线程需要等待它释放<code class="language-plaintext highlighter-rouge">GIT</code></li>
  <li>MRI ruby 不能够实现并行</li>
  <li>即使是没有 <code class="language-plaintext highlighter-rouge">GIL</code> 的语言，比如 JAVA,使用多线程也会需要有对相同的公共资源进行访问和修改，如果需要加锁控制，也不能利用到多核并行</li>
  <li>利用多进程实现并行，是 ruby 常用的方式</li>
</ul>

<h3 id="the-special-case-blocking-io特殊情况io-阻塞">The special case: blocking IO(特殊情况：IO 阻塞)</h3>

<ul>
  <li>ruby 中有 <code class="language-plaintext highlighter-rouge">GIL</code> 会阻止并行执行，但是 <code class="language-plaintext highlighter-rouge">IO 阻塞</code> 会释放 <code class="language-plaintext highlighter-rouge">GIL</code></li>
  <li>MRI doesn’t let a thread hog the GIL when it hits blocking IO(当它触发阻塞 IO 的时候，MRI 不会让线程贪婪占用 GIL)</li>
  <li>因为 ruby 有 <code class="language-plaintext highlighter-rouge">GIL</code> ，所以它等于去除了操作系统并行执行的能力，但是等于所有的情况下都不能并行</li>
</ul>

<p>代码在：<code class="language-plaintext highlighter-rouge">chapter05/block_io_demo1.rb</code></p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'open-uri'</span>
<span class="mi">3</span><span class="p">.</span><span class="nf">times</span><span class="p">.</span><span class="nf">map</span> <span class="k">do</span> 
  <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
    <span class="nb">open</span><span class="p">(</span><span class="s1">'http://zombo.com'</span><span class="p">)</span> 
  <span class="k">end</span>
<span class="k">end</span><span class="p">.</span><span class="nf">each</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:value</span><span class="p">)</span>
</code></pre></div></div>

<p>运行以上代码，假设我们已经生成了所有的线程，他们都试图获取 <code class="language-plaintext highlighter-rouge">GIL</code> 来执行代码，Thread A 获得了 <code class="language-plaintext highlighter-rouge">GIL</code>,它创建了一个套接字并且试图打开一个连接到 <code class="language-plaintext highlighter-rouge">zombo.com</code>,这是线程 A 等待响应，并释放了 <code class="language-plaintext highlighter-rouge">GIL</code>, 线程 B 将获得 <code class="language-plaintext highlighter-rouge">GIL</code> 并且和线程 A 执行同样的步骤</p>

<h3 id="why">Why?</h3>

<p>There are three reasons that the GIL exists(几种 GIL 存在的原因 ):</p>

<ol>
  <li>为了在竞争条件下保护 MRI 核心部件
  竞争条件会引起很多问题，这同样的问题会出现在 MRI的 C 内核, ,最简单的办法就是减少竞争的数量，防止多个线程同时运行</li>
  <li>To facilitate the C extension API(为了便于使用 C 扩展 API)
 只要代码块用到了 C 语言扩展 API, GIL 会阻塞其它代码的运行，因为 C 扩展可能不是线程安全的，GIL 的存在保证了线程安全</li>
  <li>To reduce the likelihood of race conditions in your Ruby code(尽可能的减少竞争条件)</li>
</ol>

<h3 id="misconceptions">Misconceptions</h3>

<h4 id="错误1-myth-the-gil-guarantees-your-code-will-be-thread-safegil-保证你的代码是线程安全的">错误1: <code class="language-plaintext highlighter-rouge">Myth: the GIL guarantees your code will be thread-safe.</code>(GIL 保证你的代码是线程安全的)</h4>

<ul>
  <li>这个观点是错误的</li>
  <li>GIL 只是大大减少并行的可能性，但并不能阻止竞争条件的发生，所以 GIL 不会保证线程安全</li>
</ul>

<p>代码在：<code class="language-plaintext highlighter-rouge">chapter04/unsafe_counter.rb</code></p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
<span class="mi">5</span><span class="p">.</span><span class="nf">times</span><span class="p">.</span><span class="nf">map</span> <span class="k">do</span>
  <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="vi">@counter</span>

    <span class="c1"># 加入以下这行，将会导致结果出错，因为 IO 阻塞时，线程会释放 GIL，导致两个线程的 @counter 值相同</span>
    <span class="c1"># puts  temp </span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="vi">@counter</span> <span class="o">=</span> <span class="n">temp</span>
  <span class="k">end</span>
<span class="k">end</span><span class="p">.</span><span class="nf">each</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:join</span><span class="p">)</span>
<span class="nb">puts</span> <span class="vi">@counter</span>

</code></pre></div></div>

<ul>
  <li>以上代码对于 @counter 的增加等同于 <code class="language-plaintext highlighter-rouge">+=</code></li>
  <li>两个线程有可能同时竞争，对于 @counter 进行赋值，结果可能会少于 5，特别是在有 IO 阻塞，或者 JRuby 以及 Rubinius 的环境下会出现</li>
</ul>

<h4 id="错误2myth-the-gil-prevents-concurrency">错误2:<code class="language-plaintext highlighter-rouge">Myth: the GIL prevents concurrency</code></h4>

<ul>
  <li>GIL 阻止了并行(parallel) 执行 ruby 代码，但并不会阻止并发，这是术语的错误</li>
  <li>并发是可能发生的，甚至在单核 CPU 的环境，也会给每一个线程分配资源</li>
  <li>重要点：GIL 允许多个线程同时发生 IO 阻塞，这意味着可以在 ` IO-bound` 的情况下并行的执行代码</li>
</ul>

<h2 id="第六章real-parallel-threading-with-jruby-and-rubinius">第六章：Real Parallel Threading with JRuby and Rubinius</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">JRuby and Rubinius don't have a GIL</code> JRuby 和 Rubinius 没有 GIL</li>
</ul>

<h3 id="proof">Proof</h3>

<p>代码见 <code class="language-plaintext highlighter-rouge">chapter06/prime.rb</code>计算素数， MRI 没有 JRuby 和  Rubinius 快</p>

<p>使用 1.8.7 的版本</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'benchmark'</span>

<span class="k">def</span> <span class="nf">prime_sieve_upto</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
  <span class="n">all_nums</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">n</span><span class="p">).</span><span class="nf">to_a</span>
  <span class="n">all_nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">all_nums</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kp">nil</span>
  <span class="n">all_nums</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="nb">p</span><span class="o">|</span>

    <span class="c1">#jump over nils</span>
    <span class="k">next</span> <span class="k">unless</span> <span class="nb">p</span>

    <span class="c1">#stop if we're too high already</span>
    <span class="k">break</span> <span class="k">if</span> <span class="nb">p</span> <span class="o">*</span> <span class="nb">p</span> <span class="o">&gt;</span> <span class="n">n</span>

    <span class="c1">#kill all multiples of this number</span>
    <span class="p">(</span><span class="nb">p</span><span class="o">*</span><span class="nb">p</span><span class="p">).</span><span class="nf">step</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">p</span><span class="p">){</span> <span class="o">|</span><span class="n">m</span><span class="o">|</span> <span class="n">all_nums</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="kp">nil</span> <span class="p">}</span>
  <span class="k">end</span>

  <span class="c1">#remove unwanted nils</span>
  <span class="n">all_nums</span><span class="p">.</span><span class="nf">compact</span>
<span class="k">end</span>


<span class="n">primes</span> <span class="o">=</span> <span class="mi">1_000_000</span>
<span class="n">iterations</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">num_threads</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">iterations_per_thread</span> <span class="o">=</span> <span class="n">iterations</span> <span class="o">/</span> <span class="n">num_threads</span>

<span class="no">Benchmark</span><span class="p">.</span><span class="nf">bm</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span>
  <span class="n">x</span><span class="p">.</span><span class="nf">report</span><span class="p">(</span><span class="s1">'single-threaded'</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">iterations</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span>
      <span class="n">prime_sieve_upto</span><span class="p">(</span><span class="n">primes</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="n">x</span><span class="p">.</span><span class="nf">report</span><span class="p">(</span><span class="s1">'multi-threaded'</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">num_threads</span><span class="p">.</span><span class="nf">times</span><span class="p">.</span><span class="nf">map</span> <span class="k">do</span>
      <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
        <span class="n">iterations_per_thread</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span>
          <span class="n">prime_sieve_upto</span><span class="p">(</span><span class="n">primes</span><span class="p">)</span>
        <span class="k">end</span>
      <span class="k">end</span>
    <span class="k">end</span><span class="p">.</span><span class="nf">each</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:join</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

</code></pre></div></div>

<p>ree-1.8.7-2012.02</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                     user     system      total        real
single-threaded  5.660000   0.060000   5.720000 (  5.725174)
multi-threaded   6.110000   0.110000   6.220000 (  6.228208)
</code></pre></div></div>

<p>MRI ruby  1.9.3-p551</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                      user     system      total        real
single-threaded   3.450000   0.060000   3.510000 (  3.531772)
multi-threaded    3.660000   0.080000   3.740000 (  3.760532)
</code></pre></div></div>

<p>MRI ruby 2.0.0-p598</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                      user     system      total        real
single-threaded   3.630000   0.080000   3.710000 (  3.726324)
multi-threaded    3.680000   0.090000   3.770000 (  3.808694)
</code></pre></div></div>

<p>MRI ruby 2.0.0-p648</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                      user     system      total        real
single-threaded   3.210000   0.060000   3.270000 (  3.276048)
multi-threaded    3.330000   0.080000   3.410000 (  3.402474)
</code></pre></div></div>

<p>MRI ruby  2.1.0</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                      user     system      total        real
single-threaded   2.360000   0.070000   2.430000 (  2.422242)
multi-threaded    2.390000   0.070000   2.460000 (  2.462325)
</code></pre></div></div>

<p>MRI ruby  2.2.3：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                      user     system      total        real
single-threaded   2.300000   0.070000   2.370000 (  2.361750)
multi-threaded    2.410000   0.080000   2.490000 (  2.482332)
</code></pre></div></div>

<p>jruby-9.0.4.0：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                      user     system      total        real
single-threaded   7.740000   0.280000   8.020000 (  2.676519)
multi-threaded   11.760000   0.230000  11.990000 (  3.064823)
</code></pre></div></div>

<p>MRI ruby 还是一直在进步，Rubinius 就没测试了，装的好慢，可恨的 <code class="language-plaintext highlighter-rouge">GFW</code></p>

<h3 id="so-how-many-should-you-use">So… how many should you use?</h3>

<p>真是应用的或许不是很清晰，可能某处是  IO-bound, 某处是  CPU-bound，也可能都不是，而是 memory-bound，或者也可能在任何地方也并没有最大化消耗资源</p>

<p>以 rails 应用作为例子：</p>

<ul>
  <li>与数据库之间的通信，与客户端通信，调用外部服务，大多数的机会是出现  IO-bound.</li>
  <li>另一方面会调用 CPU, 比如 渲染 HTML 模板， 或者转换数据到 JSON 文件</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">the only way to a surefire answer is to measure</code>:
通过不同的线程数量去运行代码，然后分析测量结果，不通过测量，我们不能找到争取的答案</p>

<h2 id="第七章how-many-threads-are-too-many">第七章：How Many Threads Are Too Many?</h2>

<p>为了从并发获益，我们必须把一个问题拆分为可以同时运行的较小的任务，如果一个问题有不可分割的重要任务，那么使用并发也不能有更多的性能增益</p>

<ul>
  <li>唯一有保证的方法是 measure(测量) 和 compare(比较):</li>
  <li>方法是：尝试在单核 CPU 上用一个线程，然后再试着用 5 个线程，比较两个的执行结果，然后改进它</li>
  <li>新人一般会解决任务会以为更多的线程会比较快</li>
</ul>

<h3 id="all-the-threads">ALL the threads</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1.upto(10_000) do |i|
  Thread.new { sleep }
  puts i
end

以上代码输出：
1
2
...
2043
2044
2045
2046
chapter06/spawning_threads.rb:2:in `initialize': can't create Thread: Resource temporarily unavailable (ThreadError)
</code></pre></div></div>
<ul>
  <li>这是因为 ruby 对一个进程可产生的线程有数量的硬限制</li>
  <li>ree-1.8.7 以及在 linux 系统上，可以产生至少 10000 的线程，但是我们并不可能用到</li>
</ul>

<h4 id="context-switching">Context Switching</h4>

<ul>
  <li>虽然每个线程都需要很少的内存开销，4 核 CPU 只能并行执行 4 个线程，会有大量线程阻塞在 IO 以及大量线程处于空闲状态，线程调度器需要开销去管理这些线程</li>
  <li>虽然需要增加开销，但是产生比内核数量更多的线程也是有意义，因为 IO-bound 会释放 GIL，允许并行执行，而 CPU-bound 在非 MRI 的环境下是可以并行执行的，并且单核 CPU 也是可以实现并发的</li>
</ul>

<h4 id="io-bound">IO-bound</h4>

<ul>
  <li>如果代码执行调用 web 请求的外部服务，有更好的网络连接速度，程序会更快</li>
  <li>如果代码有大量读写硬盘操作，有支持更快读写的硬盘，程序会因为硬件升级而更快</li>
  <li>以上两条是 IO-bound 的情况，因为需要从 IO 设备等待响应，产生比内核更多的线程是有意义的</li>
</ul>

<p>代码例子见：<code class="language-plaintext highlighter-rouge">./chapter06/io_bound.rb</code></p>

<ul>
  <li>如果 IO 操作延迟比较高，我们需要更多的线程去解决 sweet spot, 因为线程多，阻塞等待的时间会更长，如果 IO 延迟比较低，那么我们需要更少的线程去解决 sweet spot,因为等待时间少，线程释放也会很快</li>
</ul>

<h3 id="cpu-bound">CPU-bound</h3>

<p>… 待续</p>

<h2 id="第八章thread-safety">第八章：Thread safety</h2>

<h3 id="whats-really-at-stake">What’s really at stake?</h3>

<p>When your code isn’t thread-safe, the worst that can happen is that your underlying data becomes incorrect
当你的代码不是线程安全的，这最坏的情况会发生，你的基础数据会变得不正确</p>

<ul>
  <li>If your code is ‘thread-safe,’ that means that you can run your code in a multi- threaded context and your underlying data will be safe.(基础数据安全)</li>
  <li>If your code is ‘thread-safe,’ that means that you can run your code in a multi- threaded context and your underlying data remains consistent.(基础数据保持一致)</li>
  <li>If your code is ‘thread-safe,’ that means that you can run your code in a multi- threaded context and the semantics of your program are always correct.(程序在语义上正确)</li>
</ul>

<h3 id="the-computer-is-oblivious">The computer is oblivious</h3>

<ul>
  <li>The computer is unaware of thread-safety issues.</li>
</ul>

<h3 id="is-anything-thread-safe-by-default">Is anything thread-safe by default?</h3>

<ul>
  <li>any concurrent modifications to the same object are not thread- safe.</li>
</ul>

<h2 id="第九章protecting-data-with-mutexes">第九章：Protecting Data with Mutexes</h2>

<h3 id="mutual-exclusion">Mutual exclusion</h3>

<ul>
  <li>If you wrap some section of your code with a mutex, you guarantee that no two threads can enter that section at the same time.(如果你用 mutex 包含一段代码，在同一时间不会有两个线程同时进入)</li>
  <li>Until the owning thread unlocks the mutex, no other thread can lock it(一直到所属的线程解锁前，没有其它线程能锁定)</li>
</ul>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 通用的 mutex 使用方式</span>
<span class="n">mutex</span><span class="p">.</span><span class="nf">synchronize</span> <span class="k">do</span> 
  <span class="n">shared_array</span> <span class="o">&lt;&lt;</span> <span class="kp">nil</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="the-contract">The contract</h3>

<ul>
  <li>注意： <code class="language-plaintext highlighter-rouge">the mutex is shared among all the threads</code> 互斥在所有线程中共享</li>
</ul>

<h3 id="making-key-operations-atomic">Making key operations atomic</h3>
<ul>
  <li>使用 mutex 互斥所的操作需要具有原子性，不然会出现错误的结果</li>
</ul>

<h3 id="mutexes-and-memory-visibility">Mutexes and memory visibility</h3>

<ul>
  <li>mutexes carry an implicit <code class="language-plaintext highlighter-rouge">memory barrier</code>(互斥锁能实现内存屏障)</li>
  <li>程序在运行时内存实际的访问顺序和程序代码编写的访问顺序不一定一致，这就是内存乱序访问, <code class="language-plaintext highlighter-rouge">Memory barrier</code> 能够让 CPU 或编译器在内存访问上有序</li>
</ul>

<h3 id="mutex-performance">Mutex performance</h3>

<ul>
  <li>mutexes inhibit parallelism(互斥锁抑制并行)</li>
  <li><code class="language-plaintext highlighter-rouge">GIL</code> 和互斥锁的行为一样，在同一时间只能有一个线程执行代码</li>
  <li>restrict the critical section to be as small as possible, while still preserving the safety of your data（互斥所限制的部分应该尽可能的小，并且同时保证数据安全性）,限制部分更小，那么可以让其它更多的代码并行执行,就是所谓的<code class="language-plaintext highlighter-rouge">finer-grained mutex</code>细粒度互斥锁</li>
</ul>

<h2 id="第-10-章-signaling-threads-with-condition-variables">第 10 章: Signaling Threads with Condition Variables</h2>

<h3 id="the-api-by-example">The API by example</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ConditionVariable#wait</code> 会 unlock mutex，并使线程进入 sleep</li>
  <li><code class="language-plaintext highlighter-rouge">ConditionVariable#signal</code> 发信号后，第一个等待线程会获取 mutex，并且继续执行</li>
</ul>

<p>代码在：chapter10/xkcd_printer.rb</p>

<h3 id="broadcast">Broadcast</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ConditionVariable#signal</code></li>
</ul>

<p>重开1个正在等待状态变量的线程。重开的线程将尝试ConditionVariable#wait所指的mutex锁。若有等待状态的线程的话，就返回该线程。除此之外将返回nil 。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ConditionVariable#broadcast</code></li>
</ul>

<p>重开所有正在等待状态变量的线程。重开的线程将尝试<code class="language-plaintext highlighter-rouge">ConditionVariable#wait</code> 所指的 mutex 锁</p>

<h2 id="第-11-章-thread-safe-data-structures">第 11 章: Thread-safe Data Structures</h2>

<ul>
  <li>阻塞队列使用放在共享对象内部的 mutex，而不是全局的，对象共享给各个线程，这个有每个共享对象保证自己的并发读写正确</li>
  <li>书中的 <code class="language-plaintext highlighter-rouge">BlockingQueue</code> 使用 <code class="language-plaintext highlighter-rouge">ConditionVariable</code>，如果在队列为空的情况下，让线程进入 sleep</li>
  <li><code class="language-plaintext highlighter-rouge">Queue</code> 是 ruby 标准库提供的唯一线程安全的数据结构，它是通过 <code class="language-plaintext highlighter-rouge">require 'thread'</code> 加载的，它也是阻塞队列</li>
  <li>ruby 的 <code class="language-plaintext highlighter-rouge">Array</code> 和 <code class="language-plaintext highlighter-rouge">Hash</code> 不是线程安全的， Jruby 以及 java 的也不是，在单线程中使用线程安全数据结构会降低性能，但是 java 有替代品</li>
  <li>在 ruby 中，要使用线程安全的 Array 和 Hash，可以用  <code class="language-plaintext highlighter-rouge">thread_safe</code> rubygem 中的 <code class="language-plaintext highlighter-rouge">ThreadSafe::Array</code> <code class="language-plaintext highlighter-rouge">ThreadSafe::Hash</code></li>
</ul>

<h2 id="第-12-章writing-thread-safe-code">第 12 章：Writing Thread-safe Code</h2>

<ul>
  <li>Idiomatic Ruby code is most often thread-safe Ruby code
惯用的(Idiomatic)Ruby 代码往往是线程安全的代码</li>
  <li>Avoid mutating globals 避免修改全局，全局变量会在所有线程中共享
    <ul>
      <li>任何只有一个共享实例的东西都是全局的。比如：Constants（常量），AST(abstract syntax trees)，类变量，类方法</li>
      <li>modifying the AST at runtime is almost always a bad idea, especially when multiple threads are
involved.（在运行时修改 AST 往往是坏主意，特别是在多线程环境下）</li>
      <li>In other words, it’s expected that the AST will be modified at startup time(换句话说，AST 的修改最好在程序启动时)</li>
    </ul>
  </li>
  <li>Create more objects, rather than sharing one(创建更多对象，而不是共享一个)
    <ul>
      <li><strong>Thread-locals:</strong>
多个线程创建多个连接，对于少量的多线程是合适的，但对于并发较高的多线程不太适合，开销过大，改用线程池是比较合适的
        <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Instead of</span>
 <span class="vg">$redis</span> <span class="o">=</span> <span class="no">Redis</span><span class="p">.</span><span class="nf">new</span>
 <span class="c1"># use</span>
 <span class="no">Thread</span><span class="p">.</span><span class="nf">current</span><span class="p">[</span><span class="ss">:redis</span><span class="p">]</span> <span class="o">=</span> <span class="no">Redis</span><span class="p">.</span><span class="nf">new</span>
</code></pre></div>        </div>
      </li>
      <li><strong>Resource pools:</strong>
一个线程池将打开多个连接，或者是需要在多线程中共享的资源，当一个线程要使用一个连接时，它会要求连接池拿出一个连接，线程池负责检查连接是否可用并提供给线程使用，保证线程安全，当线程执行完成后，将连接放回连接池内
connection_pool rubygem：https://github.com/mperham/connection_pool</li>
      <li><strong>Avoid lazy loading（避免延迟加载）：</strong>
<code class="language-plaintext highlighter-rouge">autoload</code>是延迟并在运行时加载，在 MRI ruby 中不是线程安全的，Jruby 中是线程安全的
rails3 中 <code class="language-plaintext highlighter-rouge">autoload</code>  也不是线程安全的，需要启用 <code class="language-plaintext highlighter-rouge">config.threadsafe!</code>，在 rails4 中是线程安全</li>
      <li><strong>Prefer data structures over mutexes：</strong>（优先考虑线程安全的数据结构，而不是互斥锁）
互斥锁 mutex 是很难用好的，你需要决定很多问题：
        <ul>
          <li>互斥的粒度粗细</li>
          <li>哪些代码应该在关键部分</li>
          <li>会不会引发死锁</li>
          <li>需要一个单个实例锁还是全局锁
 大多数程序员并不熟悉 mutex，所以使用线程安全的数据结构就可以避免使用互斥锁的诸多顾虑，<code class="language-plaintext highlighter-rouge">you simply don't need tocreate any mutexes in your code.</code>（你根本不需要在你的代码中创建任何的互斥锁）</li>
          <li><strong>Finding bugs:</strong>
尽管你已经遵循所有的最佳实践，但还是会有莫名其妙的 bug 出现，并且可能非常难以去追踪或重现，最好的办法是去阅读源代码
最常见的问题就是全局的引用，所以你可以试着用 2 个线程去同时访问，通过这样的实践，问题的原因可能会突然浮现</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>… 未完</p>
]]></content>
	</entry>
	
	<entry>
		<title>《Network Programming with Go》学习笔记</title>
		<link href="http://127.0.0.1/notes/2016/09/10/Network-Programming-with-Go-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html" />
		<updated>2016-09-10T04:20:00+08:00</updated>
		<id>http://127.0.0.1/notes/2016/09/10/Network-Programming-with-Go-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html</id>
		<content type="html"><![CDATA[<h2 id="第一章-architecture体系结构">第一章： Architecture(体系结构)</h2>
<h3 id="protocol-layers协议层">Protocol Layers（协议层）</h3>

<p><strong>ISO OSI Protocol</strong>
<img src="/assets/images/network-programming-with-go-golang/1473431812089.png" alt="Alt text" /></p>

<p>每层的功能：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">网络层</code>提供交换及路由技术</li>
  <li><code class="language-plaintext highlighter-rouge">传输层</code>提供了终端系统之间的数据透明传输，并且负责端到端的错误恢复及流程控制</li>
  <li><code class="language-plaintext highlighter-rouge">会话层</code>用来建立、管理、以及终止应用程序之间的连接</li>
  <li><code class="language-plaintext highlighter-rouge">表现层</code>提供数据表现差异的独立性（例如加密）</li>
  <li><code class="language-plaintext highlighter-rouge">应用层</code>支持应用程序和用户程序</li>
</ul>

<p><strong>TCP/IP Protocol</strong></p>

<p><img src="/assets/images/network-programming-with-go-golang/1473773483879.png" alt="Alt text" /></p>

<h3 id="gateways网关">Gateways（网关）</h3>

<p>网关是一个统称，它用于连接起一个或多个网络。</p>

<ul>
  <li>其中的<code class="language-plaintext highlighter-rouge">中继器</code>在物理层面上进行操作，它将信息从一个子网复制到另一个子网上。</li>
  <li><code class="language-plaintext highlighter-rouge">桥接</code>在数据连接层面上进行操作，它在网络之间复制帧。</li>
  <li><code class="language-plaintext highlighter-rouge">路由器</code>在网络层面上进行操作，它不仅在网络之间复制信息，还决定了信息的传输路线。</li>
</ul>

<h3 id="packet-encapsulation数据包封装">Packet encapsulation（数据包封装）</h3>

<ul>
  <li>在OIS或TCP/IP协议栈层与层之间的通信，是通过将数据包从一个层发送到下一个层，最终穿过整个网络的。</li>
  <li>每一层都有必须保持其自身层的管理信息。</li>
  <li>从上层接收到的数据包在向下传递时，会添加头信息。</li>
  <li>在接收端，这些头信息会在向上传递时移除。</li>
</ul>

<p>TFTP（普通文件传输协议）将文件从一台计算机移动到另一台上。它使用IP协议上的UDP协议，该协议可通过以太网发送。看起来就像这样：</p>

<p><img src="/assets/images/network-programming-with-go-golang/1473434814430.png" alt="Alt text" /></p>

<h3 id="connection-models连接模型">Connection Models(连接模型)</h3>

<ul>
  <li>Connection oriented 面向连接模型</li>
  <li>Connectionless 无连接模型</li>
  <li>面向连接模型即为会话建立单个连接，沿着连接进行双向通信，例如 TCP</li>
  <li>在无连接系统中，消息的发送彼此独立。这类似于普通的邮件。无连接模型的消息可能不按顺序抵达。例子就是IP协议</li>
  <li>面向连接的传输可通过无连接模型——基于IP的TCP协议建立。</li>
  <li>无连接传输可通过面向连接模型——基于IP的HTTP协议建立。</li>
</ul>

<h3 id="communications-models通信模型">Communications Models(通信模型)</h3>

<p><strong>Communications Models(消息传递)</strong></p>

<ul>
  <li>并发语言大多使用消息传递的机制，比如 Unix的管道</li>
  <li>Parlog 能在并发的进程之间，将任意的逻辑数据结构当做消息来发送</li>
  <li>消息传递是分布式系统最基本的机制</li>
</ul>

<p><img src="/assets/images/network-programming-with-go-golang/1473674193873.png" alt="Alt text" /></p>

<h3 id="distributed-computing-models分布式计算模型">Distributed Computing Models(分布式计算模型)</h3>

<p><img src="/assets/images/network-programming-with-go-golang/1473674216217.png" alt="Alt text" /></p>

<p>考虑分布式系统的组件是否等价,三种模型：</p>

<ul>
  <li>点对点（peer-to-peer）: 若两个组件等价，且均可发起并响应信息</li>
  <li>过滤器（filter）:有一个组件将信息传至另一个组件，它在修改该信息后会传至第三个组件。
例如：中间组件通过SQL从数据库中获取信息，并将其转换为HTML表单提供给第三个组件（它可能是个浏览器）。</li>
  <li>客户端-服务器(客户端-服务器): 最常见的就是不对等的情况：客户端向服务器发送请求，然后服务端响应</li>
</ul>

<h3 id="clientserver-system">Client/Server System</h3>

<p><img src="/assets/images/network-programming-with-go-golang/1473674889739.png" alt="Alt text" /></p>

<h3 id="clientserver-application">Client/Server Application</h3>

<p><img src="/assets/images/network-programming-with-go-golang/1473674904487.png" alt="Alt text" /></p>

<h3 id="server-distribution服务器分布">Server Distribution（服务器分布）</h3>

<p>单一客户端，单个服务器：</p>

<p><img src="/assets/images/network-programming-with-go-golang/1473675214266.png" alt="Alt text" /></p>

<p>多个客户端，单一服务器：</p>

<p><img src="/assets/images/network-programming-with-go-golang/1473675235161.png" alt="Alt text" /></p>

<p>主站只需接收请求并处理一次，而无需将它们传递给其它服务器来处理。当客户端可能并发时，这就是个通用的模型</p>

<p>单一客户端，多个服务器，例如当业务逻辑服务器从数据库服务器获取信息时</p>

<p><img src="/assets/images/network-programming-with-go-golang/1473675269067.png" alt="Alt text" /></p>

<h3 id="component-distribution">Component Distribution</h3>

<p>分解一些应用的一个简单有效的方式就是把它们看做三部分：</p>

<p>Presentation component 表现组件
Application logic 应用逻辑
Data access 数据访问</p>

<p><strong>表现组件</strong>负责与用户进行交互，即显示数据和采集输入，可以是 GUI 界面，也可以是命令行界面
<strong>应用逻辑组件</strong>负责解释用户的响应，根据应用业务规则，准备查询并管理来自其组件的响应
<strong>数据访问组件</strong>负责存储并检索数据。这一般是通过数据库进行，不过也不一定</p>

<p><img src="/assets/images/network-programming-with-go-golang/1473676063281.png" alt="Alt text" /></p>

<p>Example: Distributed Database：
Gartner第一种分类</p>

<p><img src="/assets/images/network-programming-with-go-golang/1473676645585.png" alt="Alt text" /></p>

<p>例如 google map 会下载附近的地图为浏览器中的小型数据库，当用户移动了地图时，可以快速响应</p>

<p>Example: Network File Service 网络文件服务</p>

<p><img src="/assets/images/network-programming-with-go-golang/1473676805222.png" alt="Alt text" /></p>

<p>Gartner第二种分类允许远程客户端访问已共享的文件系统
这类系统的例子：NFS、Microsoft共享和DCE等等。</p>

<p>Example: Web:</p>

<p><img src="/assets/images/network-programming-with-go-golang/1473676919558.png" alt="Alt text" /></p>

<p>Gartner第三种分类的一个例子就是Web上的小型Java应用</p>

<p>Example: Terminal Emulation</p>

<p><img src="/assets/images/network-programming-with-go-golang/1473677181590.png" alt="Alt text" /></p>

<p>Gartner第四种分类就是终端仿真。这允许远程系统在本地系统上作为普通的终端：
Telnet就是最常见的例子。</p>

<p><strong>Three Tier Models</strong>:
可以有三层、四层甚至多层。下图展示了一些可能的三层模型:</p>

<p><img src="/assets/images/network-programming-with-go-golang/1473677365117.png" alt="Alt text" /></p>

<h3 id="middleware-model-中间件模型">Middleware model 中间件模型</h3>

<p><img src="/assets/images/network-programming-with-go-golang/1473677961430.png" alt="Alt text" /></p>

<p>中间件示例</p>

<ul>
  <li>像终端模拟器、文件传输或电子邮件这样的基础服务</li>
  <li>像RPC这样的基础服务</li>
  <li>像DCE、网络O/S这样的一体化服务</li>
  <li>像CORBA、OLE/ActiveX这样的分布式对象服务</li>
  <li>像RMI、Jini这样的移动对象服务</li>
  <li>万维网</li>
</ul>

<p>中间件的功能包括：</p>

<ul>
  <li>在不同计算机上初始化过程</li>
  <li>进行会话管理</li>
  <li>允许客户端定位服务器的目录服务</li>
  <li>进行远程数据访问</li>
  <li>允许服务器处理多个客户端的并发控制</li>
  <li>保证安全性和完整性</li>
  <li>监控</li>
  <li>终止本地处理和远程处理</li>
</ul>

<h3 id="continuum-of-processing">Continuum of Processing</h3>

<p>Gartner模型基于将一个应用分解为表现组件、应用逻辑和数据处理。一个更细粒度的分解方式为:</p>

<p><img src="/assets/images/network-programming-with-go-golang/1473678080293.png" alt="Alt text" /></p>

<h3 id="points-of-failure">Points of Failure</h3>

<p>分布式应用一般运行在复杂的环境中。这使得它比单一计算机上的独立应用更易发生故障。故障点包括：</p>

<ul>
  <li>The client side of the application could crash</li>
  <li>The client system may have h/w problems</li>
  <li>The client’s network card could fail</li>
  <li>Network contention could cause timeouts</li>
  <li>There may be network address conflicts</li>
  <li>Network elements such as routers could fail</li>
  <li>Transmission errors may lose messages</li>
  <li>The client and server versions may be incompatable</li>
  <li>The server’s network card could fail</li>
  <li>The server system may have h/w problems</li>
  <li>The server s/w may crash</li>
  <li>The server’s database may become corrupted</li>
</ul>

<h3 id="acceptance-factors">Acceptance Factors</h3>

<ul>
  <li>Reliability</li>
  <li>Performance</li>
  <li>Responsiveness</li>
  <li>Scalability</li>
  <li>Capacity</li>
  <li>Security</li>
</ul>

<h3 id="transparency">Transparency</h3>
<p>分布式系统的“圣杯”就是提供以下几点：</p>

<ul>
  <li>access transparency</li>
  <li>location transparency</li>
  <li>migration transparency</li>
  <li>replication transparency</li>
  <li>concurrency transparency</li>
  <li>scalability transparency</li>
  <li>performance transparency</li>
  <li>failure transparency</li>
</ul>

<h3 id="eight-fallacies-of-distributed-computing分布式计算的八个误区">Eight fallacies of distributed computing:分布式计算的八个误区</h3>

<ul>
  <li>The network is reliable.</li>
  <li>Latency is zero.</li>
  <li>Bandwidth is infinite.</li>
  <li>The network is secure.</li>
  <li>Topology doesn’t change.</li>
  <li>There is one administrator.</li>
  <li>Transport cost is zero.</li>
  <li>The network is homogeneous.</li>
</ul>

<h2 id="第3章-socket-level-programming套接字层编程">第3章： Socket-level Programming(套接字层编程)</h2>

<h3 id="the-tcpip-stack">The TCP/IP stack</h3>

<p>The TCP/IP stack is shorter than the OSI one:</p>

<p><img src="/assets/images/network-programming-with-go-golang/1473773483879.png" alt="Alt text" /></p>

<ul>
  <li>TCP is a connection-oriented protocol,</li>
  <li>UDP (User Datagram Protocol) is a connectionless protocol.</li>
</ul>

<h4 id="ip-datagrams">IP datagrams</h4>

<ul>
  <li>IP 是无连接协议</li>
  <li>IP datagrams 之间的关联必须由高层协议来提供支持</li>
  <li>IP层包头支持数据校验，在包头包括源地址和目的地址</li>
  <li>IP层包头支持数据校验，在包头包括源地址和目的地址</li>
</ul>

<h4 id="udptcp">UDP&amp;TCP</h4>

<ul>
  <li>UDP是无连接的，不可靠的。它包括IP数据报的内容和端口号的校验</li>
  <li>TCP是构建于IP之上的面向链接的协议。它提供了一个虚电路使得两个应用进程可以通过它来通信。它通过端口号来识别主机上的服务</li>
</ul>

<h3 id="internet-addresses">Internet addresses</h3>

<ul>
  <li>IPV4 由四位数字组成，各自的范围在 0~255,每一组数字可以用 8 位二进制数字来表示，合计共需 32 位二进制</li>
  <li>IPv6使用128位地址，即使表达同样的地址，字节数变得很麻烦，由’:’分隔的4位16进制组成。一个典型的例子如：2002:c0e8:82e7:0:0:0:c0e8:82e7。</li>
</ul>

<h3 id="ip-address-type">IP address type</h3>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">IPAddr</span> <span class="p">{</span>
    <span class="n">IP</span> <span class="n">IP</span>
<span class="p">}</span>
</code></pre></div></div>

<p>IPAddr 最主要的用法是 DNS 查询</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">ResolveIPAddr</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">addr</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="n">IPAddr</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">Error</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">addr</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">net</span><span class="o">.</span><span class="n">ResolveIPAddr</span><span class="p">(</span><span class="s">"ip"</span><span class="p">,</span><span class="s">"www.google.com"</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Resolution error"</span><span class="p">,</span> <span class="n">err</span><span class="o">.</span><span class="n">Error</span><span class="p">())</span>
    <span class="n">os</span><span class="o">.</span><span class="n">Exit</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Resolved address is "</span><span class="p">,</span> <span class="n">addr</span><span class="o">.</span><span class="n">String</span><span class="p">())</span>
  <span class="c">// 输出</span>
  <span class="c">// Resolved address is  243.185.187.39</span>
</code></pre></div></div>

<p><strong>Host lookup</strong></p>

<p><code class="language-plaintext highlighter-rouge">ResolveIPAddr</code> 执行一个 DNS 查找，返回单个的 IP 地址</p>

<p><code class="language-plaintext highlighter-rouge">LookupHost</code> 执行 DNS 查找，返回字符串切片，ipv4 和 ipv6 的 ip 地址</p>

<p><code class="language-plaintext highlighter-rouge">LookupCNAME</code>返回公认的主机名称</p>

<h3 id="34-services">3.4 Services</h3>

<p>端口号：This is an unsigned integer between 1 and 65,535</p>

<p>“standard” ports：</p>

<ul>
  <li>Telnet usually uses port 23 with the TCP protocol.</li>
  <li>DNS uses port 53, either with TCP or with UDP.</li>
  <li>FTP uses ports 21 and 20</li>
  <li>HTTP usually uses port 80, but it often uses ports 8000, 8080 and 8088, all with TCP</li>
  <li>The X Window System often takes ports 6000-6007, both on TCP and UDP.</li>
</ul>

<p>unix 系统中常用的端口列在 <code class="language-plaintext highlighter-rouge">/etc/services</code></p>

<p><code class="language-plaintext highlighter-rouge">LookupPort</code> 方法查询整个端口</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">LookupPort</span><span class="p">(</span><span class="n">network</span><span class="p">,</span> <span class="n">service</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="n">port</span> <span class="kt">int</span><span class="p">,</span> <span class="n">err</span> <span class="n">os</span><span class="o">.</span><span class="n">Error</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>The type TCPAddr</strong>:</p>

<p><code class="language-plaintext highlighter-rouge">TCPAddr</code> 是一个包含 IP 和 Port 的结构</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">TCPAddr</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">IP</span>   <span class="n">IP</span>
    <span class="n">Port</span> <span class="kt">int</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">ResolveTCPAddr</code> 创建一个 <code class="language-plaintext highlighter-rouge">TCPAddr</code></p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">ResolveTCPAddr</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">addr</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="n">TCPAddr</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">Error</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">net</code> 可选： <code class="language-plaintext highlighter-rouge">tcp</code>, <code class="language-plaintext highlighter-rouge">tcp4</code> or <code class="language-plaintext highlighter-rouge">tcp6</code>
<code class="language-plaintext highlighter-rouge">addr</code>:  主机名或 IP 地址，中间是 <code class="language-plaintext highlighter-rouge">:</code>,后面跟端口号，本机的话，可以简写 <code class="language-plaintext highlighter-rouge">:80</code></p>

<h3 id="35-tcp-sockets">3.5 TCP Sockets</h3>

<p>` net.TCPConn` 支持在客户端和服务端，全双工可读可写的通信</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">TCPConn</span><span class="p">)</span> <span class="n">Write</span><span class="p">(</span><span class="n">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">,</span> <span class="n">err</span> <span class="n">os</span><span class="o">.</span><span class="n">Error</span><span class="p">)</span>
<span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">TCPConn</span><span class="p">)</span> <span class="n">Read</span><span class="p">(</span><span class="n">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">,</span> <span class="n">err</span> <span class="n">os</span><span class="o">.</span><span class="n">Error</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>TCP client</strong>：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">DialTCP</span><span class="p">(</span><span class="n">net</span> <span class="kt">string</span><span class="p">,</span> <span class="n">laddr</span><span class="p">,</span> <span class="n">raddr</span> <span class="o">*</span><span class="n">TCPAddr</span><span class="p">)</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">TCPConn</span><span class="p">,</span> <span class="n">err</span> <span class="n">os</span><span class="o">.</span><span class="n">Error</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">DialTCP</code> 函数可以建立 TCP 连接</li>
  <li>客户端和服务器使用 <code class="language-plaintext highlighter-rouge">TCPConn</code>  交换信息，请求或者响应，直到关闭连接</li>
  <li><code class="language-plaintext highlighter-rouge">laddr</code> 是本机地址， <code class="language-plaintext highlighter-rouge">raddr</code> 是远程服务地址</li>
  <li><code class="language-plaintext highlighter-rouge">net</code> 是可选的  <code class="language-plaintext highlighter-rouge">tcp4</code>, <code class="language-plaintext highlighter-rouge">tcp6</code> or <code class="language-plaintext highlighter-rouge">tcp</code></li>
</ul>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">ListenTCP</span><span class="p">(</span><span class="n">net</span> <span class="kt">string</span><span class="p">,</span> <span class="n">laddr</span> <span class="o">*</span><span class="n">TCPAddr</span><span class="p">)</span> <span class="p">(</span><span class="n">l</span> <span class="o">*</span><span class="n">TCPListener</span><span class="p">,</span> <span class="n">err</span> <span class="n">os</span><span class="o">.</span><span class="n">Error</span><span class="p">)</span>
<span class="k">func</span> <span class="p">(</span><span class="n">l</span> <span class="o">*</span><span class="n">TCPListener</span><span class="p">)</span> <span class="n">Accept</span><span class="p">()</span> <span class="p">(</span><span class="n">c</span> <span class="n">Conn</span><span class="p">,</span> <span class="n">err</span> <span class="n">os</span><span class="o">.</span><span class="n">Error</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">ListenTCP</code> 函数，侦听本地的地址在指定端口，<code class="language-plaintext highlighter-rouge">Accept</code> 阻塞，然后等待客户端连接</p>

<h3 id="36-controlling-tcp-connections">3.6 Controlling TCP connections</h3>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">TCPConn</span><span class="p">)</span> <span class="n">SetTimeout</span><span class="p">(</span><span class="n">nsec</span> <span class="kt">int64</span><span class="p">)</span> <span class="n">os</span><span class="o">.</span><span class="n">Error</span>
</code></pre></div></div>

<p>客户端和服务器设置超时用 <code class="language-plaintext highlighter-rouge">SetTimeout</code>，函数在 “net” 包</p>

<p><strong>Staying alive:</strong></p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">TCPConn</span><span class="p">)</span> <span class="n">SetKeepAlive</span><span class="p">(</span><span class="n">keepalive</span> <span class="kt">bool</span><span class="p">)</span> <span class="n">os</span><span class="o">.</span><span class="n">Error</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">SetKeepAlive</code> 可以设置客户端保持连接，函数在 “net” 包</p>

<h3 id="37-udp-datagrams">3.7 UDP Datagrams</h3>

<p>UDP 的函数：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">ResolveUDPAddr</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">addr</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="n">UDPAddr</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">Error</span><span class="p">)</span>
<span class="k">func</span> <span class="n">DialUDP</span><span class="p">(</span><span class="n">net</span> <span class="kt">string</span><span class="p">,</span> <span class="n">laddr</span><span class="p">,</span> <span class="n">raddr</span> <span class="o">*</span><span class="n">UDPAddr</span><span class="p">)</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">UDPConn</span><span class="p">,</span> <span class="n">err</span> <span class="n">os</span><span class="o">.</span><span class="n">Error</span><span class="p">)</span>
<span class="k">func</span> <span class="n">ListenUDP</span><span class="p">(</span><span class="n">net</span> <span class="kt">string</span><span class="p">,</span> <span class="n">laddr</span> <span class="o">*</span><span class="n">UDPAddr</span><span class="p">)</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">UDPConn</span><span class="p">,</span> <span class="n">err</span> <span class="n">os</span><span class="o">.</span><span class="n">Error</span><span class="p">)</span>
<span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">UDPConn</span><span class="p">)</span> <span class="n">ReadFromUDP</span><span class="p">(</span><span class="n">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">,</span> <span class="n">addr</span> <span class="o">*</span><span class="n">UDPAddr</span><span class="p">,</span> <span class="n">err</span> <span class="n">os</span><span class="o">.</span><span class="n">Error</span>
<span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">UDPConn</span><span class="p">)</span> <span class="n">WriteToUDP</span><span class="p">(</span><span class="n">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="n">addr</span> <span class="o">*</span><span class="n">UDPAddr</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">,</span> <span class="n">err</span> <span class="n">os</span><span class="o">.</span><span class="n">Error</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="38-server-listening-on-multiple-sockets">3.8 Server listening on multiple sockets</h3>

<ul>
  <li>go 的底层利用的是系统调用 <code class="language-plaintext highlighter-rouge">select(2)</code></li>
  <li><code class="language-plaintext highlighter-rouge">select(2)</code> 可以检测同时等待的多个 I/O,告诉哪个可以读写</li>
</ul>

<pre><code class="language-gcode">/* c 函数*/
int select(int maxfd, fd_set *readfds, fd_set *writefds, fe_set *exceptfds, const struct timeval *timeout);
</code></pre>

<ul>
  <li>select 的第一个参数是文件描述符集中要被检测的比特数，这个值必须至少比待检测的最大文件描述符大1</li>
  <li>参数 readfds 指定了被读监控的文件描述符集</li>
  <li>参数 writefds 指定了被写监控的文件描述符集</li>
  <li>参数exceptfds指定了被例外条件监控的文件描述符集。</li>
  <li>参数timeout起了定时器的作用：到了指定的时间，无论是否有设备准备好，都返回调用</li>
</ul>

<h3 id="39-the-types-conn-packetconn-and-listener">3.9 The types Conn, PacketConn and Listener</h3>

<p>使用  <code class="language-plaintext highlighter-rouge">Dial</code> 可以替代指定类型的 TCP and UDP 的建立连接方法</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">Dial</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">laddr</span><span class="p">,</span> <span class="n">raddr</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="n">c</span> <span class="n">Conn</span><span class="p">,</span> <span class="n">err</span> <span class="n">os</span><span class="o">.</span><span class="n">Error</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">net</code> 可选：”tcp”, “tcp4” (IPv4-only), “tcp6” (IPv6-only), “udp”, “udp4” (IPv4-only), “udp6” (IPv6-only), “ip”, “ip4” (IPv4-only) and “ip6” IPv6-only)</li>
  <li>函数返回一个适应的 <code class="language-plaintext highlighter-rouge">Conn</code> 接口</li>
  <li><code class="language-plaintext highlighter-rouge">raddr</code> 是字符串</li>
</ul>

<p>IPGetHeadInfo 源代码例子  <code class="language-plaintext highlighter-rouge">chapter03/IPGetHeadInfo.go</code>
ThreadedIPEchoServer 源代码例子  <code class="language-plaintext highlighter-rouge">chapter03/ThreadedIPEchoServer.go</code></p>

<p>未完。。。。</p>
]]></content>
	</entry>
	
	<entry>
		<title>《理解 UNIX 进程》学习笔记</title>
		<link href="http://127.0.0.1/notes/2016/08/13/%E7%90%86%E8%A7%A3-UNIX-%E8%BF%9B%E7%A8%8B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html" />
		<updated>2016-08-13T04:20:00+08:00</updated>
		<id>http://127.0.0.1/notes/2016/08/13/%E7%90%86%E8%A7%A3-UNIX-%E8%BF%9B%E7%A8%8B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</id>
		<content type="html"><![CDATA[<p>@(学习笔记)</p>

<p><img src="/assets/images/working_with_unix_processes.png" alt="本书结构图" /></p>

<h2 id="系统调用命令库函数">系统调用/命令/库函数</h2>

<ol>
  <li>用户在shell环境中可以操作的命令或可执行文件</li>
  <li>系统内核可调用的函数与工具等</li>
  <li>一些常用的函数（function）与函数库（library），大部分为C的函数库（libc）</li>
  <li>设备文件的说明，通常是在/dev下的文件</li>
  <li>配置文件或者是某些文件的格式</li>
  <li>游戏（games）</li>
  <li>惯例与协议等，例如Linux文件系统、网络协议、ASCII code等说明</li>
  <li>系统管理员可用的管理命令</li>
  <li>跟kernel有关的文件</li>
</ol>

<hr />

<table>
  <thead>
    <tr>
      <th style="text-align: left">系统调用</th>
      <th style="text-align: left">ruby</th>
      <th style="text-align: center">描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">select(2)</code></td>
      <td style="text-align: left"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">getpid(2)</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">Process.pid</code> 或 全局变量 <code class="language-plaintext highlighter-rouge">$$</code></td>
      <td style="text-align: center">获取当前进程的 pid</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">getppid(2)</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">Process.ppid</code></td>
      <td style="text-align: center">获取当前父进程的 pid</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">ps(1)</code></td>
      <td style="text-align: left"> </td>
      <td style="text-align: center">进程状态</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">open(2)</code></td>
      <td style="text-align: left"> </td>
      <td style="text-align: center">打开或创建一个文件</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">close(2)</code></td>
      <td style="text-align: left"> </td>
      <td style="text-align: center">删除一个描述符(关闭一个打开的文件)</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">read(2)</code></td>
      <td style="text-align: left"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">write(2)</code></td>
      <td style="text-align: left"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">fsync(2)</code></td>
      <td style="text-align: left"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">stat(2)</code></td>
      <td style="text-align: left"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">getrlimit(2)</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">Process.getrlimit</code></td>
      <td style="text-align: center">查询资源限制，比如 <code class="language-plaintext highlighter-rouge">Process.getrlimit(:NOFILE)</code> 查询进程可以打开的最大文件数</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">setrlimit(2)</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">Process.setrlimit</code></td>
      <td style="text-align: center">修改资源限制，比如 <code class="language-plaintext highlighter-rouge">Process.setrlimit(:NOFILE, 10000)</code> 修改可以打开的最大文件数到 10000</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">stat(2)</code></td>
      <td style="text-align: left"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">setenv(3)</code>,<code class="language-plaintext highlighter-rouge">getenv(3)</code></td>
      <td style="text-align: left"> </td>
      <td style="text-align: center">设置或获取环境变量</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">fork(2)</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">Kenel#fork</code></td>
      <td style="text-align: center">允许运行中的进程已编程的方式衍生(forking)子进程，子进程和原进程一模一样</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">waitpid(2)</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">Process.wait</code>及其表亲</td>
      <td style="text-align: center">阻塞并等待随机或指定子进程退出</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">kill(2)</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">Process.kill</code></td>
      <td style="text-align: center">向pid所指进程发送信号。signal可以是信号编号或名称(字符串或Symbol)。若信号是负值(或信号名称前面带有-时), 则向进程组而非进程发送信号</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">sigaction(2)</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">Kernel#trap</code></td>
      <td style="text-align: center">捕获信号并设置一个信号处理程序</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">pipe(2)</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">IO.pipe</code></td>
      <td style="text-align: center">创建一个管道</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">socketpair(2)</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">Socket.pair</code></td>
      <td style="text-align: center">创建可以用过消息通信的 Unix 套接字</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">recv(2)</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">Socket#recv</code></td>
      <td style="text-align: center">从TCP连接的另一端接收数据。该函数的第一个参数指定接收端套接字描述，第二个参数指明一个缓冲区，该缓冲区用来存放recv函数接收到的数据</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">send(2)</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">Socket.send</code></td>
      <td style="text-align: center">向TCP连接的另一端发送数据</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">setsid(2)</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">Process.setsid</code></td>
      <td style="text-align: center">1. 将进程编程一个新会话的会话领导，2. 该进程变成一个新进程组的组长， 3. 该进程没有控制终端</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">getpgrp(2)</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">Process.getpgrp</code></td>
      <td style="text-align: center">获取进程组 id</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">system(3)</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">Kernel#system</code></td>
      <td style="text-align: center">系统调用函数，底层是 <code class="language-plaintext highlighter-rouge">fork(2)</code></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">execv2(2)</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">Kernel#exec</code></td>
      <td style="text-align: center">系统调用函数，底层是 <code class="language-plaintext highlighter-rouge">fork(2)</code></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">popen(3)</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">IO.popen</code></td>
      <td style="text-align: center">底层是 <code class="language-plaintext highlighter-rouge">fork+exec</code>,设置了一个管道，用于同生成进程进行通信</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">posix_spawn(2)</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">posix-spawn(2)</code></td>
      <td style="text-align: center">会获得父进程已打开的所有文件描述符的副本，但不会获得内存中所有内容的副本</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="理解-unix-进程2基础知识">理解 UNIX 进程（2）：基础知识</h2>

<h3 id="24-系统调用">2.4 系统调用</h3>

<ul>
  <li>UNIX 系统的组成：用户空间(userland) 和内核。</li>
  <li>程序不可以直接访问内核，所有通信都是通过系统调用来完成</li>
  <li>所有的程序都运行在用户空间。</li>
  <li>系统调用允许你的用户空间程序通过内核间接地与计算机硬件进行交互</li>
</ul>

<h3 id="25-命名法wtf2">2.5 命名法，wtf(2)</h3>

<p>Linux 系统手册常用的节：</p>

<ul>
  <li>节1：一般命令(shell)</li>
  <li>节2： 系统调用</li>
  <li>节3：C 库函数</li>
  <li>节4：特殊文件</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>man 2 getpid # 从节2 查看 getpid 使用说明
man find # 等同于 man 1 find
</code></pre></div></div>

<h3 id="26-unix-进程之本">2.6 Unix 进程之本</h3>

<ul>
  <li>所有的代码都是在进程中执行的。</li>
  <li>一个进程可以生成并管理其他多个进程</li>
</ul>

<hr />

<h2 id="理解-unix-进程3进程皆有标识">理解 UNIX 进程（3）：进程皆有标识</h2>

<ul>
  <li>进程都有一个唯一的进程标识符，称为 <code class="language-plaintext highlighter-rouge">pid</code></li>
  <li><code class="language-plaintext highlighter-rouge">pid</code> 是一个顺序数字标识，不传达进程本身的任何信息</li>
  <li>查看进程命令: ` ps -p <pid-of-irb-process>`</pid-of-irb-process></li>
  <li>ruby 的 <code class="language-plaintext highlighter-rouge">Process.pid</code> 对应于系统调用 <code class="language-plaintext highlighter-rouge">getpid(2)</code></li>
</ul>

<hr />

<h2 id="理解-unix-进程4进程皆有父">理解 UNIX 进程（4）：进程皆有父</h2>
<ul>
  <li>系统中运行的每一个进程都有对应的父进程</li>
  <li>每个进程都知道其父进程标识符（称为 ppid）</li>
</ul>

<p>ruby 获取父进程：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">puts</span> <span class="no">Process</span><span class="p">.</span><span class="nf">ppid</span>
</code></pre></div></div>

<p><strong>实践领域</strong></p>

<ul>
  <li>ppid 一般用于检测守护进程</li>
  <li>ruby 的 <code class="language-plaintext highlighter-rouge">Process.ppid</code> 对应系统调用 <code class="language-plaintext highlighter-rouge">getppid(2)</code></li>
</ul>

<hr />

<h2 id="理解-unix-进程5进程皆有文件描述符">理解 UNIX 进程（5）：进程皆有文件描述符</h2>

<p>文件描述符代表打开的文件</p>

<h3 id="51-万物皆为文件">5.1 万物皆为文件</h3>

<ul>
  <li>UNIX 中一切皆为文件，包括（设备、管道、套接字等），书中用 <code class="language-plaintext highlighter-rouge">资源</code> 表示</li>
  <li>传统定义（文件系统中的文件）的时候，将使用 <code class="language-plaintext highlighter-rouge">文件</code> 表示</li>
</ul>

<h3 id="52-描述符代表资源">5.2 描述符代表资源</h3>

<ul>
  <li>在进程中打开一个资源，会获得一个文件描述符编号（<code class="language-plaintext highlighter-rouge">file descriptor number</code>）</li>
  <li>文件描述符不会在无关进程之间共享，它只存在于其所属的进程之中。</li>
  <li>进程结束后，文件描述符会和进程打开的资源一同被关闭</li>
  <li>ruby 中，任何一个 IO 对象都有一个相关联的文件描述符编号，用 <code class="language-plaintext highlighter-rouge">IO#fileno</code> 访问</li>
  <li>进程打开的所有资源都会获得一个用于标识的唯一数字。这是内核跟踪进程所用资源的方法</li>
</ul>

<h3 id="53-标准流">5.3 标准流</h3>

<p>在通常情况下，UNIX每个程序在开始运行的时刻，都会有3个已经打开的 stream. 分别用来输入，输出，打印诊断和错误信息。通常他们会被连接到用户终端（tty(4)）. 但也可以改变到其它文件或设备。这取决于双亲进程的选择和设置。</p>

<p>每个 UNIX 进程都有三个打开的资源：标准输入（STDIN）、标准输出(STDOUT) 和标准错误(STDERR)</p>

<p><strong>STDIN</strong>:
提供了一种从键盘或管道中读取输入的通用方法</p>

<p><strong>STDOUT</strong> 和 <strong>STDERR</strong>
提供了一种向显示器、文件、打印机等输出写入内容的通用方法</p>

<p>每个进程的 <code class="language-plaintext highlighter-rouge">0,1,2</code> 三个文件描述符编号分别属于 <code class="language-plaintext highlighter-rouge">STDIN,STDOUT,STDERR</code></p>

<h3 id="stdinstdoutstderr和stdinstdoutstderr的区别">STDIN、STDOUT、STDERR和$stdin、$stdout、$stderr的区别</h3>

<ul>
  <li>STDIN这一组以大写字母开头，是常量</li>
  <li><code class="language-plaintext highlighter-rouge">$stdin</code> 这一组以$开头，是全局变量</li>
  <li>常量不可变，STDOUT总指向屏幕显示（除非运行ruby时在命令行设置&gt;out 2&gt;err之类）</li>
  <li>变量可变，所以 <code class="language-plaintext highlighter-rouge">$stdin</code> 可以替换成别的IO/File对象</li>
  <li>全局的输出方法，如print puts等，总是向 <code class="language-plaintext highlighter-rouge">$stdout</code> 输出，而非向 <code class="language-plaintext highlighter-rouge">STDOUT </code>输出，如：</li>
</ul>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nb">print</span> <span class="mi">1</span> <span class="c1"># 最开始时$stdout和STDOUT是一致的，输出到屏幕 </span>

  <span class="vg">$stdout</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">'output_file'</span><span class="p">,</span><span class="s1">'w'</span><span class="p">)</span> <span class="c1"># $stdout指向另一个File对象</span>
  <span class="nb">print</span> <span class="mi">2</span> <span class="c1"># 这时输出到output_file了 </span>

  <span class="vg">$stdout</span> <span class="o">=</span> <span class="no">STDOUT</span>  <span class="c1"># $stdout和STDOUT又指向同一个对象了</span>
  <span class="nb">print</span> <span class="mi">3</span> <span class="c1"># 又输出到屏幕了 </span>
</code></pre></div></div>

<hr />

<h2 id="理解-unix-进程6进程皆有资源限制">理解 UNIX 进程（6）：进程皆有资源限制</h2>
<p>@(学习笔记)</p>

<ul>
  <li>文件描述符编号一直处理递增状态</li>
  <li>内核为进程施加了某些资源限制</li>
</ul>

<h3 id="61-找出限制">6.1 找出限制</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>p Process.getrlimit(:NOFILE) # 查询可打开的最大文件数
# =&gt; [4864, 9223372036854775807]
</code></pre></div></div>

<ul>
  <li>返回值第一个元素是文件描述符数量的软限制(soft limit)，超过软限制将会产生异常</li>
  <li>第二个元素是文件描述符数量的硬限制(hard limit),实际上表示无限制</li>
</ul>

<h3 id="63-提高软限制">6.3 提高软限制</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="no">Process</span><span class="p">.</span><span class="nf">setrlimit</span><span class="p">(</span><span class="ss">:NOFILE</span><span class="p">,</span> <span class="mi">5886</span><span class="p">)</span>
 <span class="nb">p</span> <span class="no">Process</span><span class="p">.</span><span class="nf">getrlimit</span><span class="p">(</span><span class="ss">:NOFILE</span><span class="p">)</span>
 <span class="c1">#=&gt; [5886, 5886]</span>
</code></pre></div></div>

<ul>
  <li>软限制和硬限制都被设置成了 5886</li>
  <li>可以给 ` Process.setrlimit` 传递第 3 个参数来制定新的硬限制</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>P  Process.setrlimit(:NOFILE, Process.getrlimit(:NOFILE)[1])
</code></pre></div></div>
<p>设置文件描述符数量限制为最大，其实我本机只能设置到 <code class="language-plaintext highlighter-rouge">10000</code> 左右</p>

<h3 id="64-超出限制">6.4 超出限制</h3>

<p>打开 irb 输入：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Process.setrlimit(:NOFILE, 8)
# 会出现 `output=': Too many open files - dup (Errno::EMFILE)
</code></pre></div></div>
<p>因为进程打开时默认已经使用了 8个文件描述符编号，这时再操作会有错误出现</p>

<p>打开 irb 输入：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Process.setrlimit(:NOFILE, 9)
 f = File.open('/dev/null')
# 会出现 Errno::EMFILE: Too many open files @ rb_sysopen - /dev/null
</code></pre></div></div>

<h3 id="65-其它资源限制">6.5 其它资源限制</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 当前用户所允许的最大并发进程数</span>
<span class="no">Process</span><span class="p">.</span><span class="nf">getrlimit</span><span class="p">(</span><span class="ss">:NPROC</span><span class="p">)</span>

<span class="c1"># 可以创建的最大的文件</span>
<span class="no">Process</span><span class="p">.</span><span class="nf">getrlimit</span><span class="p">(</span><span class="ss">:FSIZE</span><span class="p">)</span>

<span class="c1"># 用于进程栈的最大段的大小</span>
<span class="no">Process</span><span class="p">.</span><span class="nf">getrlimit</span><span class="p">(</span><span class="ss">:STACK</span><span class="p">)</span>
</code></pre></div></div>
<p>请查看 Process.getrlimit 文档查看完整的可用选项列表</p>

<h3 id="66-实践领域">6.6 实践领域</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">httperf</code> 是一款多并发测试工具，需要提高系统的软限制才可以创建更多的并发</li>
  <li>我们还可以在执行第三方代码的时候，对代码所属进程进行设置限制，并取消修改限制的权限，确保其无法超出徐克范围的资源数量</li>
</ul>

<h3 id="67-系统调用">6.7 系统调用</h3>

<p><code class="language-plaintext highlighter-rouge">Process.getrlimit</code> 对应系统调用的 <code class="language-plaintext highlighter-rouge">getrlimit(2)</code>
<code class="language-plaintext highlighter-rouge">Process.setrlimit</code> 对应系统调用的 <code class="language-plaintext highlighter-rouge">setrlimit(2)</code></p>

<hr />

<h2 id="理解-unix-进程7进程皆有环境">理解 UNIX 进程（7）：进程皆有环境</h2>

<ul>
  <li>环境变量是包含进程数据的键-值对(<code class="language-plaintext highlighter-rouge">key-value pairs</code>)</li>
  <li>每个进程都有环境变量，由父进程设置并由子进程继承</li>
</ul>

<h3 id="71-环境变量是散列吗">7.1 环境变量是散列吗？</h3>

<ul>
  <li>ENV 使用了散列式的存取器 API，但并非 HASH</li>
  <li>它实现了 <code class="language-plaintext highlighter-rouge">Enumerable</code> 和部分 <code class="language-plaintext highlighter-rouge">Hash API</code>, 但不是全部，<code class="language-plaintext highlighter-rouge">merge</code> 就没有实现</li>
  <li>系统调用不能直接操作环境变量，但 C 库函数 <code class="language-plaintext highlighter-rouge">setenv(3)</code> 和 <code class="language-plaintext highlighter-rouge">getenv(3)</code> 可以</li>
</ul>

<hr />

<h2 id="理解-unix-进程8进程皆有参数">理解 UNIX 进程（8）：进程皆有参数</h2>

<ul>
  <li>所有进程都可以访问 <code class="language-plaintext highlighter-rouge">ARGV</code> 的特殊数组</li>
  <li>argv 是 argumant vector 的缩写，表示参数向量或数组</li>
  <li>有些库会读取 <code class="language-plaintext highlighter-rouge">ARGV</code> 来解析命令行选项，我们可以在读取前修改它</li>
</ul>

<h3 id="实践领域">实践领域</h3>

<ul>
  <li>ARGV 常用于将文件名作为参数传入程序</li>
</ul>

<hr />

<h2 id="理解-unix-进程9进程皆有名">理解 UNIX 进程（9）：进程皆有名</h2>

<p>进程的非自身通信方式：</p>

<ul>
  <li>通过文件系统，写入日志信息的方式来了解彼此的状态</li>
  <li>借助网络来打开套接字通其它进程进行通过</li>
</ul>

<p>进程自身的通信机制：一个是进程名称，另一个是退出码</p>

<h3 id="91-进程命名">9.1 进程命名</h3>

<ul>
  <li>每个进程都要一个名称</li>
  <li>进程可以在运行期间被修改作为一种通信手段</li>
  <li>ruby 中用全局变量 <code class="language-plaintext highlighter-rouge">$PROGRAM_NAME</code> 或 <code class="language-plaintext highlighter-rouge">$0</code> 获得当前进程名称</li>
</ul>

<hr />

<h2 id="理解-unix-进程10进程皆有退出码">理解 UNIX 进程（10）：进程皆有退出码</h2>

<ul>
  <li>进程在结束的时候都带有数字退出码(0~255), 用于指明进程是否顺利结束</li>
  <li>退出码为 0 表示顺利结束，其它的表示各种错误</li>
  <li>退出码也是一种进程的通信途径</li>
</ul>

<h3 id="如何退出进程">如何退出进程</h3>

<ul>
  <li>ruby 中用 <code class="language-plaintext highlighter-rouge">kernel#exit</code> 来退出进程，退出码是 0，但是亦可以定制 `exit 22</li>
  <li><code class="language-plaintext highlighter-rouge">kernel#exit</code>  被调用，退出之前，会调用 <code class="language-plaintext highlighter-rouge">at_exit</code> 定义的语句块</li>
  <li>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">kernel#exit！</code>  被调用，退出码设置为 1，不会调用 <code class="language-plaintext highlighter-rouge">at_exit</code></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">kernel#abort</code> 从错误进程中退出的通用方法，会将当前进程的退出码设置为 1</li>
  <li><code class="language-plaintext highlighter-rouge">kernel#abort</code> 退出码设置为 1， 也会调用 <code class="language-plaintext highlighter-rouge">at_exit</code></li>
  <li><code class="language-plaintext highlighter-rouge">kernel#raise</code> 不会立即结束进程，只是抛出异常，会沿着调用栈向上传递，如果不处理，那么异常会终结该进程</li>
  <li><code class="language-plaintext highlighter-rouge">kernel#raise</code> 退出码设置为 1，也会调用 <code class="language-plaintext highlighter-rouge">at_exit</code></li>
</ul>

<hr />

<h2 id="理解-unix-进程11进程皆可衍生">理解 UNIX 进程（11）：进程皆可衍生</h2>

<h3 id="111-luke使用-fork2">11.1 Luke,使用 fork(2)</h3>

<ul>
  <li>衍生(forking) 是 Unix 编程中最强大的概念之一</li>
  <li><code class="language-plaintext highlighter-rouge">fork(2)</code> 系统调用，允许运行中的进程以编程的形式创建新的进程，这个新进程和原始进程一模一样</li>
</ul>

<p>fork 工作原理：</p>

<ul>
  <li>调用 <code class="language-plaintext highlighter-rouge">fork(2)</code> 的进程是 “父进程”，新创建的进程是 “子进程”</li>
  <li>子进程从父进程出集成了其所占用内存中的所有内容，以及所有属于父进程的已打开的文件描述符</li>
  <li>子进程的 ppid 是父进程的 pid</li>
  <li>子进程获得了父进程所有的文件描述符的编号，两个进程可以共享打开的文件、套接字等</li>
  <li>子进程继承了父进程内存中的所有内容</li>
  <li>fork 调用几乎瞬间就可以返回，速度很快，比分别载入 3 个应用程序实例要快的多</li>
  <li>子进程可以随意更改其内存内容的副本，而不会对父进程造成任何影响</li>
</ul>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="nb">fork</span>
  <span class="nb">puts</span> <span class="s2">"</span><span class="si">#{</span><span class="no">Process</span><span class="p">.</span><span class="nf">pid</span><span class="si">}</span><span class="s2"> entered the if block"</span>
<span class="k">else</span>
  <span class="nb">puts</span> <span class="s2">"</span><span class="si">#{</span><span class="no">Process</span><span class="p">.</span><span class="nf">pid</span><span class="si">}</span><span class="s2"> entered the else block"</span>
<span class="k">end</span>
</code></pre></div></div>

<ul>
  <li>以上 if 和 else 都会被执行</li>
  <li>在父进程中，fork 范湖新创建的子进程的 pid，整数值为真，执行 if 语句块</li>
  <li>在子进程中，fork 返回 nil ，所以子进程执行了 else 语句块</li>
</ul>

<h3 id="112-多核编程">11.2 多核编程</h3>

<ul>
  <li>通过生成新的进程，你的代码可以(不能完全保证)被分配到多个 CPU 核心中,实现多核并发</li>
  <li>如果系统繁忙，可能 4 个进程都由一个 CPU 来处理</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">注意：</code></strong></p>

<p><code class="language-plaintext highlighter-rouge">fork(2)</code> 创建了一个和旧进程一模一样的新进程，如果父进程使用了 500M 内存进行了衍生，那么就会有 1GB 的内存被占用了，重复同样的操作 10 次，很快会耗尽所有的内容，这通常被称为 “fork 炸弹”(for bomb)</p>

<h3 id="113-使用-block">11.3 使用 block</h3>

<ul>
  <li>将一个 block 传递给 fork 方法，那么 block 会在新的子进程中执行，而父进程会跳过 block 中的内容</li>
  <li>子进程执行完 block 之后就会推出，不会像父进程那样执行随后的代码</li>
</ul>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">fork</span> <span class="k">do</span>
  <span class="c1"># 此处的代码仅在子进程中执行</span>
<span class="k">end</span>
<span class="c1"># 此处的代码仅在父进程中执行</span>
</code></pre></div></div>

<h3 id="115-系统调用">11.5 系统调用</h3>

<p><code class="language-plaintext highlighter-rouge">kenel#fork</code> 对应系统调用 <code class="language-plaintext highlighter-rouge">fork(2)</code></p>

<hr />

<h2 id="理解-unix-进程12孤儿进程">理解 UNIX 进程（12）：孤儿进程</h2>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">fork</span> <span class="k">do</span> 
  <span class="mi">100</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span>
    <span class="nb">sleep</span> <span class="mi">1</span>
    <span class="nb">puts</span> <span class="s2">"I'm an orphan! </span><span class="si">#{</span><span class="no">Process</span><span class="p">.</span><span class="nf">pid</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="nb">abort</span> <span class="s2">"Parent process died..."</span>
</code></pre></div></div>
<p>示例代码，父进程退出之后，子进程还没有退出，称为孤儿进程</p>

<p>管理孤儿：</p>

<ul>
  <li>守护进程：守护进程是一种长期运行的进程，为了能够一直保持运行，他们有意作为孤儿进程存在</li>
  <li>使用 Unix 信号来与脱离终端会话的进程进行通信</li>
</ul>

<hr />

<h2 id="理解-unix-进程13友好的进程">理解 UNIX 进程（13）：友好的进程</h2>

<ul>
  <li>Unix 系统采用写时复制(copy-on-write, COW) 的方法来优化</li>
  <li>CoW 是把子进程对父进程实际的内存复制操作推迟到了真正需要写入的时候</li>
  <li>如果不支持 Cow,子进程需要复制父进程所占内存内容的完整副本</li>
</ul>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>

<span class="nb">fork</span> <span class="k">do</span> 
  <span class="c1"># 此时子进程已经完成初始化</span>
  <span class="c1"># 借助 COW，子进程不需要复制变量 arr,因为他没有修改任何共享变量</span>
  <span class="c1"># 因此可以继续从和父进程同样的内存位置进行读取</span>
  <span class="nb">p</span> <span class="n">arr</span>
<span class="k">end</span>

<span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>

<span class="nb">fork</span> <span class="k">do</span>
<span class="c1"># 此时子进程已经完成初始化</span>
  <span class="c1"># 由于 COW，子进程不需要复制变量 arr</span>
  <span class="n">arr</span> <span class="o">&lt;&lt;</span> <span class="mi">45</span>
  <span class="c1"># 绗棉的代码修改了数组，因此在进行修改之前需要为子进程创建一个该数组的</span>
  <span class="c1"># 副本。父进程中的这个数组并不会收到影响</span>
<span class="k">end</span>
</code></pre></div></div>

<ul>
  <li>使用 COW策略，fork(2) 的速度会很快，因为子进程只获取了它所需要的那部分数据的副本，其余部分依然可以共享</li>
  <li>MRI 或 Rubinius 对其并不支持， Ruby2.0 以上版本会提供 Cow 友好的垃圾收集器</li>
  <li>Ruby 企业版(Ruby Enterprise Edition) 是 COW 友好的 ruby 版本</li>
</ul>

<blockquote>
  <p>MRI 的垃圾收集器会用 “标记-清除” (mark-and-sweep) 的算法，当垃圾收集器被调用时，它必须对每个已知的对象进行迭代并写入信息，指出该对象是否应该被回收。
  因此在衍生之后，首次进行垃圾收集的时候，写时复制所带来的好处会被撤销</p>
</blockquote>

<hr />

<h2 id="理解-unix-进程14进程可待">理解 UNIX 进程（14）：进程可待</h2>

<h3 id="看顾babysitting">看顾(Babysitting)</h3>

<ul>
  <li>ruby 的 <code class="language-plaintext highlighter-rouge">Process.wait</code> 是一个阻塞调用，会一直等待父进程的某个子进程退出之后才继续执行</li>
  <li><code class="language-plaintext highlighter-rouge">Process.wait</code> 的返回值是某个子进程的 pid</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fork do 
  5.times do 
    sleep 1
    puts "I am an orphan!"
  end
end

puts Process.wait # 等待某个子进程执行完毕
abort "Parent process died..."
</code></pre></div></div>

<h3 id="processwait-一家子">Process.wait 一家子</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Process.wait</code> 返回的一个值是 pid,<code class="language-plaintext highlighter-rouge">Process.wait2</code> 返回的两个值是(pid, status)</li>
  <li><code class="language-plaintext highlighter-rouge">Process.waitpid</code> 接收一个进程 pid 等待指定进程退出，pid 为 -1 时和 <code class="language-plaintext highlighter-rouge">Process.wait</code> 不带参数功能一样</li>
  <li><code class="language-plaintext highlighter-rouge">Process.waitpid2</code>  和 <code class="language-plaintext highlighter-rouge">Process.wait2</code> 对应，  <code class="language-plaintext highlighter-rouge">Process.waitpid</code> 和 类似 <code class="language-plaintext highlighter-rouge">Process.wait</code> 对应</li>
</ul>

<h3 id="竞争条件">竞争条件</h3>

<ul>
  <li>内核会将退出的进程信息加入队列，这样一来父进程总是能够依靠子进程退出的顺序接收到信息(实际并不是按顺序，最好使用 <code class="language-plaintext highlighter-rouge">Process.waitpid</code> 指定 id</li>
  <li>如果不存在子进程 <code class="language-plaintext highlighter-rouge">Process.wait</code> 会抛出 <code class="language-plaintext highlighter-rouge">Errno::ECHILD</code> 异常</li>
</ul>

<h2 id="146-实践领域">14.6 实践领域</h2>

<p>关注子进程是 unix 编程模型的核心，被称为 <code class="language-plaintext highlighter-rouge">看顾进程(Babysitting)</code>, <code class="language-plaintext highlighter-rouge">master/worker</code> 或 <code class="language-plaintext highlighter-rouge">preforking</code></p>

<blockquote>
  <p>如果你有一个衍生出多个并发子进程的进程，这个进程看管着这些子进程，确保他们能够保持响应，并对子进程的退出做出回应</p>
</blockquote>

<h2 id="147-系统调用">14.7 系统调用</h2>

<p>ruby 的 <code class="language-plaintext highlighter-rouge">Process.wait</code> 及其表亲都对应于系统调用 <code class="language-plaintext highlighter-rouge">waitpid(2)</code></p>

<hr />

<h2 id="理解-unix-进程15僵尸进程">理解 UNIX 进程（15）：僵尸进程</h2>

<h3 id="151-等待终有结果">15.1 等待终有结果</h3>

<p>使用 <code class="language-plaintext highlighter-rouge">Process.detach(pid)</code> 分离子进程，它会生成一个新线程，此线程 的唯一工作就是等待 pid 退出.
这样可以保证内核不会一直保留不需要的的进程信息</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">pid</span> <span class="o">=</span> <span class="nb">fork</span> <span class="k">do</span>
    <span class="mi">5</span><span class="p">.</span><span class="nf">times</span> <span class="p">{</span>
      <span class="nb">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
      <span class="nb">puts</span> <span class="s2">"thread..</span><span class="si">#{</span><span class="no">Process</span><span class="p">.</span><span class="nf">pid</span><span class="si">}</span><span class="s2">"</span>
    <span class="p">}</span>
  <span class="k">end</span>
   
<span class="c1"># 这行代码确保子进程不会变成僵尸</span>
  <span class="no">Process</span><span class="p">.</span><span class="nf">detach</span><span class="p">(</span><span class="n">pid</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="152-僵尸长什么样子">15.2 僵尸长什么样子</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#创建一个子进程， 1 秒钟之后推出</span>
<span class="n">pid</span> <span class="o">=</span> <span class="nb">fork</span><span class="p">{</span> <span class="nb">sleep</span> <span class="mi">1</span><span class="p">}</span>
<span class="c1">#打印子进程的 pid</span>
<span class="nb">puts</span> <span class="n">pid</span>
<span class="c1"># 让父进程长眠，以便于我们检查子进程的进程状态信息</span>
<span class="nb">sleep</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ps <span class="nt">-ho</span> pid,state <span class="nt">-p</span> 7132
</code></pre></div></div>
<p>终端输入以上代码，会显示僵尸进程的状态信息，7132 是进程 pid, 状态为 <code class="language-plaintext highlighter-rouge">z</code> 或 <code class="language-plaintext highlighter-rouge">Z+</code> 表示是僵尸进程</p>

<h3 id="153-实践领域">15.3 实践领域</h3>

<ul>
  <li>任何子进程在结束之时其父进程仍在运行，那么子进程会成为僵尸</li>
  <li>一旦父进程读取了僵尸进程的状态信息，那么它将不复存在，也不会再消耗内核资源</li>
</ul>

<h3 id="154-系统调用">15.4 系统调用</h3>

<p><code class="language-plaintext highlighter-rouge">Process.detach(pid)</code> 没有对应系统调用，因为ruby 仅仅使用线程和 <code class="language-plaintext highlighter-rouge">Process.wait</code> 来实现它</p>

<hr />

<h2 id="理解-unix-进程16进程皆可获得信号">理解 UNIX 进程（16）：进程皆可获得信号</h2>

<p><code class="language-plaintext highlighter-rouge">Process.wait</code> 是阻塞调用，知道子进程结束，调用才会返回(除非加第二个参数)</p>

<h3 id="161-捕获-sigchld">16.1 捕获 SIGCHLD</h3>

<ul>
  <li>通过 <code class="language-plaintext highlighter-rouge">trap(:CHLD)</code> 可以捕获 :CHLD 信号</li>
  <li>通过捕获 :CHLD, 内核会提醒父进程它的子进程何时退出</li>
</ul>

<p>代码见 snippet/signal_chld_native.rb</p>

<h3 id="162-sigchld-与并发">16.2 SIGCHLD 与并发</h3>

<ul>
  <li>信号投递是不可靠的</li>
  <li>Process.wait 加入第二个参数，这样是非阻塞的调用,可用于确保统计每个子进程的</li>
  <li>如果没有子进程存在，<code class="language-plaintext highlighter-rouge">Process.wait</code> 乃至其变量，将会抛出 <code class="language-plaintext highlighter-rouge">Errno::ECHILD</code> 异常</li>
</ul>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pid</span> <span class="o">=</span> <span class="no">Process</span><span class="p">.</span><span class="nf">wait</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="no">Process</span><span class="o">::</span><span class="no">WNOHANG</span><span class="p">)</span>
</code></pre></div></div>

<p>以上练习代码在 <code class="language-plaintext highlighter-rouge">snippets/signal_chld_nohang.rb</code></p>

<h3 id="163-信号入门">16.3 信号入门</h3>

<p>信号是一种异步通信，进程从内核接收信号时，可以执行以下操作：</p>

<ul>
  <li>忽略该信号</li>
  <li>执行特定的操作</li>
  <li>执行默认的操作</li>
</ul>

<h3 id="164-信号来自何方">16.4 信号来自何方</h3>

<ul>
  <li>信号由内核发送，但信号是从一个进程发送到另一个进程，只不过是借用内核作为中介。</li>
  <li>信号最初的目的是用来指定终结进程的不同方式</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">注意：ruby 的 Irb 环境,定义了自己的信号处理程序，跟系统本身和 ruby 程序本身不同</code></p>

<p>启动两个 ruby 进程，使用信号来结束其中一个
(1) 在第一个 ruby 会话中执行以下代码：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">puts</span> <span class="no">Process</span><span class="p">.</span><span class="nf">pid</span>
<span class="nb">sleep</span> <span class="c1"># 休眠，以便于有时间发送信号</span>
</code></pre></div></div>

<p>(2) 在第二个 ruby 会话中发送信号中介第一个会话：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Process</span><span class="p">.</span><span class="nf">kill</span><span class="p">(</span><span class="ss">:INT</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">pid</span> <span class="n">of</span> <span class="n">first</span> <span class="n">session</span><span class="o">&gt;</span><span class="p">)</span>
</code></pre></div></div>

<p>INT 是 <code class="language-plaintext highlighter-rouge">INTERRUPT</code>(中断)缩写，第二个进程会像第一个进程发送一个 <code class="language-plaintext highlighter-rouge">INT</code> 信号</p>

<h3 id="165-信号一览">16.5 信号一览</h3>

<p>信号命名的时候，名字中的 <code class="language-plaintext highlighter-rouge">SIG</code> 部分是可选的。表中 <code class="language-plaintext highlighter-rouge">动作</code> 一列描述了每个信号的默认操作</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">动作</th>
      <th style="text-align: left">描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">Term</td>
      <td style="text-align: left">表示进程会立即结束</td>
    </tr>
    <tr>
      <td style="text-align: left">Core</td>
      <td style="text-align: left">表示进程会立即结束并进行核心转储(栈跟踪)</td>
    </tr>
    <tr>
      <td style="text-align: left">Ign</td>
      <td style="text-align: left">表示进程会忽略该信号</td>
    </tr>
    <tr>
      <td style="text-align: left">Stop</td>
      <td style="text-align: left">表示进程会停止运行(暂停)</td>
    </tr>
    <tr>
      <td style="text-align: left">Cont</td>
      <td style="text-align: left">表示进程会恢复运行(继续)</td>
    </tr>
  </tbody>
</table>

<p>Unix 系统通常支持的信号：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">信号</th>
      <th style="text-align: left">值</th>
      <th style="text-align: left">动作</th>
      <th style="text-align: left">注释</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">SIG<code class="language-plaintext highlighter-rouge">HUP</code></td>
      <td style="text-align: left">1</td>
      <td style="text-align: left">Term</td>
      <td style="text-align: left">由控制终端或控制进程终止时发出</td>
    </tr>
    <tr>
      <td style="text-align: left">SIG<code class="language-plaintext highlighter-rouge">INT</code></td>
      <td style="text-align: left">2</td>
      <td style="text-align: left">Term</td>
      <td style="text-align: left">来自键盘的中断信号(通常是 <code class="language-plaintext highlighter-rouge">Ctrl-C</code> )</td>
    </tr>
    <tr>
      <td style="text-align: left">SIG<code class="language-plaintext highlighter-rouge">QUIT</code></td>
      <td style="text-align: left">3</td>
      <td style="text-align: left">Core</td>
      <td style="text-align: left">来自键盘的退出信号(通常是 <code class="language-plaintext highlighter-rouge">Ctrl-/</code> )</td>
    </tr>
    <tr>
      <td style="text-align: left">SIG<code class="language-plaintext highlighter-rouge">ILL</code></td>
      <td style="text-align: left">4</td>
      <td style="text-align: left">Core</td>
      <td style="text-align: left">非法指令</td>
    </tr>
    <tr>
      <td style="text-align: left">SIG<code class="language-plaintext highlighter-rouge">ABRT</code></td>
      <td style="text-align: left">6</td>
      <td style="text-align: left">Core</td>
      <td style="text-align: left">来自 abort(3) 的终止信号</td>
    </tr>
    <tr>
      <td style="text-align: left">SIG<code class="language-plaintext highlighter-rouge">FPE</code></td>
      <td style="text-align: left">8</td>
      <td style="text-align: left">Core</td>
      <td style="text-align: left">浮点数异常</td>
    </tr>
    <tr>
      <td style="text-align: left">SIG<code class="language-plaintext highlighter-rouge">KILL</code></td>
      <td style="text-align: left">9</td>
      <td style="text-align: left">Term</td>
      <td style="text-align: left">kill 信号</td>
    </tr>
    <tr>
      <td style="text-align: left">SIG<code class="language-plaintext highlighter-rouge">SEGV</code></td>
      <td style="text-align: left">11</td>
      <td style="text-align: left">Core</td>
      <td style="text-align: left">非法内存地址引用</td>
    </tr>
    <tr>
      <td style="text-align: left">SIG<code class="language-plaintext highlighter-rouge">PIPE</code></td>
      <td style="text-align: left">13</td>
      <td style="text-align: left">Term</td>
      <td style="text-align: left">管道损坏(Broken pipe):向没有读取进程的管道写入信息</td>
    </tr>
    <tr>
      <td style="text-align: left">SIG<code class="language-plaintext highlighter-rouge">ALRM</code></td>
      <td style="text-align: left">14</td>
      <td style="text-align: left">Term</td>
      <td style="text-align: left">来自 alarm(2) 的计时器到时信号</td>
    </tr>
    <tr>
      <td style="text-align: left">SIG<code class="language-plaintext highlighter-rouge">TERM</code></td>
      <td style="text-align: left">15</td>
      <td style="text-align: left">Term</td>
      <td style="text-align: left">终止信号</td>
    </tr>
    <tr>
      <td style="text-align: left">SIG<code class="language-plaintext highlighter-rouge">USR1</code></td>
      <td style="text-align: left">30,10,16</td>
      <td style="text-align: left">Term</td>
      <td style="text-align: left">用户自定义信号 1</td>
    </tr>
    <tr>
      <td style="text-align: left">SIG<code class="language-plaintext highlighter-rouge">USR2</code></td>
      <td style="text-align: left">31,12,17</td>
      <td style="text-align: left">Term</td>
      <td style="text-align: left">用户自定义信号 2</td>
    </tr>
    <tr>
      <td style="text-align: left">SIG<code class="language-plaintext highlighter-rouge">CHLD</code></td>
      <td style="text-align: left">20,17,18</td>
      <td style="text-align: left">Ign</td>
      <td style="text-align: left">子进程停止或终止</td>
    </tr>
    <tr>
      <td style="text-align: left">SIG<code class="language-plaintext highlighter-rouge">CONT</code></td>
      <td style="text-align: left">19,18,25</td>
      <td style="text-align: left">Cont</td>
      <td style="text-align: left">如果停止，则继续执行</td>
    </tr>
    <tr>
      <td style="text-align: left">SIG<code class="language-plaintext highlighter-rouge">STOP</code></td>
      <td style="text-align: left">17,19,23</td>
      <td style="text-align: left">Stop</td>
      <td style="text-align: left">停止进程执行(来自非终端)</td>
    </tr>
    <tr>
      <td style="text-align: left">SIG<code class="language-plaintext highlighter-rouge">TSTP</code></td>
      <td style="text-align: left">18,20,24</td>
      <td style="text-align: left">Stop</td>
      <td style="text-align: left">来自终端的停止信号</td>
    </tr>
    <tr>
      <td style="text-align: left">SIG<code class="language-plaintext highlighter-rouge">TTIN</code></td>
      <td style="text-align: left">21,21,26</td>
      <td style="text-align: left">Stop</td>
      <td style="text-align: left">后台进程的终端输入</td>
    </tr>
    <tr>
      <td style="text-align: left">SIG<code class="language-plaintext highlighter-rouge">TTOU</code></td>
      <td style="text-align: left">22,22,27</td>
      <td style="text-align: left">Stop</td>
      <td style="text-align: left">后台进程的终端输出</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>SIGKILL 和 SIGSTOP 信号不能被捕获、阻塞或忽略</li>
  <li>SIGUSR1 和 SIGUSR2 这两个信号由你的进程来定义</li>
</ul>

<h3 id="166-重新定义信号的行为">16.6 重新定义信号的行为</h3>

<p>（1）重新定义 INT 信号的行为：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">puts</span> <span class="no">Process</span><span class="p">.</span><span class="nf">pid</span>
<span class="nb">trap</span><span class="p">(</span><span class="ss">:INT</span><span class="p">)</span> <span class="p">{</span> <span class="nb">print</span> <span class="s2">"Na na na, you can't get me"</span><span class="p">}</span>
<span class="nb">sleep</span> <span class="c1"># 休眠，以便于有时间发送信号</span>
</code></pre></div></div>

<p>（2）在第二个会话中发信号：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Process.kill(:INT, &lt;pid of first session&gt;)</span>
<span class="no">Process</span><span class="p">.</span><span class="nf">kill</span><span class="p">(</span><span class="ss">:INT</span><span class="p">,</span> <span class="mi">61852</span><span class="p">)</span>
</code></pre></div></div>

<p>（3）使用 Ctrl-C 来终结第一个会话，会发现结果还是一样</p>

<p>（4）KILL  是不可以被重定义的</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Process</span><span class="p">.</span><span class="nf">kill</span><span class="p">(</span><span class="ss">:KILL</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">pid</span> <span class="n">of</span> <span class="n">first</span> <span class="n">session</span><span class="o">&gt;</span><span class="p">)</span>
</code></pre></div></div>

<p>或者在终端 kill -9 pid</p>

<h3 id="167-忽略信号">16.7 忽略信号</h3>

<p>修改 16.6 的代码，给 trap 加第二个参数，可以忽略信号</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">puts</span> <span class="no">Process</span><span class="p">.</span><span class="nf">pid</span>
<span class="nb">trap</span><span class="p">(</span><span class="ss">:INT</span><span class="p">,</span> <span class="s2">"IGNORE"</span><span class="p">)</span>
<span class="nb">sleep</span> <span class="c1"># 休眠，以便于有时间发送信号</span>
</code></pre></div></div>
<p>发送 <code class="language-plaintext highlighter-rouge">INT</code> 给以上代码的进程，进程不会退出</p>

<h3 id="168-信号处理程序是全局性的">16.8 信号处理程序是全局性的</h3>

<ul>
  <li>捕获一个信号有点像使用一个全局变量</li>
  <li>信号处理并没有命名空间</li>
</ul>

<h3 id="169-恰当地重定义信号处理程序">16.9 恰当地重定义信号处理程序</h3>

<p>利用以下方式可以保留第一次的系统的默认行为</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">trap</span><span class="p">(</span><span class="ss">:INT</span><span class="p">){</span> <span class="nb">puts</span> <span class="s1">'This is the first signal handler'</span><span class="p">}</span>

<span class="n">old_handler</span> <span class="o">=</span> <span class="nb">trap</span><span class="p">(</span><span class="ss">:INT</span><span class="p">){</span>
  <span class="n">old_handler</span><span class="p">.</span><span class="nf">call</span>
  <span class="nb">puts</span> <span class="s1">'This is the second handler'</span>
  <span class="nb">exit</span>
<span class="p">}</span>
<span class="nb">sleep</span> <span class="c1"># 以便于有时间发送信号</span>
</code></pre></div></div>

<p>从最佳时间的角度说，代码不应该定义任何信号处理程序，除非它是服务器</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 一种 “友好的” 捕获信号的方法</span>

<span class="n">old_handler</span> <span class="o">=</span> <span class="nb">trap</span><span class="p">(</span><span class="ss">:QUIT</span><span class="p">){</span>
  <span class="c1"># 进行清理</span>
  <span class="nb">puts</span> <span class="s2">"All done!"</span>

  <span class="n">old_handler</span><span class="p">.</span><span class="nf">call</span> <span class="k">if</span> <span class="n">old_handler</span><span class="p">.</span><span class="nf">respond_to?</span><span class="p">(</span><span class="ss">:call</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>退出之前清理资源可以使用 <code class="language-plaintext highlighter-rouge">at_exit</code>，不需要获取信号来处理</p>

<h3 id="1610-何时接收不到信号">16.10 何时接收不到信号？</h3>

<p>进程可以从繁忙的 for 循环中解脱出来，转而使用信号处理程序，它总会执行完所有被调用的信号处理程序中的代码</p>

<h3 id="1611-实践领域">16.11 实践领域</h3>

<ul>
  <li>常见用法是在 shell 中使用 <code class="language-plaintext highlighter-rouge">kill(1)</code> 发送信号</li>
  <li>信号是有长期运行的进程使用，例如服务器和守护进程。</li>
  <li>多数情况下，发信号的是人类用户而非自动化程序</li>
</ul>

<p>web 服务器 <code class="language-plaintext highlighter-rouge">Unicorn</code> ：</p>

<ul>
  <li>通过终止其所有进程并立即关闭来响应 <code class="language-plaintext highlighter-rouge">INT</code> 信号</li>
  <li>通过重新执行来响应 <code class="language-plaintext highlighter-rouge">USR2</code> 信号，从而实现零关闭时间重启(热部署)</li>
  <li>通过增加运行的工作进程数量来响应 <code class="language-plaintext highlighter-rouge">TTIN</code> 信号</li>
  <li>unicorn 的信号：https://unicorn.bogomips.org/SIGNALS.html</li>
</ul>

<h3 id="1612-系统调用">16.12 系统调用</h3>

<p>ruby 的 <code class="language-plaintext highlighter-rouge">Process.kill</code> 对应于 <code class="language-plaintext highlighter-rouge">kill(2)</code>
<code class="language-plaintext highlighter-rouge">Kernal#trap</code> 基本对应于 <code class="language-plaintext highlighter-rouge">sigaction(2)</code></p>

<hr />

<h2 id="理解-unix-进程17进程皆可互通">理解 UNIX 进程（17）：进程皆可互通</h2>

<p>进程通信(简称  IPC),常见的两个实用方法：管道和套接字对(<code class="language-plaintext highlighter-rouge">socket pairs</code>)</p>

<h3 id="171-我们的第一个管道">17.1 我们的第一个管道</h3>

<ul>
  <li>管道是一个数据流</li>
  <li>一端可读，一端可写，管道的两端可以被不同的进程使用</li>
</ul>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">reader</span><span class="p">,</span> <span class="n">writer</span> <span class="o">=</span> <span class="no">IO</span><span class="p">.</span><span class="nf">pipe</span> <span class="c1">#=&gt; [#&lt;IO:fd 7&gt;, #&lt;IO:fd 8&gt;]</span>
</code></pre></div></div>
<ul>
  <li>IO.pipe 返回两个 IO 对象，对象类似匿名文件， 没有 #path</li>
  <li>ruby 的 IO 类是 File, TCPSocket, UDPSocket 等的超类，所有的这些资源都有一个通用的接口</li>
</ul>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">reader</span><span class="p">,</span> <span class="n">writer</span> <span class="o">=</span> <span class="no">IO</span><span class="p">.</span><span class="nf">pipe</span>
<span class="n">writer</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="s2">"Into the pipe I go ..."</span><span class="p">)</span>
<span class="n">writer</span><span class="p">.</span><span class="nf">close</span>
<span class="nb">puts</span> <span class="n">reader</span><span class="p">.</span><span class="nf">read</span>
<span class="c1"># =&gt; 'Into the pipe I go ...'</span>
</code></pre></div></div>
<p>关闭 writer 会发送一个 EOF，这样 reader 就不会被一直阻塞
<code class="language-plaintext highlighter-rouge">IO#read</code> 会不停的从管道中读取数据，直到读到一个 <code class="language-plaintext highlighter-rouge">EOF(end of file)</code>文件结束标志</p>

<h3 id="172-管道是单向的">17.2 管道是单向的</h3>

<p><code class="language-plaintext highlighter-rouge">reader</code> 只能从文件读取
<code class="language-plaintext highlighter-rouge">writer</code> 只能向文件写入</p>

<h3 id="173-共享管道">17.3 共享管道</h3>

<ul>
  <li>管道也是一种资源，有自己的文件描述符及其他的一切，因此可以和子进程共享</li>
  <li>fork 衍生子进程也会复制管道两端的 IO 对象，管道会被进程和子进程共享</li>
  <li>管道中流淌的是数据流</li>
</ul>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">reader</span><span class="p">,</span> <span class="n">writer</span> <span class="o">=</span> <span class="no">IO</span><span class="p">.</span><span class="nf">pipe</span>

<span class="nb">puts</span> <span class="s2">"--</span><span class="si">#{</span><span class="n">reader</span><span class="p">.</span><span class="nf">fileno</span><span class="si">}</span><span class="s2">"</span>
<span class="nb">puts</span> <span class="s2">"--</span><span class="si">#{</span><span class="n">writer</span><span class="p">.</span><span class="nf">fileno</span><span class="si">}</span><span class="s2">"</span>

<span class="nb">fork</span> <span class="k">do</span>     
  <span class="nb">puts</span> <span class="n">reader</span><span class="p">.</span><span class="nf">fileno</span>
  <span class="nb">puts</span> <span class="n">writer</span><span class="p">.</span><span class="nf">fileno</span>

  <span class="n">reader</span><span class="p">.</span><span class="nf">close</span>

  <span class="mi">10</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span>
    <span class="c1">#写入数据</span>
    <span class="n">writer</span><span class="p">.</span><span class="nf">puts</span> <span class="s2">"Another one bites the dust"</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">writer</span><span class="p">.</span><span class="nf">close</span>
<span class="k">while</span> <span class="n">message</span> <span class="o">=</span> <span class="n">reader</span><span class="p">.</span><span class="nf">gets</span>
  <span class="vg">$stdout</span><span class="p">.</span><span class="nf">puts</span> <span class="n">message</span>
<span class="k">end</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">IO#puts</code> 和 <code class="language-plaintext highlighter-rouge">IO#gets</code> 是使用行终止符作为分隔符</p>

<h3 id="174-流与消息">17.4 流与消息</h3>
<p><strong>关于流</strong>：</p>

<ul>
  <li>使用管道或 TCP 套接字这样的 IO 流是，并没有开始和结束的概念，数据写入流中，之后跟着一些特定的分隔符(delimiter)</li>
  <li>从 IO 流中读取数据的时候，一次读取一块，遇到分隔符就停止。</li>
  <li>HTTP 使用一连串的终止符来分割头部和主体。</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">UNIX 套接字</code></p>

<ul>
  <li>一种只能用于在同一台物理机中进行通信的套接字，它比 TCP 套接字快很多，非常适合 <code class="language-plaintext highlighter-rouge">IPC</code></li>
  <li>使用数据包通信(datagram)通信</li>
  <li>一个套接字写入整个消息，另一个读取整个消息，不需要分隔符</li>
</ul>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Socket</span><span class="p">.</span><span class="nf">pair</span><span class="p">(</span><span class="ss">:UNIX</span><span class="p">,</span> <span class="ss">:DGRAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> 
<span class="c1">#=&gt;[#&lt;Socket:fd 15&gt;,#&lt;Socket:fd 16&gt;]</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Socket#recv</code> 从TCP连接的另一端接收数据。该函数的第一个参数指定接收端套接字描述，第二个参数指明一个缓冲区，该缓冲区用来存放recv函数接收到的数据</p>

<ul>
  <li>管道提供单向通信</li>
  <li>套接字提供双向通信</li>
</ul>

<p>代码示例看 <code class="language-plaintext highlighter-rouge">snippets/unix_socket.rb</code></p>

<h3 id="远程ipcrpc">远程IPC（RPC）</h3>
<p>RPC 通信方式：</p>
<ul>
  <li>通过 TCP 套接字通信</li>
  <li>RPC 远程调用，如消息队列，分布式系统</li>
</ul>

<p>IPC 进程通信方式：</p>
<ul>
  <li>管道(PIPE)</li>
  <li>FIFO(有名管道)</li>
  <li>XSI 消息队列</li>
  <li>XSI 信号量</li>
  <li>XSI 共享内存</li>
  <li>POSIX 信号量</li>
  <li>域套接字(Domain Socket)</li>
  <li>信号(Signal)</li>
  <li>互斥量(Mutex)</li>
</ul>

<h3 id="176-实践领域">17.6 实践领域</h3>

<p>管道和套接字都是快速的通信方式，管道是单向的，套接字是双向的</p>

<hr />

<h2 id="理解-unix-进程18守护进程">理解 UNIX 进程（18）：守护进程</h2>

<ul>
  <li>守护进程是后台运行的集成，不受终端用户控制</li>
  <li>web 服务器和数据库服务器都属于常见的守护进程</li>
</ul>

<h3 id="181-首个进程">18.1 首个进程</h3>

<ul>
  <li>当内核被引导时会产生一个叫做 <code class="language-plaintext highlighter-rouge">init</code> 的进程。</li>
  <li>这个进程的 <code class="language-plaintext highlighter-rouge">ppid</code> 是 0，作为所有进程的祖父。</li>
  <li>它是首个进程，没有祖先，它的 pid 是 1</li>
</ul>

<h3 id="182-创建第一个守护进程">18.2 创建第一个守护进程</h3>

<p>rack 的 rackup 有一个选项，可以将服务器变成守护进程并置于后台运行</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rackup</span> <span class="o">-</span><span class="no">D</span>  <span class="c1"># 会将服务器作为 daemon 进程启动</span>
</code></pre></div></div>

<h3 id="183-深入-rack">18.3 深入 Rack</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">daemonize_app</span>
  <span class="k">if</span> <span class="no">RUBY_VERSION</span> <span class="o">&lt;</span> <span class="s2">"1.9"</span>

    <span class="c1"># 衍生一个子进程，父进程退出</span>
    <span class="c1"># 但衍生的子进程仍然有从父进程继承的组 id 和会话 id</span>
    <span class="nb">exit</span> <span class="k">if</span> <span class="nb">fork</span>

    <span class="c1"># 因为终端与衍生进程之间仍有牵连，如果终端发出信号到衍生进程的会话组，这个信号仍会被当前子进程接收到</span>
    <span class="c1"># Process.setsid 会使衍生进程成为一个新进程组和新会话组的组长兼领导，这里的子进程没有控制终端</span>
    <span class="c1"># 注意：在已是进程组长的进程中调用 Process.setsid 会失败</span>
    <span class="no">Process</span><span class="p">.</span><span class="nf">setsid</span>

    <span class="c1"># 已成为进程组和会话组组长的衍生进程再次进行衍生，然后退出</span>
    <span class="c1"># 因为终端只能分配给会话领导，所以在这里新衍生的进程，不是进程组组长，也不是会话领导</span>
    <span class="c1"># 也没有控制终端,确保进程脱离了控制终端并且可以独自运行</span>
    <span class="nb">exit</span> <span class="k">if</span> <span class="nb">fork</span>

    <span class="c1"># 设置代码的工作目录为系统根目录，是为了确保守护进程的当前工作目录在执行中不会消失</span>
    <span class="no">Dir</span><span class="p">.</span><span class="nf">chdir</span> <span class="s2">"/"</span> 

    
    <span class="no">STDIN</span><span class="p">.</span><span class="nf">reopen</span> <span class="s2">"/dev/null"</span>
    <span class="no">STDOUT</span><span class="p">.</span><span class="nf">reopen</span> <span class="s2">"/dev/null"</span><span class="p">,</span> <span class="s2">"a"</span> 
    <span class="no">STDERR</span><span class="p">.</span><span class="nf">reopen</span> <span class="s2">"/dev/null"</span><span class="p">,</span> <span class="s2">"a"</span> 
  <span class="k">else</span>
    <span class="no">Process</span><span class="p">.</span><span class="nf">daemon</span>
  <span class="k">end</span> 
<span class="k">end</span>
</code></pre></div></div>

<p>ruby 1.9x 带有 <code class="language-plaintext highlighter-rouge">Process.daemon</code> 的方法，可以将当前进程变成守护进程</p>

<h3 id="184-逐步将进程变成守护进程">18.4 逐步将进程变成守护进程</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nb">exit</span> <span class="k">if</span> <span class="nb">fork</span>
</code></pre></div></div>

<p>以上代码父进程会退出，因为 <code class="language-plaintext highlighter-rouge">fork</code> 会返回两次，在父进程中返回子进程的 pid,在子进程中返回 nil
子进程会成为孤儿进程照常运行，孤儿进程的父进程 id 始终是 1, 也就是内核引导时的 <code class="language-plaintext highlighter-rouge">init</code> 进程</p>

<p>创建守护进程时，必须将主进程退出，这样会使得调用此脚本的终端认为该命令已经执行完毕，于是将控制返回终端</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="no">Process</span><span class="p">.</span><span class="nf">setsid</span>
</code></pre></div></div>
<p>调用 <code class="language-plaintext highlighter-rouge">Process.setsid</code> 完成了以下三件事：
(1) 该进程变成一个新会话的会话领导
(2) 该进程变成一个新进程组的组长
(3) 该进程没有控制终端</p>

<h3 id="185-进程组和会话组">18.5 进程组和会话组</h3>

<p><strong>进程组</strong></p>

<ul>
  <li>每一个进程都属于某个组，每一个组都有唯一的整数 id</li>
  <li>子进程的组 id 继承自父进程，父子进程都是同一个进程组的成员。</li>
  <li>如果父进程由终端控制，并被信号终止的话，父进程的子进程也会同样终止，这是因为终端接收信号，并将其转发给前台进程组中的所有进程。，同一个进程组的组员，会被同一个信号终止。</li>
</ul>

<p>ruby 的 <code class="language-plaintext highlighter-rouge">Process.getpgrp</code> 可以获得进程组的 id</p>

<p><strong>会话组</strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git log | <span class="nb">grep </span>shipped | less
</code></pre></div></div>
<p>以上例子解释：</p>

<ul>
  <li>每个命令都有自己的进程组，因为每个命令都可以创建子进程</li>
  <li>这些命令都是同一个会话组的成员，shell 中的每次调用都会获得自己的会话组</li>
  <li>一个会话组可以依附一个终端，也可以不依附任何终端，比如守护进程</li>
  <li>终端用一种特殊的方法来处理会话组：发送给会话领导的信号被转发到该会话中的所有进程组内，然后再被转发到这些进程组内的所有进程。</li>
</ul>

<p>系统调用 <code class="language-plaintext highlighter-rouge">getdis(2)</code> 可以查到当前的会话组 id, ruby 没有对应实现
但 ruby 的 <code class="language-plaintext highlighter-rouge">Process.setsid</code> 会返回其新创建的会话组 id</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="no">STDIN</span><span class="p">.</span><span class="nf">reopen</span> <span class="s2">"/dev/null"</span>
    <span class="no">STDOUT</span><span class="p">.</span><span class="nf">reopen</span> <span class="s2">"/dev/null"</span><span class="p">,</span> <span class="s2">"a"</span> 
    <span class="no">STDERR</span><span class="p">.</span><span class="nf">reopen</span> <span class="s2">"/dev/null"</span><span class="p">,</span> <span class="s2">"a"</span> 
</code></pre></div></div>
<p>以上代码将所有的标准流设置到 /dev/null， 也就是将其忽略
因为守护进程不依附于某个终端会话，那么标准流也就没什么用了呃</p>

<h3 id="186-实践领域">18.6 实践领域</h3>

<p><code class="language-plaintext highlighter-rouge">rackup</code> 有一个命令行选项可以将进程变为守护进程，对于任何流行的 ruby web 服务器来说都是这样</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rackup</span> <span class="o">-</span><span class="no">D</span>  <span class="c1"># 会将服务器作为 daemon 进程启动</span>
</code></pre></div></div>

<h3 id="187-系统调用">18.7 系统调用</h3>

<p>ruby 的 <code class="language-plaintext highlighter-rouge">Proces.setsid</code> 对应于 <code class="language-plaintext highlighter-rouge">setsid(2)</code>
<code class="language-plaintext highlighter-rouge">Process.getpgrp</code> 对应于 <code class="language-plaintext highlighter-rouge">getpgrp(2)</code></p>

<hr />

<h2 id="理解-unix-进程19生成终端进程">理解 UNIX 进程（19）：生成终端进程</h2>

<p>ruby 程序常见的交互是在程序中通过 <code class="language-plaintext highlighter-rouge">shelling out</code> 的方式在终端执行某个命令。</p>

<h3 id="191-fork--exec">19.1 fork + exec</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">exec(2)</code> 允许使用另一个进程来替换当前进程。</li>
  <li>使用 <code class="language-plaintext highlighter-rouge">exec(2)</code>  的缺点是，当前进程再也无法恢复了，所以可以用 <code class="language-plaintext highlighter-rouge">fork + exec</code> 的组合替代</li>
  <li><code class="language-plaintext highlighter-rouge">exec(2)</code> 不会关闭任何打开的文件描述符(默认情况下)或是进行内存清理</li>
</ul>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">exec</span> <span class="s1">'ls'</span><span class="p">,</span> <span class="s1">'--help'</span>
</code></pre></div></div>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">puts</span> <span class="no">Process</span><span class="p">.</span><span class="nf">pid</span>

<span class="nb">fork</span> <span class="k">do</span> 
  <span class="c1"># exec 输出结果</span>
 <span class="n">res</span> <span class="o">=</span> <span class="nb">exec</span> <span class="s1">'ls'</span>
 <span class="no">Process</span><span class="p">.</span><span class="nf">wait</span>
 <span class="nb">puts</span> <span class="n">res</span><span class="p">.</span><span class="nf">inspect</span>
<span class="k">end</span>
<span class="no">Process</span><span class="p">.</span><span class="nf">wait</span>
</code></pre></div></div>

<h3 id="192-exec-的参数">19.2 exec 的参数</h3>

<p>exec 两种参数传递方式：</p>

<ul>
  <li>把字符串传递给 exec,实际上它会启动一个 shell 进程，然后再将这个字符串交由 shell 解释</li>
  <li>传递一个数组的话，它会跳过 shell, 直接将此数组座位新进程的 ARGV</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">Kernel#system</code>:</p>

<p><code class="language-plaintext highlighter-rouge">Kernel#system</code> 的返回值，如果终端命令的退出码是 0，它就返回 true，否则返回 false
借助 <code class="language-plaintext highlighter-rouge">fork(2)</code> 的魔力，终端命令与当前进程共享标准流，因此来自终端命令的任何输出同样也会出现在当前进程中</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">system</span><span class="p">(</span><span class="s1">'ls'</span><span class="p">)</span>
<span class="nb">system</span><span class="p">(</span><span class="s1">'ls'</span><span class="p">,</span><span class="s1">'--help'</span><span class="p">)</span>
<span class="nb">system</span><span class="p">(</span><span class="s1">'git log | tail -10'</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>Kernel#`</strong>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sb">`ls`</span>
<span class="sb">`ls --help`</span>
<span class="sx">%x[git log | tail -10]</span>
</code></pre></div></div>
<p><strong>Kernel#`</strong> 的返回值由终端程序的 STDOUT 汇集而成的一个字符串</p>

<p><code class="language-plaintext highlighter-rouge">Process.spawn</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#仅适用于 ruby 1.9!</span>

<span class="c1"># 此调用会启动 rails server 进程并将环境变量 RAILS_ENV 设置为 test</span>
<span class="no">Process</span><span class="p">.</span><span class="nf">spawn</span><span class="p">({</span><span class="s1">'RAILS_ENV'</span> <span class="o">=&gt;</span> <span class="s1">'test'</span><span class="p">},</span> <span class="s1">'rails server'</span><span class="p">)</span>

<span class="c1"># 该调用在执行 ls --help 阶段将 STDERR 与 STDOUT 进行合并</span>
<span class="no">Process</span><span class="p">.</span><span class="nf">spawn</span><span class="p">(</span><span class="s2">"ls"</span><span class="p">,</span> <span class="s1">'--help'</span><span class="p">,</span> <span class="no">STDERR</span> <span class="o">=&gt;</span> <span class="no">STDOUT</span><span class="p">)</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">Process.spawn</code> 是非阻塞的，<code class="language-plaintext highlighter-rouge">Kernel#system</code> 会阻塞到命令执行完毕</p>

<p><strong>IO.popen</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">IO.popen</code> 是用纯 ruby 来实现 unix 管道</li>
  <li>底层使用 <code class="language-plaintext highlighter-rouge">fork+exec</code> 实现，设置一个管道用于同生成进程进行通信</li>
</ul>

<p><strong>Open3</strong></p>

<p>Open3 允许同时访问一个生成进程的 STDIN，STDOUT 和 STDERR</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># open3 是标准库的一员</span>
<span class="nb">require</span> <span class="s1">'open3'</span>

<span class="no">Open3</span><span class="p">.</span><span class="nf">popen3</span><span class="p">(</span><span class="s1">'grep'</span><span class="p">,</span> <span class="s1">'data'</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">stdin</span><span class="p">,</span> <span class="n">stdout</span><span class="p">,</span> <span class="n">stderr</span><span class="o">|</span>
  <span class="n">stdin</span><span class="p">.</span><span class="nf">puts</span> <span class="s2">"some</span><span class="se">\n</span><span class="s2">datadgdsg</span><span class="se">\n</span><span class="s2">data"</span>
  <span class="n">stdin</span><span class="p">.</span><span class="nf">close</span>
  <span class="nb">puts</span> <span class="n">stdout</span><span class="p">.</span><span class="nf">read</span>
<span class="k">end</span>

<span class="c1"># 在可行的情况下，Open3 会使用 Process.spawn</span>
<span class="c1"># 可以像这样把选项传递给 Process.spawn</span>
<span class="no">Open3</span><span class="p">.</span><span class="nf">popen3</span><span class="p">(</span><span class="s1">'ls'</span><span class="p">,</span> <span class="s1">'-uhh'</span><span class="p">,</span> <span class="ss">:err</span> <span class="o">=&gt;</span> <span class="ss">:out</span><span class="p">)</span> <span class="k">do</span>  <span class="o">|</span><span class="n">stdin</span><span class="p">,</span> <span class="n">stdout</span><span class="p">,</span> <span class="n">stderr</span><span class="o">|</span>
  <span class="nb">puts</span> <span class="n">stdout</span><span class="p">.</span><span class="nf">read</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="193-实践领域">19.3 实践领域</h3>

<p>本章的所有方法的缺点就是都依赖 <code class="language-plaintext highlighter-rouge">fork(2)</code>，因为 <code class="language-plaintext highlighter-rouge">fork(2)</code> 会引发由进程衍生所带来的成本。
利用 shell out 执行简单的 <code class="language-plaintext highlighter-rouge">ls(1)</code> 调用，内核仍需要保证新的 <code class="language-plaintext highlighter-rouge">ls(1)</code> 进程可以使用 ruby 进程的全部内存。</p>

<ul>
  <li>ruby 语言核心库不支持系统调用 <code class="language-plaintext highlighter-rouge">posix_spawn(2)</code> 等不会带来 <code class="language-plaintext highlighter-rouge">fork(2)</code> 所引发的开销的系统调用。</li>
  <li><code class="language-plaintext highlighter-rouge">posix-spawn</code> gem 提供了对 <code class="language-plaintext highlighter-rouge">posix_spawn(2)</code> 的访问，此调用在大多数 <code class="language-plaintext highlighter-rouge">Unix</code> 系统中都可用</li>
  <li><code class="language-plaintext highlighter-rouge">posix-spawn</code> gem 模拟了 <code class="language-plaintext highlighter-rouge">Process.spawn</code> API,并且会速度更快，有资源利用效率更高的进程生成</li>
  <li>系统调用 <code class="language-plaintext highlighter-rouge">posix_spawn(2)</code> 是 <code class="language-plaintext highlighter-rouge">fork(2)</code> 的一个子集</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">fork(2)</code> 生成进程的两个独特属性：</p>

<ul>
  <li>1）获取了一份父进程在内存中的所有内容的副本</li>
  <li>2) 获得了父进程已打开的所有文件描述符的副本</li>
  <li>而系统调用 <code class="language-plaintext highlighter-rouge">posix_spawn(2)</code> 只实现了以上的 (1)，并不会有属性(2)，不会获取父进程在内存中的所有内容的副本</li>
</ul>

<h3 id="194-系统调用">19.4 系统调用</h3>

<ul>
  <li>ruby 的 <code class="language-plaintext highlighter-rouge">Kenel#system</code> 对应于 <code class="language-plaintext highlighter-rouge">system(3)</code></li>
  <li><code class="language-plaintext highlighter-rouge">Kenel#exec</code> 对应于 <code class="language-plaintext highlighter-rouge">execve(2)</code></li>
  <li><code class="language-plaintext highlighter-rouge">IO.popen</code> 对应于 <code class="language-plaintext highlighter-rouge">popen(3)</code></li>
  <li><code class="language-plaintext highlighter-rouge">posix-spawn</code> 这个 gem 使用 <code class="language-plaintext highlighter-rouge">posix_spawn(2)</code></li>
</ul>
]]></content>
	</entry>
	
	<entry>
		<title>《Javascript 设计模式与开发实践》学习笔记</title>
		<link href="http://127.0.0.1/notes/2016/08/06/Javascript-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html" />
		<updated>2016-08-06T02:30:00+08:00</updated>
		<id>http://127.0.0.1/notes/2016/08/06/Javascript-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</id>
		<content type="html"><![CDATA[<h2 id="第-1-章面向对象的-javascript">第 1 章：面向对象的 Javascript</h2>

<ul>
  <li>js 是通过原型委托的方式来实现对象与对象之间的继承</li>
  <li>编程语言按照数据类型大体分为两类，一类是静态类型语言，另一类是动态类型语言。</li>
  <li>静态语言在编译时便已确定变量的类型</li>
  <li>动态语言的变量类型要到程序运行的时候，待变量被赋予某个值之后，才会具有某种类型</li>
</ul>

<h4 id="静态类型">静态类型</h4>

<p><strong>优点：</strong></p>

<ul>
  <li>编译时就能发现类型不匹配的错误，提前避免运行时的错误</li>
  <li>明确规定了数据类型，编译器会针对性的做优化，提高程序执行速度</li>
</ul>

<p><strong>缺点：</strong></p>

<ul>
  <li>迫使程序员依照强契约来编写程序，为变量规定数据类型只是编写可靠性高程序的一种手段，而不是编写程序的目的</li>
  <li>类型的声明也会增加更多的代码，细节会让程序员的精力从思考业务逻辑上分散开来</li>
</ul>

<h4 id="动态类型">动态类型</h4>

<p><strong>优点：</strong></p>

<ul>
  <li>代码量少，更加简洁，更加易于阅读</li>
  <li>程序员可以把精力更多的放在业务逻辑上</li>
  <li>由于无需进行类型检测，我们可以尝试调用任何对象的任意方法，无需考虑它是否拥有</li>
</ul>

<p><strong>缺点：</strong></p>

<ul>
  <li>无法保证变量的类型，从而在程序运行期有可能发生跟类型相关的错误</li>
</ul>

<h4 id="鸭子类型">鸭子类型</h4>

<ul>
  <li>鸭子类型(<code class="language-plaintext highlighter-rouge">duck typing</code>)：如果它走起路来像鸭子，叫起来也是鸭子，那么它就是鸭子</li>
  <li><code class="language-plaintext highlighter-rouge">面向接口编程，而不是面向实现编程</code>：
    <ul>
      <li>一个对象若有 <code class="language-plaintext highlighter-rouge">push</code> 和 <code class="language-plaintext highlighter-rouge">pop</code>,并且提供了正确的实现，它就可以被当做栈</li>
      <li>如果一个对象有 <code class="language-plaintext highlighter-rouge">length</code> 属性，也可以用下标来存取属性，那么对象可以被当做数组来用</li>
    </ul>
  </li>
</ul>

<h4 id="多态">多态</h4>

<ul>
  <li>多态含义：同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果</li>
  <li>开放封闭原则：对扩展开放，对修改封闭。</li>
  <li>把不变的部分隔离出来，把可变的部分封装起来</li>
  <li>java 中通过继承，向上转型来实现多态，js 中不需要</li>
  <li>多态的好处在于不必问对象是什么类型，根据得到的答案调用对象的某个行为</li>
</ul>

<h4 id="封装">封装</h4>

<ul>
  <li>封装的目的是将信息隐藏。</li>
  <li>封装数据：部分语言的对象系统中，封装数据是由词法解析来实现的，提供了 private、public、protected 等关键字来提供不同的访问权限</li>
  <li>js 中需要依赖变量的作用域来实现封装特性，只能模拟出 public 和 private 另种封装特性</li>
  <li>封装实现：对象之间通过暴露的 API 接口来通信，其它对象和用户都不关心它的内部实现</li>
  <li>封装类型：通过抽象类和接口来进行，把对象真正的类型隐藏在抽象类和接口之后，相比对象的类型，客户更关心对象的行为。比如工厂方法模式、组合模式等</li>
  <li>封装变化：把容易变化的部分和稳定不变的部分隔离开来，在系统演变过程中，只需要替换已封装的容易变化的部分，保证程序的稳定性和可扩展性</li>
</ul>

<h4 id="javascript-中的原型继承">javascript 中的原型继承</h4>

<p><img src="/assets/images/js原型继承.png" alt="js原型继承" /></p>

<p>原型编程的基本原则:</p>

<ul>
  <li>所有的数据都是对象</li>
  <li>要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它</li>
  <li>对象会记住它的原型</li>
  <li>如果对象无法响应某个请求，它会把这个请求委托给它自己的原型</li>
</ul>

<p><strong>所有的数据都是对象：</strong></p>

<p>js 引入了两套类型机制：基本类型和对象类型。基本类型包括：undefined、number、boolean、string、function、object</p>

<p><strong>要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它:</strong></p>

<ul>
  <li>js 中没有类的概念，函数构造器可以用 <code class="language-plaintext highlighter-rouge">new</code> 运算符来创建对象，实际只是先克隆 <code class="language-plaintext highlighter-rouge">Object.prototype</code> 对象，再进行其他额外的操作。函数构造器也可以作为普通函数使用</li>
  <li>对象有 <code class="language-plaintext highlighter-rouge">[[prototype]]</code> 指针指向正确的原型，在 chrome 和 firefox 中是 <code class="language-plaintext highlighter-rouge">_proto_</code></li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Person</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">};</span>

<span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">objectFactory</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>

  <span class="c1">// 从 Object.prototype 上克隆一个空的对象</span>
  <span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Object</span><span class="p">(),</span>

  <span class="c1">// 取得外部传入的构造器，此例是 Person</span>
  <span class="nx">Constructor</span> <span class="o">=</span> <span class="p">[].</span><span class="nx">shift</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">);</span> 
  <span class="nx">obj</span><span class="p">.</span><span class="nx">_proto_</span> <span class="o">=</span> <span class="nx">Constructor</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span> <span class="c1">// 指向正确的原型</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">objectFactory</span><span class="p">(</span><span class="nx">Person</span><span class="p">,</span> <span class="dl">'</span><span class="s1">seven</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// 输出  sven</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">getName</span><span class="p">());</span> <span class="c1">// 输出:sven</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="o">===</span> <span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span> <span class="c1">// 输出： true</span>

</code></pre></div></div>

<p><strong>对象会记住它的原型：</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">对象的原型</code> 并不是对象有原型，而是对象的构造器有原型，对象将请求委托给它的构造器的原型</li>
  <li>js 给对象提供了一个名为 <code class="language-plaintext highlighter-rouge">_proto_</code> 的隐藏属性，对象的 <code class="language-plaintext highlighter-rouge">_proto_</code> 属性默认会指向它的构造器的原型对象，即 <code class="language-plaintext highlighter-rouge">[Constructor].prototype</code> ，在 chrome 和 firefox 中 <code class="language-plaintext highlighter-rouge">_proto_</code>  被公开出来</li>
</ul>

<p><strong>如果对象无法响应某个请求，它会把这个请求委托给它自己的原型:</strong></p>

<ul>
  <li>原型继承的精髓：当一个对象无法响应某个请求的时候，它会顺着原型链把请求传递下去，知道遇到一个可以处理该请求的对象为止</li>
  <li>js 的对象都是从 <code class="language-plaintext highlighter-rouge">Object.prototype</code> 对象克隆而来，只能得到单一的继承关系，单对象构造器的原型可以动态的指向其它对象</li>
</ul>

<h2 id="原型继承的未来">原型继承的未来</h2>

<ul>
  <li>Peter Norvig 说： 设计模式是对语言不足的补充，如果要适用设计模式，不如去找一门更好的语言。</li>
  <li>通过设置构造器的 <code class="language-plaintext highlighter-rouge">prototype</code> 的来实现原型继承的时候，除了根对象 <code class="language-plaintext highlighter-rouge">Object.prototype</code> 本身之外，任何对象都会有一个原型。</li>
  <li>通过 <code class="language-plaintext highlighter-rouge">Object.create(null)</code> 可以创建出没有原型的对象，大多数浏览器提供了 <code class="language-plaintext highlighter-rouge">Object.create</code> 方法，<code class="language-plaintext highlighter-rouge">Object.create</code> 方法是原型模式的天然实现</li>
</ul>

<h2 id="第-2-章thiscall-和-apply">第 2 章：this、call 和 apply</h2>

<h3 id="this">this</h3>

<p><code class="language-plaintext highlighter-rouge">js</code> 的 this 总指向一个对象，具体指向哪个对象是在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境</p>

<h4 id="this-的指向">this 的指向：</h4>

<p>this 的指向可以分为 4 种情况：</p>

<ul>
  <li>作为对象的方法调用</li>
  <li>作为普通函数调用</li>
  <li>构造器调用</li>
  <li><code class="language-plaintext highlighter-rouge">Function.prototype.call</code> 或 <code class="language-plaintext highlighter-rouge">Function.prototype.apply</code> 调用</li>
</ul>

<p><strong>作为对象的方法调用：</strong></p>

<p>this 指向该对象</p>

<p><strong>作为普通函数调用</strong>:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">this</code> 指向 <code class="language-plaintext highlighter-rouge">window</code>(全局对象)</li>
  <li><code class="language-plaintext highlighter-rouge">js</code> 处理元素的事件函数内部，callback 作为普通函数调用时，内部函数的，this 指向了 window，看代码：</li>
  <li>
    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">div1</span><span class="dl">'</span><span class="p">).</span><span class="nx">onclick</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">that</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span> <span class="c1">// 输出 'div1'</span>
    <span class="kd">var</span> <span class="nx">callback</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">alert</span><span class="p">(</span><span class="nx">that</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nx">callback</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li><code class="language-plaintext highlighter-rouge">ECMAScript 5</code> 的 <code class="language-plaintext highlighter-rouge">strict</code> 模式下， <code class="language-plaintext highlighter-rouge">this</code> 已被规定为不会指向全局对象，而是 <code class="language-plaintext highlighter-rouge">undefined</code>:</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">func</span><span class="p">(){</span>
	<span class="dl">"</span><span class="s2">use strict</span><span class="dl">"</span><span class="p">;</span> <span class="c1">// 启用严格模式</span>
	<span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="c1">// 输出： undefined</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>构造器调用：</strong></p>

<ul>
  <li>使用 <code class="language-plaintext highlighter-rouge">new</code> 运算符调用函数时，该函数总会返回一个对象，<code class="language-plaintext highlighter-rouge">this</code> 指向构造器返回的这个对象</li>
  <li>如果 <code class="language-plaintext highlighter-rouge">new</code> 调用构造器时，不能显示的指定返回值</li>
</ul>

<h4 id="丢失的-this">丢失的 this：</h4>

<ul>
  <li>作为普通函数调用，函数内部的 this 会指向 window</li>
</ul>

<p>以下代码会抛出异常，因为 <code class="language-plaintext highlighter-rouge">getId</code> 引用 <code class="language-plaintext highlighter-rouge">document.getElementById</code> ，调用 <code class="language-plaintext highlighter-rouge">getId</code>，此时就成了普通函数调用，函数内部的 this 指向了 widnow， 而不是原来的 <code class="language-plaintext highlighter-rouge">document</code></p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">id</span><span class="o">=</span><span class="dl">"</span><span class="s2">div1</span><span class="dl">"</span><span class="o">&gt;</span><span class="nx">我是一个</span> <span class="nx">div</span><span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="nx">script</span> <span class="nx">type</span><span class="o">=</span><span class="dl">"</span><span class="s2">text/javascript</span><span class="dl">"</span><span class="o">&gt;</span>
    <span class="kd">var</span> <span class="nx">getId</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">;</span>
    <span class="nx">getId</span><span class="p">(</span><span class="dl">'</span><span class="s1">div1</span><span class="dl">'</span><span class="p">);</span>
    <span class="o">&lt;</span><span class="sr">/script</span><span class="err">&gt;
</span></code></pre></div></div>

<h3 id="call-和-apply">call 和 apply</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ECMAScript3</code> 给 Function 的原型定义了两个方法，分别是 <code class="language-plaintext highlighter-rouge">Function.prototype.call</code> 和  <code class="language-plaintext highlighter-rouge">Function.prototype.apply</code></li>
</ul>

<p><strong>call 和 apply 的区别：</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">apply</code> 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合（数组或者类数组）</li>
  <li><code class="language-plaintext highlighter-rouge">call</code> 传入参数数量不固定，第一个参数也是 this 指向，第二个往后的参数不定，依次传入</li>
  <li><code class="language-plaintext highlighter-rouge">call</code> 是包装在 <code class="language-plaintext highlighter-rouge">apply</code> 上面的一颗语法糖</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">#</span> <span class="nx">使用</span> <span class="nx">call</span> <span class="nx">或</span> <span class="nx">apply</span> <span class="nx">时</span><span class="err">，</span><span class="nx">如果第一个参数为</span> <span class="kc">null</span><span class="p">,</span> <span class="nx">函数内的</span> <span class="k">this</span> <span class="nx">会指向默认的宿主对象</span><span class="err">，</span><span class="nx">浏览器你是</span> <span class="nb">window</span>

<span class="kd">var</span> <span class="nx">func</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">){</span>
	<span class="nx">alert</span><span class="p">(</span> <span class="k">this</span> <span class="o">====</span> <span class="nb">window</span><span class="p">);</span> <span class="c1">// 输出 true,如果启用严格模式，this 会是 null</span>
<span class="p">}</span>

<span class="nx">func</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]);</span>
</code></pre></div></div>

<p><strong>call 和 apply 的用途：</strong></p>

<ul>
  <li>改变 this 指向</li>
  <li>Function.prototype.bind</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">bind</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">context</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nb">self</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span> <span class="c1">// 保存原函数</span>
        <span class="k">return</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// 返回一个新的函数</span>
            <span class="k">return</span> <span class="nb">self</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">context</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span> <span class="c1">// 执行新的函数的时候，会把之前传入的 context 当做新函数体内的 this</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
        <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">seven</span><span class="dl">'</span>
    <span class="p">};</span>

    <span class="kd">var</span> <span class="nx">func</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// 输出 seven</span>
    <span class="p">}.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>

    <span class="nx">func</span><span class="p">();</span>
</code></pre></div></div>
<ul>
  <li>借用其他对象的方法</li>
</ul>

<h2 id="第-3-章闭包和高阶函数">第 3 章：闭包和高阶函数</h2>

<p>js 设计之初参考了 LISP 的两大方言之一的 <code class="language-plaintext highlighter-rouge">Scheme</code>，引入了 <code class="language-plaintext highlighter-rouge">Lambda</code> 表达式、闭包、高阶函数等特性</p>

<h3 id="闭包">闭包</h3>

<p><strong>变量的作用域：</strong></p>

<ul>
  <li>在函数中声明一个变量时，如果变量前没有关键字 var，这个变量会成为全局变量</li>
  <li>js 中，函数可以用来创造函数作用域，函数内可以看到外面的变量，函数外无法看到函数内部的变量</li>
  <li>当在函数中搜索一个变量时，如果函数内没有声明这个变量，那么会随着代码执行环境创建的作用域链往外层逐层搜索，一直搜索到全局对象为止</li>
</ul>

<p><strong>变量的生存周期：</strong></p>

<ul>
  <li>全局变量的生命周期当然是永久的，除非主动销毁</li>
  <li>函数内部用 var 生命的局部变量，会随着函数的调用结束而被销毁</li>
</ul>

<p>闭包的例子：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">var</span> <span class="nx">nodes</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementsByTagName</span><span class="p">(</span><span class="dl">'</span><span class="s1">div</span><span class="dl">'</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">nodes</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">nodes</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">onclick</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
                <span class="nx">alert</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">})(</span><span class="nx">i</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div></div>

<p><strong>闭包的更多作用：</strong></p>

<ul>
  <li>封装变量：把一些不需要暴露在全局的变量封装成 “私有变量”</li>
  <li>延续局部变量的寿命：</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// var report = function(src) {</span>
  <span class="c1">//     var img = new Image();</span>
  <span class="c1">//     img.src = src;</span>
  <span class="c1">// }</span>

  <span class="c1">// img 变量用闭包封闭起来，可以解决请求丢失的问题:</span>
    <span class="kd">var</span> <span class="nx">report</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">imgs</span> <span class="o">=</span> <span class="p">[];</span>
        <span class="k">return</span> <span class="kd">function</span><span class="p">(</span><span class="nx">src</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">img</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Image</span><span class="p">();</span>
            <span class="nx">imgs</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">img</span><span class="p">);</span>
            <span class="nx">img</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="nx">src</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">})();</span>
</code></pre></div></div>

<p><strong>闭包和面向对象设计：</strong></p>

<p>闭包相关代码：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">extend</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">{</span>
      <span class="na">call</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">value</span><span class="o">++</span><span class="p">;</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">};</span>

  <span class="kd">var</span> <span class="nx">extend</span> <span class="o">=</span> <span class="nx">extend</span><span class="p">();</span>
  <span class="nx">extend</span><span class="p">.</span><span class="nx">call</span><span class="p">();</span> <span class="c1">// 输出 1</span>
  <span class="nx">extend</span><span class="p">.</span><span class="nx">call</span><span class="p">();</span> <span class="c1">// 输出 1</span>
  <span class="nx">extend</span><span class="p">.</span><span class="nx">call</span><span class="p">();</span> <span class="c1">// 输出 1</span>
</code></pre></div></div>

<p>面向对象的写法：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">extend</span> <span class="o">=</span> <span class="p">{</span>
        <span class="na">value</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="na">call</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="o">++</span><span class="p">;</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// var extend = extend();</span>
    <span class="nx">extend</span><span class="p">.</span><span class="nx">call</span><span class="p">();</span> <span class="c1">// 输出 1</span>
    <span class="nx">extend</span><span class="p">.</span><span class="nx">call</span><span class="p">();</span> <span class="c1">// 输出 1</span>
    <span class="nx">extend</span><span class="p">.</span><span class="nx">call</span><span class="p">();</span> <span class="c1">// 输出 1</span>
</code></pre></div></div>

<p>原型继承写法：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">var</span> <span class="nx">Extend</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">Extend</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">call</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="o">++</span><span class="p">;</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nx">extend</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Extend</span><span class="p">();</span>
    <span class="nx">extend</span><span class="p">.</span><span class="nx">call</span><span class="p">();</span> <span class="c1">// 输出 1</span>
    <span class="nx">extend</span><span class="p">.</span><span class="nx">call</span><span class="p">();</span> <span class="c1">// 输出 2</span>
    <span class="nx">extend</span><span class="p">.</span><span class="nx">call</span><span class="p">();</span> <span class="c1">// 输出 3</span>
</code></pre></div></div>

<p><strong>闭包和内存管理：</strong></p>

<ul>
  <li>局部变量本应该在函数退出时被解除引用，但如果局部变量被封闭在闭包形成的环境中，那么可以局部变量可以一直生存下去。如果需要回收变量，可以手动设置变量为 <code class="language-plaintext highlighter-rouge">null</code></li>
  <li>在 IE 浏览器中，由于 BOM 和 DOM 中的对象是使用 C++ 以 COM 对象的方式实现的，而 COM 对象的垃圾收集机制采用的是<code class="language-plaintext highlighter-rouge">引用计数策略</code>。在<code class="language-plaintext highlighter-rouge">引用计数策略</code>垃圾回收机制中，如果两个对象之间形成了循环引用，那么这两个对象都无法被回收</li>
  <li>解决循环引用带来的内存泄露问题，只需要把循环引用中的变量设为 null 即可</li>
</ul>

<h3 id="高阶函数">高阶函数</h3>

<p>高阶函数至少满足以下条件：</p>

<ul>
  <li>函数可以作为参数被传递；</li>
  <li>函数可以作为返回值输出</li>
</ul>

<p><strong>单例模式：</strong></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">var</span> <span class="nx">getSingle</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">ret</span><span class="p">;</span>
        <span class="k">return</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">ret</span> <span class="o">||</span> <span class="p">(</span><span class="nx">ret</span> <span class="o">=</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nx">getScript</span> <span class="o">=</span> <span class="nx">getSingle</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
        <span class="k">return</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">script</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">})</span>

    <span class="kd">var</span> <span class="nx">script1</span> <span class="o">=</span> <span class="nx">getScript</span><span class="p">();</span>
    <span class="kd">var</span> <span class="nx">script2</span> <span class="o">=</span> <span class="nx">getScript</span><span class="p">();</span>

    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">script1</span> <span class="o">===</span> <span class="nx">script2</span><span class="p">);</span>
</code></pre></div></div>

<p><strong>高阶函数实现 AOP：</strong></p>

<ul>
  <li>AOP(面向切面编程)的主要作用是把一些跟核心业务逻辑模块无关的功能抽离出来，这些跟业务逻辑无关的功能通常包括日志统计、安全控制、异常处理等。把这些功能抽离出来，再通过“动态织入”的方式掺入业务逻辑模块中。</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">before</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">beforefn</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">__self</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span> <span class="c1">// 保存原函数的引用</span>
        <span class="k">return</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// 返回包含了原函数和新函数的代理函数</span>
            <span class="nx">beforefn</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span> <span class="c1">// 执行新函数，修正 this</span>
            <span class="k">return</span> <span class="nx">__self</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span> <span class="c1">// 执行原函数</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">after</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">afterfn</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">__self</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span> <span class="c1">// 保存原函数的引用</span>
        <span class="k">return</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// 返回包含了原函数和新函数的代理函数</span>
            <span class="kd">var</span> <span class="nx">ret</span> <span class="o">=</span> <span class="nx">__self</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">)</span> <span class="c1">// 执行原函数</span>
            <span class="nx">afterfn</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span> <span class="c1">// 执行新函数，修正 this</span>
            <span class="k">return</span> <span class="nx">ret</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nx">func</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nx">func</span> <span class="o">=</span> <span class="nx">func</span><span class="p">.</span><span class="nx">before</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">}).</span><span class="nx">after</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    <span class="p">});</span>

    <span class="nx">func</span><span class="p">();</span>
</code></pre></div></div>

<p><strong>柯里化(currying):</strong>*</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">currying</code> 又称部分求值。函数首先会接受一些参数，接受了这些参数之后，该函数并不会立即求值，而是继续返回另外一个函数，到最后真正需要求值时，所有参数都会被一次性用于求值</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">var</span> <span class="nx">currying</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">fn</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nx">args</span> <span class="o">=</span> <span class="p">[];</span>

    <span class="k">return</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">arguments</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">){</span>
            <span class="k">return</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>
        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
            <span class="p">[].</span><span class="nx">push</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">args</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
            <span class="k">return</span> <span class="nx">arguments</span><span class="p">.</span><span class="nx">callee</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>

<span class="p">};</span>
</code></pre></div></div>

<p><strong>uncurrying:</strong></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// uncurrying 实现</span>
<span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">uncurrying</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nb">self</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="k">return</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">shift</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">self</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
    <span class="p">};</span>
<span class="p">};</span>
</code></pre></div></div>

<p><strong>函数节流:</strong></p>

<p>函数被频繁调用的场景：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">window.onresize</code> 事件，浏览器窗口大小被改变的时候</li>
  <li><code class="language-plaintext highlighter-rouge">mousemove</code> 事件</li>
  <li>上传进度</li>
</ul>

<p>函数节流的代码实现：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">throttle</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span> <span class="nx">interval</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">_self</span> <span class="o">=</span> <span class="nx">fn</span><span class="p">,</span> <span class="c1">// 保存需要被延迟执行的函数引用</span>
        <span class="nx">timer</span><span class="p">,</span> <span class="c1">// 定时器</span>
        <span class="nx">firstTime</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span> <span class="c1">// 是否是第一次调用</span>

    <span class="k">return</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">args</span> <span class="o">=</span> <span class="nx">arguments</span><span class="p">,</span>
            <span class="nx">__me</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="nx">firstTime</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 如果是第一次调用，不需要延迟执行</span>
            <span class="nx">_self</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">__me</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>
            <span class="k">return</span> <span class="nx">firstTime</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span><span class="p">(</span><span class="nx">timer</span><span class="p">){</span> <span class="c1">// 如果定时器还在，说明前一次延迟执行还没有完成</span>
            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nx">timer</span> <span class="o">=</span> <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span> <span class="c1">// 延迟一段时间执行</span>
            <span class="nx">clearTimeout</span><span class="p">(</span><span class="nx">timer</span><span class="p">);</span>
            <span class="nx">timer</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
            <span class="nx">_self</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">__me</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>
        <span class="p">},</span> <span class="nx">interval</span> <span class="o">||</span> <span class="mi">500</span><span class="p">);</span>
    <span class="p">};</span>
<span class="p">};</span>

<span class="nb">window</span><span class="p">.</span><span class="nx">onresize</span> <span class="o">=</span> <span class="nx">throttle</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">},</span> <span class="mi">500</span><span class="p">);</span>
</code></pre></div></div>

<p>函数节流的原理：</p>

<p>将即将被执行的函数用 <code class="language-plaintext highlighter-rouge">setTimeout</code> 延迟一段时间执行。如果延迟执行还没有完成，则忽略接下来的调用</p>

<p><strong>分时函数：</strong></p>

<p>通过定时调用 <code class="language-plaintext highlighter-rouge">setInterval</code>，可以将大量数据的处理分批进行</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">timeChunk</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">ary</span><span class="p">,</span> <span class="nx">fn</span><span class="p">,</span> <span class="nx">count</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">obj</span><span class="p">,</span> <span class="nx">t</span><span class="p">;</span>
    
    <span class="kd">var</span> <span class="nx">start</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>

        <span class="c1">//  Math.min(int a, int b)方法用法实例教程 - 此方法返回a和b中的较小的, 避免 count 大于 ary.length 的 bug</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">count</span> <span class="o">||</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">ary</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nx">ary</span><span class="p">.</span><span class="nx">shift</span><span class="p">();</span>
            <span class="nx">fn</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">};</span>


    <span class="k">return</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">t</span> <span class="o">=</span> <span class="nx">setInterval</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">ary</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 如果全部节点都已经被创建好</span>
                <span class="k">return</span> <span class="nx">clearInterval</span><span class="p">(</span><span class="nx">t</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="nx">start</span><span class="p">();</span>
        <span class="p">},</span> <span class="mi">200</span><span class="p">);</span> <span class="c1">// 分批执行的时间间隔，也可以用参数的方式</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>惰性加载函数：</strong></p>

<p>addEvent 函数内有分支判断，第一次进入条件分支后，函数内部会重写这个函数</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">// 方案 3，惰性载入函数方案</span>

    <span class="kd">var</span> <span class="nx">addEvent</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">elem</span><span class="p">,</span> <span class="nx">type</span><span class="p">,</span> <span class="nx">handler</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">window</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">){</span>
            <span class="nx">addEvent</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">elem</span><span class="p">,</span> <span class="nx">type</span><span class="p">,</span> <span class="nx">handler</span><span class="p">){</span>
                <span class="nx">elem</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="nx">type</span><span class="p">,</span> <span class="nx">handler</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nb">window</span><span class="p">.</span><span class="nx">attachEvent</span><span class="p">){</span>
            <span class="nx">addEvent</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">elem</span><span class="p">,</span> <span class="nx">type</span><span class="p">,</span> <span class="nx">handler</span><span class="p">){</span>
                <span class="nx">elem</span><span class="p">.</span><span class="nx">attachEvent</span><span class="p">(</span><span class="dl">'</span><span class="s1">on</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">type</span><span class="p">,</span> <span class="nx">handler</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="nx">addEvent</span><span class="p">(</span><span class="nx">elem</span><span class="p">,</span> <span class="nx">type</span><span class="p">,</span> <span class="nx">handler</span><span class="p">);</span>
    <span class="p">};</span>

    <span class="kd">var</span> <span class="nx">div</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">div1</span><span class="dl">'</span><span class="p">);</span>
    <span class="nx">addEvent</span><span class="p">(</span><span class="nx">div</span><span class="p">,</span> <span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="nx">alert</span><span class="p">(</span><span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">});</span>

    <span class="nx">addEvent</span><span class="p">(</span><span class="nx">div</span><span class="p">,</span> <span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="nx">alert</span><span class="p">(</span><span class="dl">'</span><span class="s1">world</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">});</span>

    <span class="nx">addEvent</span><span class="p">(</span><span class="nx">div</span><span class="p">,</span> <span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="nx">alert</span><span class="p">(</span><span class="dl">'</span><span class="s1">andrew</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">});</span>
</code></pre></div></div>

<h2 id="第-4-章单例模式">第 4 章：单例模式</h2>

<p>单例模式定义：
保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>

<p><strong>代理实现单例模式：</strong></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">script</span> <span class="nx">type</span><span class="o">=</span><span class="dl">"</span><span class="s2">text/javascript</span><span class="dl">"</span><span class="o">&gt;</span>
<span class="kd">var</span> <span class="nx">CreateDiv</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">html</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">html</span> <span class="o">=</span> <span class="nx">html</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">init</span><span class="p">();</span>
<span class="p">};</span>

<span class="nx">CreateDiv</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">init</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">div</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">div</span><span class="dl">'</span><span class="p">);</span>
    <span class="nx">div</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">html</span><span class="p">;</span>
    <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">div</span><span class="p">);</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">ProxySingletonCreateDiv</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">instance</span><span class="p">;</span>
    <span class="k">return</span> <span class="kd">function</span><span class="p">(</span><span class="nx">html</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">instance</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">CreateDiv</span><span class="p">(</span><span class="nx">html</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">instance</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">})();</span>

<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ProxySingletonCreateDiv</span><span class="p">(</span><span class="dl">'</span><span class="s1">sven1</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ProxySingletonCreateDiv</span><span class="p">(</span><span class="dl">'</span><span class="s1">sven2</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">a</span> <span class="o">===</span> <span class="nx">b</span><span class="p">);</span> <span class="c1">// true</span>
<span class="o">&lt;</span><span class="sr">/script</span><span class="err">&gt;
</span></code></pre></div></div>

<p><strong>javascript 中的的单例模式：</strong></p>

<ul>
  <li>javascript 是无类(<code class="language-plaintext highlighter-rouge">clas-free</code>)语言，面向对象的单例模式不适用</li>
  <li>单例模式的核心：确保只有一个实例，并提供全局访问。</li>
</ul>

<h3 id="降低全局变量命名污染的方式">降低全局变量命名污染的方式:</h3>

<p><strong>1. 使用命名空间：</strong></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//  对象字面量命名空间</span>
<span class="kd">var</span> <span class="nx">namespace1</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">a</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">alert</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">},</span>
    <span class="na">b</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">alert</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 动态创建命名空间</span>
<span class="kd">var</span> <span class="nx">Myapp</span> <span class="o">=</span> <span class="p">{};</span>

<span class="nx">Myapp</span><span class="p">.</span><span class="nx">namespace</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">parts</span> <span class="o">=</span> <span class="nx">name</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">'</span><span class="s1">.</span><span class="dl">'</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">current</span> <span class="o">=</span> <span class="nx">Myapp</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="k">in</span> <span class="nx">parts</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">current</span><span class="p">[</span><span class="nx">parts</span><span class="p">[</span><span class="nx">i</span><span class="p">]])</span> <span class="p">{</span>
            <span class="nx">current</span><span class="p">[</span><span class="nx">parts</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{};</span>
        <span class="p">}</span>
        <span class="nx">current</span> <span class="o">=</span> <span class="nx">current</span><span class="p">[</span><span class="nx">parts</span><span class="p">[</span><span class="nx">i</span><span class="p">]];</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="nx">Myapp</span><span class="p">.</span><span class="nx">namespace</span><span class="p">(</span><span class="dl">'</span><span class="s1">event</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">Myapp</span><span class="p">.</span><span class="nx">namespace</span><span class="p">(</span><span class="dl">'</span><span class="s1">dom.style</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">Myapp</span><span class="p">);</span>

<span class="c1">// 上述代码等价于：</span>
<span class="kd">var</span> <span class="nx">Myapp</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">event</span><span class="p">:</span> <span class="p">{},</span>
    <span class="na">dom</span><span class="p">:</span> <span class="p">{</span>
        <span class="na">style</span><span class="p">:</span> <span class="p">{}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>使用闭包封装私有变量</li>
</ol>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 使用闭包封装私有变量</span>
<span class="kd">var</span> <span class="nx">user</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">_name</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">seven</span><span class="dl">'</span><span class="p">,</span>
        <span class="nx">_age</span> <span class="o">=</span> <span class="mi">29</span><span class="p">;</span>

    <span class="k">return</span> <span class="p">{</span>
        <span class="na">getUserInfo</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">_name</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">-</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">_age</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">})();</span>
</code></pre></div></div>

<p><strong>惰性单例：</strong></p>

<ul>
  <li>在需要的时候才创建对象实例</li>
</ul>

<p>通用惰性单例示例代码：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">button</span> <span class="nx">id</span><span class="o">=</span><span class="dl">"</span><span class="s2">loginbtn</span><span class="dl">"</span><span class="o">&gt;</span><span class="nx">打开百度</span><span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span><span class="o">&lt;</span><span class="nx">script</span> <span class="nx">type</span><span class="o">=</span><span class="dl">"</span><span class="s2">text/javascript</span><span class="dl">"</span><span class="o">&gt;</span>
<span class="kd">var</span> <span class="nx">getSingle</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">result</span><span class="p">;</span>
    <span class="k">return</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">result</span> <span class="o">||</span> <span class="p">(</span><span class="nx">result</span> <span class="o">=</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">));</span>
    <span class="p">};</span>
<span class="p">};</span>


<span class="kd">var</span> <span class="nx">createSingleIframe</span> <span class="o">=</span> <span class="nx">getSingle</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
    <span class="kd">var</span> <span class="nx">iframe</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">iframe</span><span class="dl">'</span><span class="p">);</span>
    <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">iframe</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">iframe</span><span class="p">;</span>
<span class="p">});</span>

<span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">loginbtn</span><span class="dl">'</span><span class="p">).</span><span class="nx">onclick</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">loginLayer</span> <span class="o">=</span> <span class="nx">createSingleIframe</span><span class="p">();</span>
    <span class="nx">loginLayer</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">http://baidu.com</span><span class="dl">"</span><span class="p">;</span>
<span class="p">}</span>
<span class="o">&lt;</span><span class="sr">/script</span><span class="err">&gt;
</span></code></pre></div></div>

<h2 id="第-5-章策略模式">第 5 章：策略模式</h2>

<ul>
  <li>策略模式的定义：定义一系列的算法，把它们一个个封装起来，并且使它们可以相互转换。</li>
  <li>基于策略模式的程序至少由两部分组成:
    <ul>
      <li>第一部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程</li>
      <li>第二部分是环境类 <code class="language-plaintext highlighter-rouge">Context</code>，<code class="language-plaintext highlighter-rouge">Context</code> 接受客户的请求，随后把请求委托给某一个策略类</li>
    </ul>
  </li>
  <li>策略模式可以消除程序中的大片的条件分支语句，这是对象多态性的体现</li>
  <li><code class="language-plaintext highlighter-rouge">Peter Norvig</code> 说过：”在函数作为一等对象的语言中，策略模式是隐形的。strategy 就是值为函数的变量”</li>
</ul>

<p><strong>策略模式的优缺点：</strong></p>

<p>优点：</p>

<ul>
  <li>策略模式利用组合、委托和多态等技术和思想，可以有效的避免多重条件选择语句</li>
  <li>策略模式提供了对开放-封闭原则的完美支持，将算法封装在独立的 strategy 语句中，使得它们易于切换，易于理解，易于扩展</li>
  <li>策略模式中的算法也可以复用在系统的其它地方，从而避免许多重复的复制粘贴工作</li>
  <li>在策略模式中利用组合和委托来让 <code class="language-plaintext highlighter-rouge">Context</code> 拥有执行算法的能力，这也是继承的一种更轻便的替代方案</li>
</ul>

<p>缺点：</p>

<ul>
  <li>策略模式会在程序中增加许多策略类或者策略对象</li>
  <li>使用策略模式，strategy 要向客户暴露它的所有实现，这是违反最少知识原则的</li>
</ul>

<h2 id="第-6-章代理模式">第 6 章：代理模式</h2>

<ul>
  <li>代理模式是为一个对象提供一个代用品或占位符，以便于控制对它的访问</li>
  <li>生活中的场景：明星的经纪人</li>
  <li>代理模式的关键：当客户不方便直接访问一个对象或不满足需要的时候，提供一个替身对象来控制对这个对象的访问，客户实际访问替身对象。替身对象对请求做出一些处理之后，再把请求转交给本体对象</li>
  <li><code class="language-plaintext highlighter-rouge">单一职责：</code> 就一个类（通常也包括对象和函数等）而言，应该仅有一个引起它变化的原因</li>
  <li>代理和本体接口的一致性：
    <ul>
      <li>用户可以放心的请求代理，他只关心是否能得到想要的结果</li>
      <li>在任何使用本体的地方都可以替换成并使用代理</li>
    </ul>
  </li>
  <li>编写业务代码时，不需要猜测是否需要使用代理模式，当真正发现不方便直接访问某个对象时，再编写代理也不迟</li>
</ul>

<p>虚拟代理实现图片预加载：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="o">&lt;</span><span class="nx">script</span> <span class="nx">type</span><span class="o">=</span><span class="dl">"</span><span class="s2">text/javascript</span><span class="dl">"</span><span class="o">&gt;</span>
    <span class="kd">var</span> <span class="nx">myImage</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">imgNode</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">img</span><span class="dl">'</span><span class="p">);</span>
        <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">imgNode</span><span class="p">);</span>
        <span class="k">return</span> <span class="kd">function</span><span class="p">(</span><span class="nx">src</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">imgNode</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="nx">src</span><span class="p">;</span>
        <span class="p">};</span>
    <span class="p">})();</span>

    <span class="c1">// 没有改变或增加 myImage 的接口</span>
    <span class="c1">// 通过代理给系统增加了新的行为，符合开放封闭原则</span>
    <span class="kd">var</span> <span class="nx">proxyImage</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">img</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Image</span><span class="p">;</span>
        <span class="nx">img</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">src</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">src</span><span class="p">;</span>
            <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
                <span class="nx">myImage</span><span class="p">(</span><span class="nx">src</span><span class="p">);</span>
            <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="kd">function</span><span class="p">(</span><span class="nx">src</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">myImage</span><span class="p">(</span><span class="dl">"</span><span class="s2">/images/loading.gif</span><span class="dl">"</span><span class="p">);</span>
            <span class="nx">img</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="nx">src</span><span class="p">;</span>
        <span class="p">};</span>

    <span class="p">})();</span>

    <span class="c1">// proxyImage('http://ww1.sinaimg.cn/large/aeb19806gw1ermlpunhdej20rs15owon.jpg')</span>
    <span class="nx">proxyImage</span><span class="p">(</span><span class="dl">"</span><span class="s2">http://bbsimg0.dahe.cn/Day_141111/1038_14484479_acc705d86c0bc0a.jpg</span><span class="dl">"</span><span class="p">);</span>

    <span class="o">&lt;</span><span class="sr">/script</span><span class="err">&gt;
</span></code></pre></div></div>

<h2 id="第-7-章迭代器模式">第 7 章：迭代器模式</h2>

<ul>
  <li>迭代器模式：是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示</li>
</ul>

<p>内部迭代器：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">each</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">ary</span><span class="p">,</span> <span class="nx">callback</span><span class="p">){</span>
  <span class="k">for</span><span class="p">(</span> <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">l</span> <span class="o">=</span> <span class="nx">ary</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">l</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
    <span class="nx">callback</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">ary</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">ary</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span> <span class="c1">// 把下标和元素当作参数传给 callback 参数</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>外部迭代器：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">Iterator</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">current</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="kd">var</span> <span class="nx">next</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">current</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="kd">var</span> <span class="nx">isDone</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">current</span> <span class="o">&gt;=</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="kd">var</span> <span class="nx">getCurrItem</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">obj</span><span class="p">[</span><span class="nx">current</span><span class="p">];</span>
    <span class="p">};</span>

    <span class="k">return</span> <span class="p">{</span>
        <span class="na">next</span><span class="p">:</span> <span class="nx">next</span><span class="p">,</span>
        <span class="na">isDone</span><span class="p">:</span> <span class="nx">isDone</span><span class="p">,</span>
        <span class="na">getCurrItem</span><span class="p">:</span> <span class="nx">getCurrItem</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="第-8-章发布订阅模式">第 8 章：发布订阅模式</h2>

<ul>
  <li>发布订阅模式又叫观察者模式，它定义对象之间的一种一对多的关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。</li>
  <li>js 开发中，一般用事件模型来代替传统的发布-订阅模式</li>
  <li>发布订阅模式可以广泛应用于异步编程中，替代传递回调函数的方案</li>
  <li>发布订阅模式可以取代对象之间硬编码的通知机制，一个对象不用再显式得调用另外一个对象的某个接口，松耦合的联系在一起，不清楚彼此细节，但不影响通信。</li>
  <li><code class="language-plaintext highlighter-rouge">DOM 事件</code>就是使用发布-订阅模式</li>
</ul>

<p><strong>自定义事件：</strong></p>

<ul>
  <li>首先要指定好谁充当发布者（比如售楼部）；</li>
  <li>然后给发布者添加一个缓存列表，用于存放回调函数以便于通知订阅者（售楼部的花名册）</li>
  <li>最后发布消息时，发布者会遍历这个缓存列表，依次触发里面存放的订阅者回调函数（遍历花名册，挨个发短信）</li>
</ul>

<p>发布订阅模式的通用实现：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">event</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">clientList</span><span class="p">:</span> <span class="p">[],</span>
    <span class="na">listen</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">fn</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">clientList</span><span class="p">[</span><span class="nx">key</span><span class="p">])</span> <span class="p">{</span> <span class="c1">// 如果还没有订阅过此类消息，给该类消息创建一个缓存列表</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">clientList</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[];</span>
        <span class="p">}</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">clientList</span><span class="p">[</span><span class="nx">key</span><span class="p">].</span><span class="nx">push</span><span class="p">(</span><span class="nx">fn</span><span class="p">);</span> <span class="c1">// 订阅的消息添加进消息缓存列表</span>
    <span class="p">},</span>
    <span class="na">trigger</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">key</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">shift</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">),</span> <span class="c1">// 取出消息类型</span>
            <span class="nx">fns</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">clientList</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span> <span class="c1">//取出该类消息对应的回调函数集合</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">fns</span> <span class="o">||</span> <span class="nx">fns</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 如果没有订阅该消息，则返回</span>
            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">fn</span><span class="p">;</span> <span class="nx">fn</span> <span class="o">=</span> <span class="nx">fns</span><span class="p">[</span><span class="nx">i</span><span class="o">++</span><span class="p">];)</span> <span class="p">{</span>
            <span class="nx">fn</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span> <span class="c1">// arguments 是发布消息时带上的参数</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 给对象动态安装发布-订阅功能</span>
<span class="kd">var</span> <span class="nx">installEvent</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="k">in</span> <span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">obj</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">event</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="第-9-章命令模式">第 9 章：命令模式</h2>

<ul>
  <li>命令模式中的命令指的是一个执行某些特定事情的指令</li>
  <li>命令模式的应用场景是：有时候需要向某些对象发送请求，但是并不知道请求的接受者是谁，也不知道被请求的操作是什么</li>
  <li>命令模式是一种松耦合的设计方式，使命令发送者和请求接收者能够消除彼此之间的耦合关系</li>
  <li>设计模式的主题总是把不变的事物和变化的事物分离开来</li>
</ul>

<p>js 命令模式示例：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">button1</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">button1</span><span class="dl">'</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">setCommand</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">button</span><span class="p">,</span> <span class="nx">command</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">button</span><span class="p">.</span><span class="nx">onclick</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="nx">command</span><span class="p">.</span><span class="nx">execute</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">MenuBar</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">refresh</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">刷新菜单目录</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">SubMenu</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">add</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">增加子菜单</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">},</span>
    <span class="na">del</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">删除子菜单</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">RefreshMenuBarCommand</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">receiver</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="na">execute</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">receiver</span><span class="p">.</span><span class="nx">refresh</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">refreshMenuBarCommand</span>  <span class="o">=</span> <span class="nx">RefreshMenuBarCommand</span><span class="p">(</span><span class="nx">MenuBar</span><span class="p">);</span>
<span class="nx">setCommand</span><span class="p">(</span><span class="nx">button1</span><span class="p">,</span> <span class="nx">refreshMenuBarCommand</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="第-10-章组合模式">第 10 章：组合模式</h2>

<ul>
  <li>组合模式是用小的子对象来构建更大的对象，而小的子对象本身也许是由更小的“孙对象”构成的</li>
  <li>组合模式将对象组合成树形结构，以表示 “部分-整体” 的层次结构</li>
  <li>
    <p>组合模式通过对象多态性表现，使得用户对单个对象和组合对象的使用具有一致性</p>
  </li>
  <li>组合模式注意的地方：
    <ul>
      <li>组合模式不是父子关系：组合模式是 <code class="language-plaintext highlighter-rouge">HAS-A</code>(聚合)的关系</li>
      <li>对叶对象操作的一致性：组合模式要求组合对象和叶对象拥有相同的接口，对一组叶对象的操作必须具有一致性</li>
      <li>双向映射关系</li>
      <li>用职责链模式提高组合模式性能</li>
    </ul>
  </li>
  <li>如何使用组合模式：
    <ul>
      <li>表示对象的部分-整体层次结构。</li>
      <li>客户希望统一对待树中的是所有对象，忽略组合对象和叶对象的区别</li>
    </ul>
  </li>
  <li>组合模式的每个对象的区别只有在运行时才会显现，会使代码难以理解</li>
  <li>如果通过组合模式创建了太多的对象，那么这些对象可能会让系统负担不起</li>
</ul>

<p>组合模式示例代码：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">closeDoorCommand</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">execute</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">关门</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">},</span>
    <span class="na">add</span><span class="p">:</span> <span class="nx">funciton</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="dl">'</span><span class="s1">叶对象不能添加子节点</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">openPcCommand</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">execute</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">开电脑</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">},</span>
    <span class="na">add</span><span class="p">:</span> <span class="nx">funciton</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="dl">'</span><span class="s1">叶对象不能添加子节点</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">openQQCommand</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">execute</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">登录 QQ</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">},</span>
    <span class="na">add</span><span class="p">:</span> <span class="nx">funciton</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="dl">'</span><span class="s1">叶对象不能添加子节点</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">MacroCommand</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="na">commandsList</span><span class="p">:</span> <span class="p">[],</span>
        <span class="na">add</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">command</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">commandsList</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">command</span><span class="p">)</span>
        <span class="p">},</span>
        <span class="na">execute</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">command</span><span class="p">;</span> <span class="nx">command</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">commandsList</span><span class="p">[</span><span class="nx">i</span><span class="o">++</span><span class="p">];)</span> <span class="p">{</span>
                <span class="nx">command</span><span class="p">.</span><span class="nx">execute</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">macroCommand</span> <span class="o">=</span> <span class="nx">MacroCommand</span><span class="p">();</span>
<span class="nx">macroCommand</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">closeDoorCommand</span><span class="p">);</span>
<span class="nx">macroCommand</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">openPcCommand</span><span class="p">);</span>
<span class="nx">macroCommand</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">openQQCommand</span><span class="p">);</span>

<span class="nx">macroCommand</span><span class="p">.</span><span class="nx">execute</span><span class="p">();</span>
</code></pre></div></div>

<h2 id="第-11-章模板方法模式">第 11 章：模板方法模式</h2>

<ul>
  <li>模板方法是只需要使用集成就可以实现的非常简单的模式</li>
  <li>模板方法由两部分组成，第一部分是抽象父类，第二部分是具体的实现子类</li>
  <li>父类中封装了子类的算法框架，包括实现一些公共方法以及封装子类中所有方法的执行顺序。子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法</li>
</ul>

<p><strong>抽象类：</strong></p>

<ul>
  <li>模板方法模式是一种严重依赖抽象类的设计模式</li>
  <li>抽象类不可以实例化</li>
  <li>依赖倒置原则：
    <ul>
      <li>A.高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。</li>
      <li>B.抽象不应该依赖于具体实现，具体实现应该依赖于抽象。</li>
    </ul>
  </li>
  <li>继承抽象类的所有子类都将拥有跟抽象类一致的接口方法，抽象类的主要作用就是为它的子类定义这些公共接口</li>
</ul>

<p>模板方法示例代码：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">Beverage</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{};</span>

<span class="nx">Beverage</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">boilWater</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">把水煮沸</span><span class="dl">'</span><span class="p">);</span>
<span class="p">};</span>

<span class="nx">Beverage</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">brew</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{};</span> <span class="c1">// 空方法，应该由子类重写</span>
<span class="nx">Beverage</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">pourInCup</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{};</span> <span class="c1">// 空方法，应该由子类重写</span>
<span class="nx">Beverage</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">addCondiments</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{};</span> <span class="c1">// 空方法，应该由子类重写</span>

<span class="nx">Beverage</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">customerWantsCondiments</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span> <span class="c1">// 默认需要调料</span>
<span class="p">};</span>

<span class="nx">Beverage</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">init</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">boilWater</span><span class="p">();</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">brew</span><span class="p">();</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">pourInCup</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">customerWantsCondiments</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">addCondiments</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">Coffee</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{};</span>

<span class="nx">Coffee</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Beverage</span><span class="p">();</span>

<span class="nx">Coffee</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">brew</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">用沸水冲泡咖啡</span><span class="dl">'</span><span class="p">);</span>
<span class="p">};</span>

<span class="nx">Coffee</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">pourInCup</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">把咖啡倒进杯子</span><span class="dl">'</span><span class="p">);</span>
<span class="p">};</span>

<span class="nx">Coffee</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">addCondiments</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">加糖和牛奶</span><span class="dl">'</span><span class="p">);</span>
<span class="p">};</span>

<span class="nx">Coffee</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">customerWantsCondiments</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">window</span><span class="p">.</span><span class="nx">confirm</span><span class="p">(</span><span class="dl">'</span><span class="s1">请问需要调料吗？</span><span class="dl">'</span><span class="p">);</span>
<span class="p">};</span>


<span class="kd">var</span> <span class="nx">coffee</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Coffee</span><span class="p">();</span>
<span class="nx">coffee</span><span class="p">.</span><span class="nx">init</span><span class="p">();</span>
</code></pre></div></div>

<p><strong>好莱坞原则：</strong></p>

<ul>
  <li>好莱坞对待新人的：<code class="language-plaintext highlighter-rouge">不要来找我，我会给你打电话</code></li>
  <li>高层组件调用底层组件</li>
  <li>使用场景：
    <ul>
      <li>发布-订阅模式</li>
      <li>回调函数</li>
    </ul>
  </li>
</ul>

<p>非继承代码示例：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">Beverage</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">params</span><span class="p">)</span> <span class="p">{</span>

    <span class="kd">var</span> <span class="nx">boilWater</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">把水煮沸</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">};</span>

    <span class="kd">var</span> <span class="nx">brew</span> <span class="o">=</span> <span class="nx">params</span><span class="p">.</span><span class="nx">brew</span> <span class="o">||</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="dl">'</span><span class="s1">必须传递 brew 方法</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">};</span>

    <span class="kd">var</span> <span class="nx">pourInCup</span> <span class="o">=</span> <span class="nx">params</span><span class="p">.</span><span class="nx">pourInCup</span> <span class="o">||</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="dl">'</span><span class="s1">必须传递 pourInCup 方法</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">};</span>

    <span class="kd">var</span> <span class="nx">addCondiments</span> <span class="o">=</span> <span class="nx">params</span><span class="p">.</span><span class="nx">addCondiments</span> <span class="o">||</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="dl">'</span><span class="s1">必须传递 addCondiments 方法</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">};</span>

    <span class="kd">var</span> <span class="nx">customerWantsCondiments</span> <span class="o">=</span> <span class="nx">params</span><span class="p">.</span><span class="nx">customerWantsCondiments</span> <span class="o">||</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="kd">var</span> <span class="nx">F</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{};</span>

    <span class="nx">F</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">init</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">boilWater</span><span class="p">();</span>
        <span class="nx">brew</span><span class="p">();</span>
        <span class="nx">pourInCup</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">customerWantsCondiments</span><span class="p">())</span> <span class="p">{</span>
            <span class="nx">addCondiments</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">return</span> <span class="nx">F</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">Tea</span> <span class="o">=</span> <span class="nx">Beverage</span><span class="p">({</span>
    <span class="na">brew</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">用沸水浸泡茶叶</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">},</span>
    <span class="na">pourInCup</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">把茶倒进杯子</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">},</span>
    <span class="na">addCondiments</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">加柠檬</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">},</span>
    <span class="na">customerWantsCondiments</span><span class="p">:</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="k">return</span> <span class="nb">window</span><span class="p">.</span><span class="nx">confirm</span><span class="p">(</span><span class="dl">'</span><span class="s1">请问需要加调料吗？</span><span class="dl">'</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">});</span>

<span class="kd">var</span> <span class="nx">tea</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Tea</span><span class="p">();</span>
<span class="nx">tea</span><span class="p">.</span><span class="nx">init</span><span class="p">();</span>
</code></pre></div></div>

<h2 id="第-12-章享元模式flyweight">第 12 章：享元模式(flyweight)</h2>

<ul>
  <li>享元模式是一种用于性能优化的模式, <code class="language-plaintext highlighter-rouge">fly</code> 是苍蝇的意思，<code class="language-plaintext highlighter-rouge">flyweight</code> 意为蝇量级。</li>
  <li>享元模式的核心是运用共享技术来有效支持大量细粒度的对象</li>
  <li>如果因为创建大量类似的对象导致内存占用过高，享元模式可以节省内存
-享元模式是一种用时间换空间的优化模式</li>
</ul>

<p>享元模式代码示例：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">Model</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">sex</span><span class="p">,</span> <span class="nx">underwear</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">sex</span> <span class="o">=</span> <span class="nx">sex</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">underwear</span> <span class="o">=</span> <span class="nx">underwear</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">Model</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">takePhoto</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">sex=</span><span class="dl">'</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">sex</span> <span class="o">+</span> <span class="dl">'</span><span class="s1"> underwear=</span><span class="dl">'</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">underwear</span><span class="p">);</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">maleModel</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Model</span><span class="p">(</span><span class="dl">'</span><span class="s1">male</span><span class="dl">'</span><span class="p">),</span>
    <span class="nx">femaleModel</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Model</span><span class="p">(</span><span class="dl">'</span><span class="s1">female</span><span class="dl">'</span><span class="p">);</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">50</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">maleModel</span><span class="p">.</span><span class="nx">underwear</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">underwear</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">i</span><span class="p">;</span>
    <span class="nx">maleModel</span><span class="p">.</span><span class="nx">takePhoto</span><span class="p">();</span>
<span class="p">};</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">50</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">femaleModel</span><span class="p">.</span><span class="nx">underwear</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">underwear</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">i</span><span class="p">;</span>
    <span class="nx">femaleModel</span><span class="p">.</span><span class="nx">takePhoto</span><span class="p">();</span>
<span class="p">};</span>
</code></pre></div></div>

<p><strong>内部状态与外部状态：</strong></p>

<ul>
  <li>享元模式要求将对象的属性划分为内部状态和外部状态（状态在这里指属性）</li>
  <li>享元模式的目的是尽量减少共享对象的数量</li>
  <li>划分内部和外部状态的指引：
    <ul>
      <li>内部状态存储于对象内部</li>
      <li>内部状态可以被一些对象共享</li>
      <li>内部状态独立于具体的场景，通常不会改变</li>
      <li>外部状态取决于具体的场景，并根据场景而变化，外部状态不能被共享</li>
    </ul>
  </li>
</ul>

<p>对象池代码示例：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">objectPoolFactory</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">createObjFn</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">objectPool</span> <span class="o">=</span> <span class="p">[];</span>

    <span class="k">return</span> <span class="p">{</span>
        <span class="na">create</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">obj</span><span class="p">;</span>
            <span class="c1">// var obj = objectPool.length === 0 ?</span>
            <span class="c1">// createObjFn.apply(this, arguments) : objectPool.shift();</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">objectPool</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">obj</span> <span class="o">=</span> <span class="nx">createObjFn</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nx">obj</span> <span class="o">=</span> <span class="nx">objectPool</span><span class="p">.</span><span class="nx">shift</span><span class="p">();</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="nx">obj</span><span class="p">;</span>
        <span class="p">},</span>
        <span class="na">recover</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">objectPool</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">objectPool</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">iframeFactory</span> <span class="o">=</span> <span class="nx">objectPoolFactory</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">iframe</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">iframe</span><span class="dl">'</span><span class="p">);</span>
    <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">iframe</span><span class="p">);</span>

    <span class="nx">iframe</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">iframe</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// 防止 iframe 重复加载的 bug</span>
        <span class="nx">iframeFactory</span><span class="p">.</span><span class="nx">recover</span><span class="p">(</span><span class="nx">iframe</span><span class="p">);</span> <span class="c1">// iframe 加载完成之后回收节点</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">iframe</span><span class="p">;</span>
<span class="p">});</span>

<span class="kd">var</span> <span class="nx">iframe1</span> <span class="o">=</span> <span class="nx">iframeFactory</span><span class="p">.</span><span class="nx">create</span><span class="p">();</span>
<span class="nx">iframe1</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">http://baidu.com</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">iframe2</span> <span class="o">=</span> <span class="nx">iframeFactory</span><span class="p">.</span><span class="nx">create</span><span class="p">();</span>
<span class="nx">iframe2</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">http://qq.com</span><span class="dl">'</span><span class="p">;</span>

<span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">iframe3</span> <span class="o">=</span> <span class="nx">iframeFactory</span><span class="p">.</span><span class="nx">create</span><span class="p">();</span>
    <span class="nx">iframe3</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">http://163.com</span><span class="dl">'</span><span class="p">;</span>
<span class="p">},</span> <span class="mi">3000</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="第-13-章职责链模式">第 13 章：职责链模式</h2>

<ul>
  <li>职责链模式的定义是：使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，知道有一个对象处理它为止。</li>
</ul>

<p>职责链代码示例：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">var</span> <span class="nx">order500</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">orderType</span><span class="p">,</span> <span class="nx">pay</span><span class="p">,</span> <span class="nx">stock</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">orderType</span> <span class="o">===</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">pay</span> <span class="o">===</span> <span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">500 元定金预购,得到 100 优惠劵</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="dl">'</span><span class="s1">nextSuccessor</span><span class="dl">'</span><span class="p">;</span> <span class="c1">// 我不知道下一个节点是谁，反正把请求往后面传递</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">order200</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">orderType</span><span class="p">,</span> <span class="nx">pay</span><span class="p">,</span> <span class="nx">stock</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">orderType</span> <span class="o">===</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="nx">pay</span> <span class="o">===</span> <span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">200 元定金预购,得到 50 优惠劵</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="dl">'</span><span class="s1">nextSuccessor</span><span class="dl">'</span><span class="p">;</span> <span class="c1">// 我不知道下一个节点是谁，反正把请求往后面传递</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">orderNormal</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">orderType</span><span class="p">,</span> <span class="nx">pay</span><span class="p">,</span> <span class="nx">stock</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">stock</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">普通购买，无优惠劵</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">手机库存不足</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>


<span class="kd">var</span> <span class="nx">Chain</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">fn</span> <span class="o">=</span> <span class="nx">fn</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">successor</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="p">};</span>

<span class="nx">Chain</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">setNextSuccessor</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">successor</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">successor</span> <span class="o">=</span> <span class="nx">successor</span><span class="p">;</span>
<span class="p">};</span>

<span class="nx">Chain</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">passRequest</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">ret</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">fn</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="nx">ret</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">nextSuccessor</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">successor</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="p">.</span><span class="nx">successor</span><span class="p">.</span><span class="nx">passRequest</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">successor</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">chainOrder500</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Chain</span><span class="p">(</span> <span class="nx">order500</span> <span class="p">);</span>
<span class="kd">var</span> <span class="nx">chainOrder200</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Chain</span><span class="p">(</span> <span class="nx">order200</span> <span class="p">);</span>
<span class="kd">var</span> <span class="nx">chainOrderNormal</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Chain</span><span class="p">(</span> <span class="nx">orderNormal</span> <span class="p">);</span>

<span class="nx">chainOrder500</span><span class="p">.</span><span class="nx">setNextSuccessor</span><span class="p">(</span> <span class="nx">chainOrder200</span> <span class="p">);</span>
<span class="nx">chainOrder200</span><span class="p">.</span><span class="nx">setNextSuccessor</span><span class="p">(</span> <span class="nx">chainOrderNormal</span> <span class="p">);</span>

<span class="nx">chainOrder500</span><span class="p">.</span><span class="nx">passRequest</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="mi">500</span><span class="p">);</span> <span class="c1">// 输出：500 元定金预购,得到 100 优惠劵</span>
<span class="nx">chainOrder500</span><span class="p">.</span><span class="nx">passRequest</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="mi">500</span><span class="p">);</span> <span class="c1">// 输出：200 元定金预购,得到 50 优惠劵</span>
<span class="nx">chainOrder500</span><span class="p">.</span><span class="nx">passRequest</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="mi">500</span><span class="p">);</span> <span class="c1">// 输出：普通购买，无优惠劵</span>
<span class="nx">chainOrder500</span><span class="p">.</span><span class="nx">passRequest</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// 输出：手机库存不足</span>
</code></pre></div></div>

<p><strong>职责链中的优缺点：</strong></p>

<ul>
  <li>最大优点就是解耦了请求发送者和 N 个接收者之间的复杂关系</li>
  <li>可以手动设置起始节点，请求并不是非得从链中的第一个节点开始传递</li>
  <li>职责链中大部分节点并没有起到实质性的作用，他们仅仅是让请求传递下去，从性能方面考虑，我们要避免过长的职责链带来的性能损耗</li>
</ul>

<p>AOP 实现职责链：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">after</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span> <span class="nx">fn</span> <span class="p">){</span>
    <span class="kd">var</span> <span class="nb">self</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="k">return</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="kd">var</span> <span class="nx">ret</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span> <span class="k">this</span><span class="p">,</span> <span class="nx">arguments</span> <span class="p">);</span>
        <span class="k">if</span><span class="p">(</span> <span class="nx">ret</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">nextSuccessor</span><span class="dl">'</span><span class="p">){</span>
            <span class="k">return</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nx">ret</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span> 
</code></pre></div></div>

<h2 id="第-14-章中介者模式">第 14 章：中介者模式</h2>

<ul>
  <li>中介者模式的作用就是解除对象与对象之间的紧耦合关系。</li>
  <li>增加一个中介者对象后，所有的相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知中介者对象即可</li>
  <li>中介者模式使网状的多对多关系变成了相对简单的一对多关系</li>
</ul>

<p><img src="/assets/images/中介者模式.png" alt="中介者模式" /></p>

<p>现实的中介者：</p>

<ul>
  <li>机场指挥塔</li>
  <li>博彩公司</li>
</ul>

<p>小结：</p>

<ul>
  <li>迪密特法则叫最少知识原则，是指一个对象应该尽可能少地了解另外的对象(类似不合陌生人说话)</li>
  <li>中介者模式是迎合迪米特法则的一种实现</li>
  <li>中介者模式里，对象之间几乎不知道彼此的存在，只能通过中介者对象来互相影响对方</li>
  <li>如果对象之间的复杂耦合度导致调用和维护出现困难，而且耦合度随项目的变化呈指数增长曲线，那么就可以考虑用中介者模式来重构代码</li>
</ul>

<h2 id="第-15-章装饰者模式">第 15 章：装饰者模式</h2>

<ul>
  <li>给对象动态得增加职责的方式称为装饰者模式</li>
  <li>装饰者模式能够在不改变对象自身的基础上，在程序运行起劲给对象动态的添加职责</li>
  <li>GOF 原想把装饰者(<code class="language-plaintext highlighter-rouge">decorator</code>) 模式称为包装器(<code class="language-plaintext highlighter-rouge">wrapper</code>)模式</li>
  <li>装饰者模式将一个对象嵌入另一个对象之中，实际上相当于这个对象被另一个对象包装起来，形成一条包装链，请求随着包装链一次传递到所有的对象</li>
</ul>

<p>js 版本的装饰者示例：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">plane</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">fire</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">发射普通子弹</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">missileDecorator</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">发射导弹</span><span class="dl">'</span><span class="p">);</span>
<span class="p">};</span>
<span class="kd">var</span> <span class="nx">AtomDecorator</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">发射原子弹</span><span class="dl">'</span><span class="p">);</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">fire1</span> <span class="o">=</span> <span class="nx">plane</span><span class="p">.</span><span class="nx">fire</span><span class="p">;</span>
<span class="nx">plane</span><span class="p">.</span><span class="nx">fire</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fire1</span><span class="p">();</span>
    <span class="nx">missileDecorator</span><span class="p">();</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">fire2</span> <span class="o">=</span> <span class="nx">plane</span><span class="p">.</span><span class="nx">fire</span><span class="p">;</span>
<span class="nx">plane</span><span class="p">.</span><span class="nx">fire</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fire2</span><span class="p">();</span>
    <span class="nx">AtomDecorator</span><span class="p">();</span>
<span class="p">};</span>

<span class="nx">plane</span><span class="p">.</span><span class="nx">fire</span><span class="p">();</span>
</code></pre></div></div>

<h2 id="第-16-章状态模式">第 16 章：状态模式</h2>

<ul>
  <li>状态模式的关键是区分事务内部的状态，事物内部状态的改变往往会带来事物的行为改变</li>
  <li>优点：
    <ul>
      <li>状态模式定义了状态和行为之间的关系，并将它们封装在一个类里，通过增加新的状态类，很容易增加新的状态和转换</li>
      <li>避免 <code class="language-plaintext highlighter-rouge">Context</code> 无限膨胀，状态切换的逻辑被分布在状态类中，也去掉了 <code class="language-plaintext highlighter-rouge">Context</code> 中原本过多的条件分支</li>
      <li>用对象代理字符串来记录当前状态，使得状态的切换更加一目了然</li>
      <li><code class="language-plaintext highlighter-rouge">Context</code> 中的请求动作和状态类中封装的行为可以非常容易地独立变化而互不影响</li>
    </ul>
  </li>
  <li>缺点：
    <ul>
      <li>定义许多状态类，增加了很多对象</li>
      <li>逻辑分散，无法在一个地方理解整个状态机的逻辑</li>
    </ul>
  </li>
  <li>状态和策略的类图几乎一模一样，但意图不同，策略的各个策略类之间没有任何联系，状态模式中状态之间有 “改变行为” 的切换规定</li>
</ul>

<h3 id="有限状态机">有限状态机</h3>

<ul>
  <li>http://www.ruanyifeng.com/blog/2013/09/finite-state_machine_for_javascript.html</li>
  <li>https://github.com/jakesgordon/javascript-state-machine</li>
</ul>

<p>有限状态机的实践：</p>

<ul>
  <li>游戏开发中，游戏 API 的逻辑编写，比如游戏格斗任务有走动、攻击、防御、跌倒、跳跃等多种状态</li>
  <li>比如 TCP 请求有建立连接、监听、关闭等状态</li>
</ul>

<h2 id="第-17-章适配器模式">第 17 章：适配器模式</h2>

<ul>
  <li>适配器的别名是包装器(<code class="language-plaintext highlighter-rouge">wrapper</code>)，这是一个相对简单的模式</li>
  <li>适配器应用场景：当我们试图调用模块或者对象的某个接口时，却发现这个接口的格式不符合目前的需求，可以创建适配器，将原接口转换为客户希望的另一个接口，客户只需要和适配器打交道</li>
  <li>现实中的适配器：港式插头转换器、电源适配器、USB 转换口</li>
  <li>适配器模式主要用来解决两个已有接口之间不匹配的问题，它不考虑这些接口是怎样实现的，也饿不考虑它们奖励可能会如何演化。适配器模式不需要改变已有的接口，就能够使它们协同作用</li>
  <li>装饰者模式和代理模式也不会改变原有对象的接口，但装饰者模式的作用是为了给对象增加功能。
    <ul>
      <li>装饰链模式常常形成一条长的装饰链</li>
      <li>适配器模式通常只包装一次</li>
      <li>代理模式是为了控制对对象的访问，通常也只包装一次</li>
    </ul>
  </li>
  <li>外观模式的作用倒是和适配器比较相似，有人把外观模式看成一组对象的适配器，但外观模式最显著的特点是定义了一个新的接口</li>
</ul>

<h2 id="第-18-章单一职责原则">第 18 章：单一职责原则</h2>

<ul>
  <li>单一职责原则（<code class="language-plaintext highlighter-rouge">SRP</code>）的职责被定义为“引起变化的原因”，就一个类而言，应该有且仅有一个引起它变化的原因</li>
  <li><code class="language-plaintext highlighter-rouge">SRP</code> 原则体现为：一个对象（方法）只做一件事情</li>
  <li><code class="language-plaintext highlighter-rouge">SRP</code> 原则是最简单也是最难正确运用的原则之一，因为并不是所有的职责都应该一一分离</li>
</ul>

<h2 id="第-19-章最少知识原则">第 19 章：最少知识原则</h2>

<ul>
  <li>最少知识原则(<code class="language-plaintext highlighter-rouge">LKP</code>)说的是一个软件实体应当尽可能少地与其他实体发生相互作用</li>
  <li>软件实体是一个广义概念，不仅包括对象，还包括系统、类、模块、函数、变量等</li>
  <li><code class="language-plaintext highlighter-rouge">LKP</code> 要求设计中尽量减少队形之间的联系</li>
  <li>最少知识原则在设计模式中体现得最多的地方是中介者模式和外观模式</li>
  <li>外观模式的作用：
    <ul>
      <li>为一组子系统提供一个简单遍历的访问入口</li>
      <li>隔离客户与复杂子系统之间的联系，客户不用去了解子系统的细节</li>
    </ul>
  </li>
  <li>最少知识原则又称为迪米特法则</li>
  <li>最少知识原则可以减少对象之间的依赖，但也有可能增加一些庞大到难以遵守的第三者对象</li>
</ul>

<h2 id="第-19-章开放-封闭原则">第 19 章：开放-封闭原则</h2>

<ul>
  <li>开放-封闭原则定义：软件实体（类、模块、函数）等应该是可以扩展的，但是不可修改</li>
  <li>遵守开放-封闭原则的规律，最明显的就是找出程序中将要发生变化的地方，然后将变化封装起来</li>
  <li>编写开放-封闭原则代码的方式：
    <ul>
      <li>放置挂钩：放置挂钩(hook)也是分离变化的一种方式，我们在程序有可能发生变化的地方放置一个挂钩，挂钩的返回结果决定了程序的下一步走向</li>
      <li>使用回调函数</li>
    </ul>
  </li>
  <li>挑出最容易发生变化的地方，然后构造抽象来封闭这些变化</li>
  <li>在不可避免发生修改的时候，尽量修改那些相对容易修改的地方，比如修改配置文件比修改源码简单方便</li>
</ul>

<h2 id="第-21-章接口和面向接口编程">第 21 章：接口和面向接口编程</h2>

<ul>
  <li>接口是对象能响应的请求的集合</li>
  <li>抽象类的作用：
    <ul>
      <li>向上转型</li>
      <li>建立一些契约</li>
    </ul>
  </li>
  <li>面向接口编程，而不是面向实现编程</li>
  <li>抽象类和 interface 的作用：
    <ul>
      <li>通过向上转型来隐藏对象的真正类型，以表现对象的多态性</li>
      <li>约定类与类支架按的一些契约行为</li>
    </ul>
  </li>
</ul>

<h2 id="第-22-章代码重构">第 22 章：代码重构</h2>

<ul>
  <li>提炼函数
    <ul>
      <li>避免出现超大函数</li>
      <li>独立出来的函数有助于代码复用</li>
      <li>独立出来的函数更容易被覆写</li>
      <li>独立出来的函数如果拥有一个良好的命名，它本身就起到了注释的作用</li>
    </ul>
  </li>
</ul>

]]></content>
	</entry>
	
	<entry>
		<title>GO 指南笔记</title>
		<link href="http://127.0.0.1/notes/2016/07/13/go%E6%8C%87%E5%8D%97-%E7%AC%94%E8%AE%B0_20160712.html" />
		<updated>2016-07-13T02:30:00+08:00</updated>
		<id>http://127.0.0.1/notes/2016/07/13/go%E6%8C%87%E5%8D%97-%E7%AC%94%E8%AE%B0_20160712.html</id>
		<content type="html"><![CDATA[<h3 id="零值"><strong>零值</strong></h3>
<ul>
  <li>数值类型为 <code class="language-plaintext highlighter-rouge">0</code></li>
  <li>布尔类型为 <code class="language-plaintext highlighter-rouge">false</code></li>
  <li>字符串为 “” (空字符串)</li>
</ul>

<h3 id="常量"><strong>常量</strong></h3>
<ul>
  <li>常量定义与变量类似，只不过使用 <code class="language-plaintext highlighter-rouge">const</code> 关键字</li>
  <li>常量不能用 <code class="language-plaintext highlighter-rouge">:=</code> 语法定义</li>
</ul>

<h3 id="数值常量"><strong>数值常量</strong></h3>
<ul>
  <li>数值常量是高精度的 值 。</li>
  <li>一个未指定类型的常量由上下文来决定其类型。</li>
</ul>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="p">(</span>
  <span class="n">Big</span>   <span class="o">=</span> <span class="m">1</span> <span class="o">&lt;&lt;</span> <span class="m">100</span>
  <span class="n">Small</span> <span class="o">=</span> <span class="n">Big</span> <span class="o">&gt;&gt;</span> <span class="m">99</span>
<span class="p">)</span>
<span class="k">func</span> <span class="n">needInt</span><span class="p">(</span><span class="n">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="m">10</span> <span class="o">+</span> <span class="m">1</span> <span class="p">}</span>
<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">needFloat</span><span class="p">(</span><span class="n">Big</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="switch"><strong>switch</strong></h3>
<ul>
  <li>除非以 <code class="language-plaintext highlighter-rouge">fallthrough</code> 语句结束，否则分支会自动终止。</li>
</ul>

<h3 id="defer"><strong>defer</strong></h3>
<ul>
  <li>defer 语句会延迟函数的执行直到上层函数返回。</li>
  <li>延迟调用的参数会立刻生成，但是在上层函数返回前函数都不会被调用。</li>
  <li>延迟的函数调用被压入一个栈中。当函数返回时， 会按照后进先出的顺序调用被延迟的函数调用。</li>
</ul>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">i</span> <span class="o">:=</span> <span class="m">1</span>
  <span class="k">defer</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"world"</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

  <span class="n">i</span><span class="o">++</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"hello"</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">//hello 2</span>
<span class="c">//world 1</span>
</code></pre></div></div>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"counting"</span><span class="p">)</span>

  <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"done"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="指针">指针</h3>

<ul>
  <li>指针保存了变量的内存地址</li>
  <li>类型 *T 是指向类型 T 的值的指针。其零值是 nil 。</li>
  <li>&amp; 符号会生成一个指向其作用对象的指针。</li>
  <li>符号表示指针指向的底层的值</li>
</ul>

<h3 id="结构体"><strong>结构体</strong></h3>

<ul>
  <li>结构体字段可以通过结构体指针来访问</li>
  <li>指针简介的访问时透明的</li>
  <li>前缀 <code class="language-plaintext highlighter-rouge">&amp;</code> 返回一个指向结构体的指针</li>
</ul>

<h3 id="数组"><strong>数组</strong></h3>

<ul>
  <li>类型 <code class="language-plaintext highlighter-rouge">[n]T</code> 是一个有 <code class="language-plaintext highlighter-rouge">n</code> 个类型为 <code class="language-plaintext highlighter-rouge">T</code> 的值的数组</li>
  <li>数组不能改变大小</li>
</ul>

<h3 id="slice"><strong>slice</strong></h3>

<ul>
  <li>一个 slice 会指向一个序列的值，并且包含了长度信息</li>
  <li><code class="language-plaintext highlighter-rouge">[]T</code> 是一个元素类型为 <code class="language-plaintext highlighter-rouge">T</code> 的 <code class="language-plaintext highlighter-rouge">slice</code></li>
  <li><code class="language-plaintext highlighter-rouge">len(s)</code> 返回 slice s 的长度</li>
  <li>作为变长数组的替代方案，可以管理底层数组的局部或全部</li>
</ul>

<p><strong>对 slice 切片</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">s[lo:hi]</code> 表示从 lo 到 hi-1 的 slice 元素，含开始下标，不包含结束下标</li>
  <li><code class="language-plaintext highlighter-rouge">make</code> 创建 slice,会分配一个全是零值的数组并且返回一个 slice 指向这个数组</li>
  <li>第三个参数是制定容量</li>
  <li>slice 的零值是 nil</li>
  <li>一个 nil 的 slice 的长度和容量是 0。</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>b := make([]int, 0, 5) // len(b)=0, cap(b)=5
</code></pre></div></div>

<h3 id="range"><strong>range</strong></h3>

<p>for 循环的 range 格式可以对 slice 或者 map 进行迭代循环</p>

<h3 id="map"><strong>map</strong></h3>

<p>在 map m 中插入或修改一个元素: <code class="language-plaintext highlighter-rouge">m[key] = elem</code>
获得元素：<code class="language-plaintext highlighter-rouge">elem = m[key]</code>
删除元素：<code class="language-plaintext highlighter-rouge">delete(m, key)</code>
通过双赋值检测某个键存在：<code class="language-plaintext highlighter-rouge">elem, ok = m[key]</code></p>

<h3 id="函数"><strong>函数</strong></h3>

<ul>
  <li>函数值可以作为函数的参数或者返回值</li>
  <li>Go 函数可以是一个闭包</li>
</ul>

<h3 id="方法"><strong>方法</strong></h3>

<p>有两个原因需要使用指针接收者。</p>
<ul>
  <li>首先避免在每个方法调用中拷贝值（如果值类型是大的结构体的话会更有效率）。</li>
  <li>其次，方法可以修改接收者指向的值</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Vertex struct {
  X, Y float64
}

// 使用指针接收者，是为了避免在调用方法中拷贝值，其次是可以修改接受者指向的值
// 因为值类型可能是大的结构体，拷贝的话性能不好
// 如果 v 是一个值（非指针），方法看到的是 Vertex 的副本，并且无法修改原始值
func (v *Vertex) Abs() float64 { 
  return math.Sqrt(v.X*v.X + v.Y*v.Y) 
}

func main() {
  v := &amp;Vertex{3, 4}
  fmt.Println(v.Abs())
}
</code></pre></div></div>

<h3 id="接口"><strong>接口</strong></h3>
<ul>
  <li>接口类型是由一组方法定义的集合。</li>
  <li>接口类型的值可以存放实现这些方法的任何值。</li>
</ul>

<p><strong>Stringers</strong>
Stringer 是一个可以用字符串描述自己的类型。<code class="language-plaintext highlighter-rouge">fmt</code>包 （还有许多其他包）使用这个来进行输出。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Stringer</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">String</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>错误</strong></p>

<p>与 fmt.Stringer 类似， error 类型是一个内建接口：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type error interface {
    Error() string
}
</code></pre></div></div>

<h3 id="goroutine"><strong>Goroutine</strong></h3>

<p>goroutine 是由 Go 运行时环境管理的轻量级线程。</p>

<p><strong>channel</strong></p>
<ul>
  <li>channel 是有类型的管道</li>
  <li>可以用 channel 操作符 &lt;- 对其发送或者接收值。</li>
  <li>默认情况下，在另一端准备好之前，发送和接收都会阻塞。这使得 goroutine 可以在没有明确的锁或竞态变量的情况下进行同步</li>
</ul>

<p><strong>缓冲 channel</strong></p>
<ul>
  <li>channel 可以是 带缓冲的。为 make 提供第二个参数作为缓冲长度来初始化一个缓冲</li>
  <li>向带缓冲的 channel 发送数据的时候，只有在缓冲区满的时候才会阻塞。</li>
  <li>而当缓冲区为空的时候接收操作会阻塞。</li>
</ul>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="m">2</span><span class="p">)</span>
  <span class="n">ch</span> <span class="o">&lt;-</span> <span class="m">1</span>
  <span class="n">ch</span> <span class="o">&lt;-</span> <span class="m">2</span>
  <span class="n">ch</span> <span class="o">&lt;-</span> <span class="m">3</span> <span class="c">//因为缓存区比填满，fatal error: all goroutines are asleep - deadlock!</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="n">ch</span><span class="p">)</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="n">ch</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>range 和 close</strong></p>

<ul>
  <li>发送者可以 close 一个 channel</li>
</ul>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">v</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">ch</span>
</code></pre></div></div>
<ul>
  <li>接收者可以通过赋值语句的第二参数来测试 channel 是否被关闭</li>
  <li>当没有值可以接收并且 channel 已经被关闭，那么取值之后 ok 会被设置为 false</li>
</ul>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">c</span>
</code></pre></div></div>
<ul>
  <li>循环 会不断从 channel 接收值，直到它被关闭</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">注意事项</code></strong></p>
<ul>
  <li>只有发送者才能关闭 channel，而不是接收者</li>
  <li>向一个已经关闭的 channel 发送数据会引起 panic</li>
  <li>channel 与文件不同；通常情况下无需关闭它们</li>
  <li>只有在需要告诉接收者没有更多的数据的时候才有必要进行关闭，例如中断一个 range</li>
</ul>

<p><strong>select</strong></p>
<ul>
  <li>select 语句使得一个 goroutine 在多个通讯操作上等待。</li>
</ul>

]]></content>
	</entry>
	
	<entry>
		<title>《TCP Sockets 编程》读书笔记</title>
		<link href="http://127.0.0.1/notes/2016/03/29/TCP-Sockets-%E7%BC%96%E7%A8%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html" />
		<updated>2016-03-29T17:06:00+08:00</updated>
		<id>http://127.0.0.1/notes/2016/03/29/TCP-Sockets-%E7%BC%96%E7%A8%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html</id>
		<content type="html"><![CDATA[<h2 id="第一章建立套接字">第一章：建立套接字</h2>

<h3 id="11-ruby-的套接字库">1.1 ruby 的套接字库</h3>
<p>socket 库是 ruby 标准库的组成，包含各种用于 TCP 套接字、UDP 套接字的类</p>

<h3 id="12-创建首个套接字">1.2 创建首个套接字</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'socket'</span>
<span class="n">socket</span> <span class="o">=</span> <span class="no">Socket</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">Socket</span><span class="o">::</span><span class="no">AF_INET</span><span class="p">,</span> <span class="no">Socket</span><span class="o">::</span><span class="no">SOCK_STREAM</span><span class="p">)</span>
</code></pre></div></div>
<ul>
  <li>INET 是 internet 的缩写，特别用于指代 IPv4 版本的套接字。</li>
  <li>STREAM 表示用数据流通信，由 TCP 提供。</li>
  <li>DGRAM(datagram 的缩写，数据报),则表示 UDP 套结字</li>
</ul>

<h3 id="13-什么是端点">1.3 什么是端点</h3>

<ul>
  <li>套接字使用 IP 地址将消息指向特定的主机。</li>
  <li>主机由唯一的 IP 地址来标识</li>
</ul>

<h3 id="14-环回地址">1.4 环回地址</h3>

<ul>
  <li>环回接口(loopback interface)。与硬件无关、完全虚拟的接口。发送到环回接口的数据立即会在同一个接口上被接收。</li>
  <li>环回接口对应的主机名是 localhost, 对应的 IP 地址通常是 127.0.0.1，定义在 hosts 文件中</li>
</ul>

<h3 id="15-ipv6">1.5 IPv6</h3>
<ul>
  <li>IPv4 由 4 组数字组成，各自的范围在 0 ~ 255, 每组数字可以用 8 位二进制数字来表示，合计共需 32 位进制，意味着有 2的32次方或 43亿个地址。</li>
  <li>IPv6 用另一个不同的格式，可以拥有天文数字级别的独立 IP 地址。</li>
</ul>

<h3 id="16-端口">1.6 端口</h3>
<p>套接字的 IP 地址和端口号的组合必须是唯一，端口号就是套接字端点的 “分机号”。</p>

<h3 id="17-创建第二个套接字">1.7 创建第二个套接字</h3>

<p><strong>IPv6 域中的套接字</strong>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># ./code/snippets/create_socket_memoized.rb</span>

<span class="nb">require</span> <span class="s1">'socket'</span>
<span class="n">socket</span> <span class="o">=</span> <span class="no">Socket</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:INET6</span><span class="p">,</span> <span class="ss">:STREAM</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="18-系统调用">1.8 系统调用</h3>

<p><code class="language-plaintext highlighter-rouge">Socket.new -&gt; socket(2)</code></p>

<hr />

<h2 id="第二章建立连接">第二章：建立连接</h2>

<ul>
  <li>TCP 在两个端点之间建立连接。端点可以处在同一台主机或不同主机</li>
  <li>套接字必须担任以下角色之一：
    <ol>
      <li>发起者(initiator)</li>
      <li>侦听者(listener)</li>
    </ol>
  </li>
  <li>网络编程中，从事侦听的套接字称为 “服务器”，发起连接的套接字称为 “客户端”</li>
</ul>

<hr />

<h3 id="第三章服务器套接字生命周期">第三章：服务器套接字生命周期</h3>
<p>用于侦听连接而非发起连接，其典型的生命周期如下：</p>

<ol>
  <li>创建</li>
  <li>绑定</li>
  <li>侦听</li>
  <li>接受</li>
  <li>关闭</li>
</ol>

<h3 id="31-服务器绑定">3.1 服务器绑定</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'socket'</span>
<span class="c1"># 首先创建一个新的 TCP 套接字</span>
<span class="n">socket</span> <span class="o">=</span> <span class="no">Socket</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:INET</span><span class="p">,</span> <span class="ss">:STREAM</span><span class="p">)</span>

<span class="c1"># 创建一个 C 结构体来保存用于侦听的地址。</span>
<span class="n">addr</span> <span class="o">=</span> <span class="no">Socket</span><span class="p">.</span><span class="nf">pack_sockaddr_in</span><span class="p">(</span><span class="mi">4481</span><span class="p">,</span> <span class="s1">'0.0.0.0'</span><span class="p">)</span>

<span class="c1">#执行绑定</span>
<span class="n">socket</span><span class="p">.</span><span class="nf">bingd</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span>
</code></pre></div></div>

<p>这个套接字已绑定到本机的 4481 端口，其它套接字不可用此端口，否则会产生异常 <code class="language-plaintext highlighter-rouge">Errno::EADDRINUSE</code></p>

<h3 id="311-该绑定到哪个端口">3.1.1 该绑定到哪个端口</h3>

<ul>
  <li>规则1: 不要使用  0~1024 之间的端口。这些端口是保留给系统使用的。 
http: 80，SMTP: 25，RSYNC: 873，绑定这些端口需要 root 权限。</li>
  <li>规则2：不要使用 49 000 ~ 65 535 之间的端口。
这些是临时(tphemeral)端口。通常是用于临时之需的服务使用。</li>
  <li>除此之外,1025~48 999 的端口使用时一视同仁的。可以参考 <a href="http://www.iana.org/assignments/port-numbers">IANA 的注册端口列表</a>，确保不与其他流行的服务器冲突。</li>
</ul>

<h3 id="312-该绑定到哪个地址">3.1.2 该绑定到哪个地址</h3>

<ul>
  <li>绑定环回地址(127.0.0.1) ，仅限于本地连接使用。无法用于外部连接，只有 localhost 或 127.0.0.1 的连接才会被服务器套接字接受</li>
  <li>绑定 <code class="language-plaintext highlighter-rouge">192.168.0.5</code> ，套接字只侦听此接口，无法用于本地连接</li>
  <li>使用用 0.0.0.0，会侦听所有可用接口、环回地址等</li>
</ul>

<h3 id="32-服务器侦听">3.2 服务器侦听</h3>

<p>创建套接字绑定到端口之后，需要进行侦听.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'socket'</span>

<span class="c1"># 创建套接字并绑定到端口 4481</span>
<span class="n">socket</span> <span class="o">=</span> <span class="no">Socket</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:INET</span><span class="p">,</span> <span class="ss">:STREAM</span><span class="p">)</span>
<span class="n">addr</span> <span class="o">=</span> <span class="no">Socket</span><span class="p">.</span><span class="nf">pack_sockadd_in</span><span class="p">(</span><span class="mi">4481</span><span class="p">,</span> <span class="s1">'0.0.0.0'</span><span class="p">)</span>
<span class="n">socket</span><span class="p">.</span><span class="nf">bind</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span>

<span class="c1">#告诉套接字侦听接入的连接</span>
<span class="n">socket</span><span class="p">.</span><span class="nf">listen</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="321-侦听队列">3.2.1 侦听队列</h3>

<ul>
  <li>listen 方法传递了一个整数类型的参数，表示服务器套接字能容纳的待处理的最大连接数</li>
  <li>待处理的连接列表被称为侦听队列。</li>
  <li>如果客户端连接到达且侦听队列已满，客户端会产生 Errno::ECONNREFUSED</li>
</ul>

<h3 id="322-侦听队列的长度">3.2.2 侦听队列的长度</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Socket::SOMAXCONN</code> 可以获知当前锁允许的最大的侦听队列长度，Mac 上是 128</li>
  <li>需要 root 权限来增加系统级别限制。</li>
  <li>可使用 server.listen(Socket::SOMAXCONN) 将侦听队列长度设置为允许的最大值。</li>
</ul>

<h3 id="33-接受连接">3.3 接受连接</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'socket'</span>
<span class="c1"># 创建套接字并绑定到端口 4481</span>
<span class="n">socket</span> <span class="o">=</span> <span class="no">Socket</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:INET</span><span class="p">,</span> <span class="ss">:STREAM</span><span class="p">)</span>
<span class="n">addr</span> <span class="o">=</span> <span class="no">Socket</span><span class="p">.</span><span class="nf">pack_sockadd_in</span><span class="p">(</span><span class="mi">4481</span><span class="p">,</span> <span class="s1">'0.0.0.0'</span><span class="p">)</span>
<span class="n">socket</span><span class="p">.</span><span class="nf">bind</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span>

<span class="c1">#告诉套接字侦听接入的连接</span>
<span class="n">socket</span><span class="p">.</span><span class="nf">listen</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

<span class="c1">#接受连接</span>
<span class="n">connection</span><span class="p">,</span> <span class="o">-</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="nf">accept</span>
</code></pre></div></div>
<p>用 netcat 发起一个连接, 运行后 nc 和 ruby 程序都会顺利退出</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">echo </span>ohai | nc localhost 4481
</code></pre></div></div>

<h4 id="accept">accept</h4>

<ul>
  <li>accept 调用时阻塞式的，没有接收到新的连接，它会一直阻塞当前线程。</li>
  <li>accept 调用返回一个数组，第一个是建立好的连接，第二个元素是 Addrinfo 对象，该对象描述客户端连接的远程地址</li>
</ul>

<h4 id="addrinfo">Addrinfo</h4>

<ul>
  <li>Addrinfo 类描述了一台主机机器端口号</li>
  <li>有用的方法包括 #ip_address 和 #ip_port</li>
  <li>构建例子：Addrinfo.tcp(‘localhost’, 4481)</li>
</ul>

<h3 id="连接详解">连接详解</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'socket'</span>
<span class="c1"># 创建套接字并绑定到端口 4481</span>
<span class="n">socket</span> <span class="o">=</span> <span class="no">Socket</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:INET</span><span class="p">,</span> <span class="ss">:STREAM</span><span class="p">)</span>
<span class="n">addr</span> <span class="o">=</span> <span class="no">Socket</span><span class="p">.</span><span class="nf">pack_sockadd_in</span><span class="p">(</span><span class="mi">4481</span><span class="p">,</span> <span class="s1">'0.0.0.0'</span><span class="p">)</span>
<span class="n">socket</span><span class="p">.</span><span class="nf">bind</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span>

<span class="c1">#告诉套接字侦听接入的连接</span>
<span class="n">socket</span><span class="p">.</span><span class="nf">listen</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span>

<span class="c1">#接受连接</span>
<span class="n">connection</span><span class="p">,</span> <span class="o">-</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="nf">accept</span>

<span class="nb">print</span> <span class="s1">'Connection class:'</span>
<span class="nb">p</span> <span class="n">connection</span><span class="p">.</span><span class="nf">class</span>

<span class="nb">print</span> <span class="s1">'Server fileno:'</span>
<span class="nb">p</span> <span class="n">server</span><span class="p">.</span><span class="nf">fileno</span>

<span class="nb">print</span> <span class="s1">'Connection fileno:'</span>
<span class="nb">p</span> <span class="n">connection</span><span class="p">.</span><span class="nf">fileno</span>

<span class="nb">print</span> <span class="s1">'Local address:'</span>
<span class="nb">p</span> <span class="n">connection</span><span class="p">.</span><span class="nf">local_address</span>

<span class="nb">print</span> <span class="s1">'Remote address:'</span>
<span class="nb">p</span> <span class="n">connection</span><span class="p">.</span><span class="nf">remote_address</span> <span class="c1"># accept 第二个返回值相同</span>
</code></pre></div></div>

<p>使用 netcat 命令发起连接后会输出：</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Connection</span> <span class="ss">class: </span><span class="no">Socket</span>
<span class="no">Server</span> <span class="ss">fileno: </span><span class="mi">7</span>
<span class="no">Connection</span> <span class="ss">fileno: </span><span class="mi">8</span>
<span class="no">Local</span> <span class="ss">address: </span><span class="c1">#&lt;Addrinfo: 127.0.0.1:4481 TCP&gt;</span>
<span class="no">Remote</span> <span class="ss">address: </span><span class="c1">#&lt;Addrinfo: 127.0.0.1:50488 TCP&gt;</span>
<span class="no">Addrinfo</span><span class="s2">"#&lt;Addrinfo: 127.0.0.1:50488 TCP&gt;"</span>
</code></pre></div></div>
<h4 id="333-连接类">3.3.3 连接类</h4>
<ul>
  <li>连接类是 Socket 表示一个连接就是一个 Socket 的实例</li>
</ul>

<h4 id="334-文件描述符">3.3.4 文件描述符</h4>

<ul>
  <li>fileno(文件描述符编号)是内核用于跟踪当前进程所打开文件的一种方法。</li>
  <li>在 Unix 世界中，所有的一些都被视为文件。包括文件系统中的文件以及管道、套接字和打印机，等等。</li>
  <li>accept 返回了一个不同于服务器套接字的全新 Socket，每个连接都是一个全新的 Socket 对象描述</li>
</ul>

<h4 id="335-连接地址">3.3.5 连接地址</h4>

<ul>
  <li>本地地址：本地主机、本地端口</li>
  <li>远程地址：远程主机、远程端口</li>
  <li>以上 4 个属性的组合必须是唯一的</li>
</ul>

<h4 id="336-accept-循环">3.3.6 accept 循环</h4>
<p>accept 返回一个连接</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'socket'</span>
<span class="c1"># 创建套接字并绑定到端口 4481</span>
<span class="n">socket</span> <span class="o">=</span> <span class="no">Socket</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:INET</span><span class="p">,</span> <span class="ss">:STREAM</span><span class="p">)</span>
<span class="n">addr</span> <span class="o">=</span> <span class="no">Socket</span><span class="p">.</span><span class="nf">pack_sockadd_in</span><span class="p">(</span><span class="mi">4481</span><span class="p">,</span> <span class="s1">'0.0.0.0'</span><span class="p">)</span>
<span class="n">socket</span><span class="p">.</span><span class="nf">bind</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span>

<span class="c1">#告诉套接字侦听接入的连接</span>
<span class="n">socket</span><span class="p">.</span><span class="nf">listen</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span>

<span class="c1">#进入无限循环，接受并处理连接</span>
<span class="kp">loop</span> <span class="k">do</span>
  <span class="c1">#接受连接</span>
  <span class="n">connection</span><span class="p">,</span> <span class="o">-</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="nf">accept</span> <span class="c1"># 返回连接，第二个 - 是远程地址</span>
  <span class="c1"># 处理连接</span>
  <span class="n">connection</span><span class="p">.</span><span class="nf">close</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="34-关闭服务器">3.4 关闭服务器</h3>
<p>服务器接受某个连接并处理完毕，那么最后需要关闭该连接。这样才算完成一个连接的
“创建-处理-关闭” 的生命周期。</p>

<h4 id="341-退出时关闭">3.4.1 退出时关闭</h4>
<p>关闭连接的理由：</p>

<ul>
  <li>资源使用</li>
  <li>打开文件的数量限制</li>
</ul>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">Process.getrlimit(:NOFILE)</code>，获知当前进程所需要打开文件的数量。
返回值是数组，包含软限制(用户配置的设置)和硬限制(系统限制)。
<code class="language-plaintext highlighter-rouge">Process.setrlimit(Process.getrlimit(:NOFILE)[1])</code> 将进程的打开文件限制改为最大值</p>
</blockquote>

<h4 id="342-不同的关闭方式">3.4.2 不同的关闭方式</h4>
<p>套接字允许双向通信(读/写)，实际上可以只关闭其中一个通道。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Socket#close_write</code>  关闭写操作流 (wite stream) 会发送一个EOF到套接字的另一端。</li>
  <li><code class="language-plaintext highlighter-rouge">Socket#close_read</code> 关闭读操作流</li>
  <li><code class="language-plaintext highlighter-rouge">Socket#close_write</code>  <code class="language-plaintext highlighter-rouge">Socket#close_read</code> 方法在底层都利用 <code class="language-plaintext highlighter-rouge">shutdown(2)</code></li>
  <li><code class="language-plaintext highlighter-rouge">Socket#close</code> 关闭套接字实例并回收所用资源，但不会关闭副本，副本所占用资源也不会被回收。</li>
  <li><code class="language-plaintext highlighter-rouge">Socket#shutdown</code>  会关闭当前套接字及其副本上的通信，但不会回收所用资源。每个套接字都需要使用 close 结束它的生命周期。</li>
  <li><code class="language-plaintext highlighter-rouge">Socket#dup</code> 创建文件描述符副本</li>
  <li><code class="language-plaintext highlighter-rouge">Process.fork</code> 可以获得一个文件描述符副本，该方法创建了一个全新的进程(仅在 Unix 环境中)，这个进程和当前进程一模一样，除了拥有当前进程在内存中的所有内容外，新进程还通过 <code class="language-plaintext highlighter-rouge">dup</code> 获得了所有已打开的文件描述符的副本</li>
</ul>

<h3 id="35-ruby-包装器">3.5 Ruby 包装器</h3>

<h4 id="351-服务器创建">3.5.1 服务器创建</h4>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'socket'</span>
<span class="n">server</span> <span class="o">=</span> <span class="no">TCPServer</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">4481</span><span class="p">)</span>
</code></pre></div></div>
<p>简便的服务器创建方式</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">TCPServer#accept</code> 值返回连接</li>
  <li><code class="language-plaintext highlighter-rouge">TCPServer</code> 默认的侦听队列长度是 5, 可以用 <code class="language-plaintext highlighter-rouge">TCPSrver#listen</code> 修改侦听队列长度</li>
</ul>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'socket'</span>
<span class="n">servers</span> <span class="o">=</span> <span class="no">Socket</span><span class="p">.</span><span class="nf">tcp_server_sockets</span><span class="p">(</span><span class="mi">4481</span><span class="p">)</span>
</code></pre></div></div>
<p>以上代码同时返回两个套接字，IPv4 和 IPv6</p>

<h4 id="352-连接处理">3.5.2 连接处理</h4>

<p><code class="language-plaintext highlighter-rouge">accept_loop</code> 无限循环，并且还可以接受多个侦听套接字</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'socket'</span>

<span class="c1"># 创建侦听套接字</span>
<span class="n">server</span> <span class="o">=</span> <span class="no">TCPServer</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">4481</span><span class="p">)</span>

<span class="c1"># 进入无线循环接手并处理连接</span>
<span class="no">Socket</span><span class="p">.</span><span class="nf">accept_loop</span><span class="p">(</span><span class="n">server</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">connection</span><span class="o">|</span>
  <span class="c1"># 处理连接</span>
  <span class="n">connection</span><span class="p">.</span><span class="nf">close</span>
<span class="k">end</span>
</code></pre></div></div>

<p>多个套接字处理</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 创建侦听套接字
servers = Socket.tcp_server_sockets(4481) # 创建两个套接字 IPv4 和 IPv6 

# 进入无线循环接手并处理连接
Socket.accept_loop(servers) do |connection|
  # 处理连接
  connection.close
end
</code></pre></div></div>

<h4 id="353-合而为一">3.5.3 合而为一</h4>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'socket'</span>

<span class="no">Socket</span><span class="p">.</span><span class="nf">tcp_server_loop</span><span class="p">(</span><span class="mi">4481</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">connection</span><span class="o">|</span>
  <span class="c1"># 处理连接</span>
  <span class="n">connection</span><span class="p">.</span><span class="nf">close</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="36-系统调用">3.6 系统调用</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Socket#bind -&gt; <span class="nb">bind</span><span class="o">(</span>2<span class="o">)</span>
Socket#listen -&gt; listen<span class="o">(</span>2<span class="o">)</span>
Socket#accept -&gt; accept<span class="o">(</span>2<span class="o">)</span>
Socket#local_address -&gt; getsockname<span class="o">(</span>2<span class="o">)</span>
Socket#remote_address -&gt; getpeername<span class="o">(</span>2<span class="o">)</span>
Socket#close -&gt; close<span class="o">(</span>2<span class="o">)</span>
Socket#close_write -&gt; shutdown<span class="o">(</span>2<span class="o">)</span>
Socket#shutdown -&gt; shutdown<span class="o">(</span>2<span class="o">)</span>
</code></pre></div></div>

<hr />

<h2 id="第四章客户端生命周期">第四章：客户端生命周期</h2>

<p><strong>网络连接两部分：</strong></p>

<ul>
  <li>服务器负责侦听及处理接入的连接</li>
  <li>客户端负责向服务器发起连接</li>
</ul>

<p><strong>客户端的生命周期</strong></p>

<ul>
  <li>(1) 创建</li>
  <li>(2)  绑定</li>
  <li>(3)  连接</li>
  <li>(4)  关闭</li>
</ul>

<h3 id="41-客户端绑定">4.1 客户端绑定</h3>

<ul>
  <li>建议：不要给客户端绑定端口</li>
  <li>客户端不需要调用 bind，他会从临时端口范围内获得一个随机端口号</li>
</ul>

<h3 id="42-客户端连接">4.2 客户端连接</h3>

<ul>
  <li>connect 调用默认有一段较长时间的超时</li>
  <li>出现超时，会产生一个 <code class="language-plaintext highlighter-rouge">Errno::ETIMEOUT</code> 异常</li>
</ul>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'socket'</span>
<span class="n">socket</span> <span class="o">=</span> <span class="no">Socket</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:INET</span><span class="p">,</span> <span class="ss">:STREAM</span><span class="p">)</span>

<span class="c1"># 发起到 baidu.com 端口 80 的连接</span>
<span class="n">remote_addr</span> <span class="o">=</span> <span class="no">Socket</span><span class="p">.</span><span class="nf">pack_sockaddr_in</span><span class="p">(</span><span class="mi">80</span><span class="p">,</span> <span class="s1">'baidu.com'</span><span class="p">)</span>
<span class="n">socket</span><span class="p">.</span><span class="nf">connect</span><span class="p">(</span><span class="n">remote_addr</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="43-ruby-包装器">4.3 ruby 包装器</h3>

<p>客户端创建简写版本：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'socket'</span>
<span class="n">socket</span> <span class="o">=</span> <span class="no">TCPSocket</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s1">'baidu.com'</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span>
</code></pre></div></div>

<p>代码块：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'socket'</span>

<span class="no">Socket</span><span class="p">.</span><span class="nf">tcp</span><span class="p">(</span><span class="s1">'baidu.com'</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">connection</span><span class="o">|</span>
  <span class="n">connection</span><span class="p">.</span><span class="nf">write</span> <span class="s2">"GET / HTTP/1.1</span><span class="se">\r\n</span><span class="s2">"</span>
  <span class="n">connection</span><span class="p">.</span><span class="nf">close</span>
<span class="k">end</span>
</code></pre></div></div>

<p>省略代码块:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'socket'</span>

<span class="n">client</span> <span class="o">=</span> <span class="no">Socket</span><span class="p">.</span><span class="nf">tcp</span><span class="p">(</span><span class="s1">'baidu.com'</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="44-系统调用">4.4 系统调用</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Socket#bind -&gt; <span class="nb">bind</span><span class="o">(</span>2<span class="o">)</span>
Socket#connect -&gt; connect<span class="o">(</span>2<span class="o">)</span>
</code></pre></div></div>

<hr />

<h2 id="第五章交换数据">第五章：交换数据</h2>

<ul>
  <li>TCP 连接如同遗传连接了本地套接字和远程套接字的管子，可以通过管子发送数据</li>
  <li>所有的数据都被编码成 TCP/IP 分组</li>
</ul>

<h3 id="流">流</h3>

<ul>
  <li>TCP 是一个基于流的协议</li>
  <li>创建套接字，需要传入 :STREAM 选项</li>
  <li>TCP 连接提供了一个不间断的、有序的通信流。</li>
</ul>

<p>演示伪代码：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 下面的代码会在网络上发送 3 份数据，一次一份</span>
<span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'a'</span><span class="p">,</span><span class="s1">'b'</span><span class="p">,</span><span class="s1">'c'</span><span class="p">]</span>

<span class="k">for</span> <span class="n">piece</span> <span class="k">in</span> <span class="n">data</span>
  <span class="n">write_to_connection</span><span class="p">(</span><span class="n">piece</span><span class="p">)</span>
<span class="k">end</span>

<span class="c1"># 下面的代码在一次做作中读取全部数据</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">read_from_connection</span> <span class="c1">#=&gt; ['a','b','c']</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">流并没有消息边界的概念</code>：</p>

<ul>
  <li>客户端分别发送 3 份数据，服务器读取，是将其作为一份数据来接手，并不知道客户端是分批发送的数据</li>
</ul>

<hr />

<h2 id="第六章套接字读取">第六章：套接字读取</h2>

<p>学习如何在套接字上传送数据</p>

<h3 id="61-简单的读操作">6.1 简单的读操作</h3>

<ul>
  <li>Ruby 的各种套接字以及 File 在 IO 中都有一个共同的父类。</li>
  <li>Ruby 中所有的 IO 对象(套接字、管道、文件…)都有一套通用的接口，支持 read、write、flush 等方法</li>
  <li>抽象源自操作系统核心本身，底层的 <code class="language-plaintext highlighter-rouge">read(2)</code> <code class="language-plaintext highlighter-rouge">write(2)</code> 等系统调用都可以作用域文件、套接字、管道等之上</li>
</ul>

<p>服务端：</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'socket'</span>

<span class="no">Socket</span><span class="p">.</span><span class="nf">tcp_server_loop</span><span class="p">(</span><span class="mi">4481</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">connection</span><span class="o">|</span>
  <span class="c1"># 从连接中读取数据最简单的方法</span>
  <span class="nb">puts</span> <span class="n">connection</span><span class="p">.</span><span class="nf">read</span>

  <span class="c1"># 完成读取之后关闭连接，让客户端知道不用再等待数据返回</span>
  <span class="n">connection</span><span class="p">.</span><span class="nf">close</span>
<span class="k">end</span>
</code></pre></div></div>

<p>客户端调用：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo </span>ohi | nc lcoalhost 4481
</code></pre></div></div>

<h3 id="62-没那么简单">6.2 没那么简单</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">EOF</code>:  end-of-file, 表示数据结尾</li>
  <li>服务器的 read 会一直阻塞，直到客户端发完数据为止</li>
</ul>

<p>客户端：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nb">tail</span> <span class="nt">-f</span> /var/log/system.log | nc <span class="nt">-v</span> localhost 4481
</code></pre></div></div>

<h3 id="63-读取长度">6.3 读取长度</h3>
<ul>
  <li>解决阻塞的办法是，指定最小的读取长度，告诉服务器读取(read)特定的数据量</li>
</ul>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'socket'</span>
<span class="n">one_kb</span> <span class="o">=</span> <span class="mi">1024</span> <span class="c1"># 字节数</span>

<span class="no">Socket</span><span class="p">.</span><span class="nf">tcp_server_loop</span><span class="p">(</span><span class="mi">4481</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">connection</span><span class="o">|</span>

  <span class="c1"># 以 1kb 为单位进行读取</span>
  <span class="k">while</span> <span class="n">data</span> <span class="o">=</span> <span class="n">connection</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="n">one_kb</span><span class="p">)</span> <span class="k">do</span> 
    <span class="nb">puts</span> <span class="n">data</span>
  <span class="k">end</span>

  <span class="c1"># 完成读取之后关闭连接，让客户端知道不用再等待数据返回</span>
  <span class="n">connection</span><span class="p">.</span><span class="nf">close</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="64-阻塞的本质">6.4 阻塞的本质</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">read</code> 调用会一直阻塞，直到获取了完整长度的数据为止</li>
</ul>

<p>解决 <code class="language-plaintext highlighter-rouge">read</code> 死锁的办法：</p>

<ol>
  <li>客户端发完 500B 后再发送一个 ·EOF·</li>
  <li>服务器采用部分读取 (partial read) 的方式</li>
</ol>

<h3 id="65-eof-事件">6.5 EOF 事件</h3>

<ul>
  <li>当在连接上调用 <code class="language-plaintext highlighter-rouge">read</code> 并接收到 EOF 事件时，就可以确定不会再有数据，可以停止读取了。</li>
  <li><code class="language-plaintext highlighter-rouge">EOF</code> 代表 <code class="language-plaintext highlighter-rouge">end of file</code>(文件结束)</li>
  <li><code class="language-plaintext highlighter-rouge">EOF</code> 并不代表某种字符序列，它更新一个状态事件(state even)</li>
  <li>如果一个套接字没有数据可写，可以调用 <code class="language-plaintext highlighter-rouge">shutdown</code> 或 <code class="language-plaintext highlighter-rouge">close</code> 表示不再需要写入数据。这发送一个 <code class="language-plaintext highlighter-rouge">EOF</code> 事件给另一端进行读操作的进程</li>
  <li>调用 <code class="language-plaintext highlighter-rouge">File#read</code> 时(同 <code class="language-plaintext highlighter-rouge">Socket#read</code> 的行为方式类似)，会一直进行数据读取，直到无数据为止。一旦读完文件，会受到一个 <code class="language-plaintext highlighter-rouge">EOF</code> 事件并返回已读取到的数据</li>
</ul>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># ./code/snippets/read_with_length.rb</span>

<span class="nb">require</span> <span class="s1">'socket'</span>
<span class="n">one_hundred_kb</span> <span class="o">=</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">100</span> <span class="c1"># 字节数</span>

<span class="no">Socket</span><span class="p">.</span><span class="nf">tcp_server_loop</span><span class="p">(</span><span class="mi">4481</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">connection</span><span class="o">|</span>
  <span class="k">begin</span>
    <span class="c1"># 以 1kb 为单位进行读取</span>
    <span class="k">while</span> <span class="n">data</span> <span class="o">=</span> <span class="n">connection</span><span class="p">.</span><span class="nf">readpartial</span><span class="p">(</span><span class="n">one_hundred_kb</span><span class="p">)</span> <span class="k">do</span>
        <span class="nb">puts</span> <span class="n">data</span>
      <span class="k">end</span>
    <span class="k">rescue</span> <span class="no">EOFError</span>
    <span class="k">end</span>

    <span class="c1"># 完成读取之后关闭连接，让客户端知道不用再等待数据返回</span>
    <span class="n">connection</span><span class="p">.</span><span class="nf">close</span>
  <span class="k">end</span>

</code></pre></div></div>

<p>客户端连接：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># ./code/snippets/write_with_eof.rb</span>

<span class="nb">require</span> <span class="s1">'socket'</span>
<span class="n">client</span> <span class="o">=</span> <span class="no">TCPSocket</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s1">'localhost'</span><span class="p">,</span> <span class="mi">4481</span><span class="p">)</span>
<span class="n">client</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="s1">'gekko'</span><span class="p">)</span>
<span class="n">client</span><span class="p">.</span><span class="nf">close</span>
</code></pre></div></div>

<h3 id="66-部分读取">6.6 部分读取</h3>

<ul>
  <li>调用 <code class="language-plaintext highlighter-rouge">readpartial</code> 不会阻塞，而是立即返回可用数据</li>
  <li><code class="language-plaintext highlighter-rouge">readpartial</code> 必须传递一个整数作为参数，来指定最大的长度</li>
  <li><code class="language-plaintext highlighter-rouge">readpartial</code> 最多读取到指定长度。如果指明 1kb 数据，但客户端发送了 500B，并不会阻塞，会立即将读到的数据返回</li>
  <li>当接收到 <code class="language-plaintext highlighter-rouge">EOF</code> 时 <code class="language-plaintext highlighter-rouge">read</code> 仅仅是返回， 而 <code class="language-plaintext highlighter-rouge">readpartial</code> 则会产生一个 <code class="language-plaintext highlighter-rouge">EOFError</code> 异常</li>
</ul>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># ./code/snippets/readpartial_with_length.rb</span>

<span class="nb">require</span> <span class="s1">'socket'</span>
<span class="n">one_hundred_kb</span> <span class="o">=</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">100</span> <span class="c1"># 字节数</span>

<span class="no">Socket</span><span class="p">.</span><span class="nf">tcp_server_loop</span><span class="p">(</span><span class="mi">4481</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">connection</span><span class="o">|</span>
  <span class="k">begin</span>
    <span class="c1"># 以 1kb 为单位进行读取</span>
    <span class="k">while</span> <span class="n">data</span> <span class="o">=</span> <span class="n">connection</span><span class="p">.</span><span class="nf">readpartial</span><span class="p">(</span><span class="n">one_hundred_kb</span><span class="p">)</span> <span class="k">do</span>
        <span class="nb">puts</span> <span class="n">data</span>
      <span class="k">end</span>
    <span class="k">rescue</span> <span class="no">EOFError</span>
    <span class="k">end</span>

    <span class="c1"># 完成读取之后关闭连接，让客户端知道不用再等待数据返回</span>
    <span class="n">connection</span><span class="p">.</span><span class="nf">close</span>
  <span class="k">end</span>

</code></pre></div></div>

<h3 id="67-系统调用">6.7 系统调用</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Socket#read -&gt; <span class="nb">read</span><span class="o">(</span>2<span class="o">)</span>,行为类似 fread<span class="o">(</span>3<span class="o">)</span>
Socket#readpartial -&gt; <span class="nb">read</span><span class="o">(</span>2<span class="o">)</span>
</code></pre></div></div>

<hr />

<h2 id="第七章套接字写操作">第七章：套接字写操作</h2>

<ul>
  <li>套接字写入数据，需要调用 <code class="language-plaintext highlighter-rouge">write</code> 方法</li>
  <li>系统调用: <code class="language-plaintext highlighter-rouge">Socket#write</code> -&gt; <code class="language-plaintext highlighter-rouge">write(2)</code></li>
</ul>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'socket'</span>

<span class="no">Socket</span><span class="p">.</span><span class="nf">tcp_server_loop</span><span class="p">(</span><span class="mi">4481</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">connection</span><span class="o">|</span>

  <span class="c1"># 向连接中写入数据的最简单的方法</span>
  <span class="n">connection</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="s1">'Welcome!'</span><span class="p">)</span>
  <span class="n">connection</span><span class="p">.</span><span class="nf">close</span>
<span class="k">end</span>
</code></pre></div></div>

<hr />

<h2 id="第八章缓冲">第八章：缓冲</h2>

<h3 id="81-写缓冲">8.1 写缓冲</h3>

<ul>
  <li>调用 <code class="language-plaintext highlighter-rouge">write</code> 并返回，不代表数据已通过网络发送并被客户端套接字接收</li>
  <li>调用 <code class="language-plaintext highlighter-rouge">write</code> 并返回，只表明已将数据提交给了 <code class="language-plaintext highlighter-rouge">Ruby</code> 的 <code class="language-plaintext highlighter-rouge">IO</code> 系统和底层的操作系统内核</li>
  <li>在应用程序代码和实际的网络硬件之间至少还存在一个缓冲层</li>
  <li>TCP 套接字morning将 sync 设置为 true, 跳过了 ruby 的内部缓冲</li>
  <li>IO 缓冲是为了更好的性能</li>
</ul>

<h3 id="82-读写入多少数据">8.2 读写入多少数据</h3>

<ul>
  <li>因为有缓冲区，我们可以一次写入所有的数据，由内核决定如何对数据进行分割或合并来调节性能</li>
  <li>如果数据量很大的 write，可以将自己将数据分割，避免全部载入内存中</li>
</ul>

<h3 id="83-读缓冲">8.3 读缓冲</h3>

<ul>
  <li>读操作同样会被缓冲</li>
  <li>用 <code class="language-plaintext highlighter-rouge">read</code> 读取指定长度的数据，ruby 实际会接收大于制定长度的数据, ruby 多读的数据会被存储在 ruby 内部的读缓冲区</li>
  <li>下次调用 <code class="language-plaintext highlighter-rouge">read</code>,ruby 会查看内部缓冲区数据，然后再通过内核请求更多的数据</li>
</ul>

<h3 id="84-该读取多少数据">8.4 该读取多少数据</h3>

<ul>
  <li>TCP 提供的是数据流，无法得知发送方到底发送了多少数据，读取长度只能靠猜测</li>
  <li>指定读取长度时，内核会分配一定的内存</li>
  <li>指定读取长度太大，会浪费内存资源；指定长度太小，会有大量系统调用开销</li>
  <li>Mongrel、Unicorn、Puma、Passenger 以及 Net::HTTP，采 <code class="language-plaintext highlighter-rouge">readpartial(1024*16)</code> 16KB 作为读取长度</li>
  <li><code class="language-plaintext highlighter-rouge">redis-rb</code> 使用 1KB 作为读取长度</li>
</ul>

<hr />

<h2 id="第-10-章套接字选项">第 10 章：套接字选项</h2>

<h3 id="101-so_type">10.1 SO_TYPE</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'socket'</span>
<span class="n">socket</span> <span class="o">=</span> <span class="no">TCPSocket</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s1">'google.com'</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span>

<span class="c1"># 获得一个描述套接字类型的 Socket::Option 实例</span>
<span class="n">opt</span> <span class="o">=</span> <span class="n">socket</span><span class="p">.</span><span class="nf">getsockopt</span><span class="p">(</span><span class="no">Socket</span><span class="o">::</span><span class="no">SOL_SOCKET</span><span class="p">,</span> <span class="no">Socket</span><span class="o">::</span><span class="no">SO_TYPE</span><span class="p">)</span>

<span class="c1"># 将描述该选项的整数值同存储在 Socket::SOCK_STREAM 中的整数值进行比较</span>
<span class="nb">puts</span> <span class="n">opt</span><span class="p">.</span><span class="nf">int</span> <span class="o">==</span> <span class="no">Socket</span><span class="o">::</span><span class="no">SOCK_STREAM</span> <span class="c1">#=&gt; true</span>
<span class="nb">puts</span> <span class="n">opt</span><span class="p">.</span><span class="nf">int</span> <span class="o">==</span> <span class="no">Socket</span><span class="o">::</span><span class="no">SOCK_DGRAM</span> <span class="c1">#=&gt; false</span>
</code></pre></div></div>

<p>简便方式：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'socket'</span>
<span class="n">socket</span> <span class="o">=</span> <span class="no">TCPSocket</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s1">'google.com'</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span>

<span class="c1"># 使用符号名,而不是常量</span>
<span class="n">opt</span> <span class="o">=</span> <span class="n">socket</span><span class="p">.</span><span class="nf">getsockopt</span><span class="p">(</span><span class="ss">:SOCKET</span><span class="p">,</span> <span class="ss">:TYPE</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="102-so_reuse_addr">10.2 SO_REUSE_ADDR</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">SO_REUSE_ADDR</code> 选项告诉内核：如果服务器当前处于 TCP 的 <code class="language-plaintext highlighter-rouge">TIME_WAIT</code> 状态，即便另一个套接字要绑定(<code class="language-plaintext highlighter-rouge">bind</code>) 到服务器目前所使用的本地地址也无妨.</li>
  <li>TCPServer.new、Socket.tcp_server_loop 及其类似的方法默认都打开了此选项</li>
</ul>

<p>示例代码：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'socket'</span>
<span class="n">server</span> <span class="o">=</span> <span class="no">TCPServer</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s1">'localhost'</span><span class="p">,</span> <span class="mi">4481</span><span class="p">)</span>
<span class="n">server</span><span class="p">.</span><span class="nf">setsockopt</span><span class="p">(</span><span class="ss">:SOCKET</span><span class="p">,</span> <span class="ss">:REUSEADDR</span><span class="p">,</span> <span class="kp">true</span><span class="p">)</span>

<span class="n">server</span><span class="p">.</span><span class="nf">getsockopt</span><span class="p">(</span><span class="ss">:SOCKET</span><span class="p">,</span> <span class="ss">:REUSEADDR</span><span class="p">)</span> <span class="c1">#=&gt; true</span>
</code></pre></div></div>

<h3 id="103-系统调用">10.3 系统调用</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Socket#setsockopt -&gt; setsockopt<span class="o">(</span>2<span class="o">)</span>
Socket#getsockopt -&gt; getsockopt<span class="o">(</span>2<span class="o">)</span>
</code></pre></div></div>

<hr />

<h2 id="第11章非阻塞式-io">第11章：非阻塞式 IO</h2>

<h3 id="111-非阻塞式读操作">11.1 非阻塞式读操作</h3>

<p><strong>两种阻塞的读操作</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">read</code> 会一直保持阻塞，直到接收到 <code class="language-plaintext highlighter-rouge">EOF</code> 或是获得指定的最小字节数为止</li>
  <li><code class="language-plaintext highlighter-rouge">readpartial</code> 会立即返回所有的可用数据，但如果没有数据可用，那么 <code class="language-plaintext highlighter-rouge">readpartial</code>仍会陷入阻塞</li>
</ul>

<p>**<code class="language-plaintext highlighter-rouge">Socket#read_nonblock</code> **:</p>

<ul>
  <li>非阻塞读操作，需要指定整数值，作为读取的最大字节数</li>
  <li>如果可用数据小于最大字节数，则返回可用数据</li>
  <li>没有数据可读，<code class="language-plaintext highlighter-rouge">read_nonblock</code> 调用仍然会立即返回，并产生一个 <code class="language-plaintext highlighter-rouge">Errno::EAGAIN</code>异常</li>
  <li><code class="language-plaintext highlighter-rouge">Errno::EAGAIN</code>: 文件被标记用于非阻塞式 IO，无数据可读</li>
</ul>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">read_nonblock</code> 方法首先检查 <code class="language-plaintext highlighter-rouge">ruby</code> 的内部缓冲区中是否还有未处理的数据，如果有，则立即返回
   <code class="language-plaintext highlighter-rouge">read_nonblock</code> 会询问内核是否有其他可用的数据可供 <code class="language-plaintext highlighter-rouge">select(2)</code>  读取,如果有，不管这些数据是在内核缓冲区还是网络中，他们都会被读取并返回
  其他情况都会使 <code class="language-plaintext highlighter-rouge">read(2)</code> 阻塞并在 <code class="language-plaintext highlighter-rouge">read_nonblock</code> 中引发异常</p>
</blockquote>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'socket'</span>

<span class="no">Socket</span><span class="p">.</span><span class="nf">tcp_server_loop</span><span class="p">(</span><span class="mi">4481</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">connection</span><span class="o">|</span>
  <span class="k">begin</span>
    <span class="nb">puts</span> <span class="n">connection</span><span class="p">.</span><span class="nf">read_nonblock</span><span class="p">(</span><span class="mi">4096</span><span class="p">)</span>
  <span class="k">rescue</span> <span class="no">Errno</span><span class="o">::</span><span class="no">EAGAIN</span> <span class="o">=&gt;</span> <span class="n">e</span>
    <span class="no">IO</span><span class="p">.</span><span class="nf">select</span><span class="p">([</span><span class="n">connection</span><span class="p">])</span>
    <span class="k">retry</span>
  <span class="k">rescue</span> <span class="no">EOFError</span>
    <span class="k">break</span>
  <span class="k">end</span>

  <span class="n">connection</span><span class="p">.</span><span class="nf">close</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="112-非阻塞式写操作">11.2 非阻塞式写操作</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">write_nonblock</code> 会在出现阻塞的时候，返回部分写入的结果</li>
  <li><code class="language-plaintext highlighter-rouge">write_nonblock</code> 的行为和系统调用 <code class="language-plaintext highlighter-rouge">write(2)</code>一样， 尽可能多的写入数据并返回写入的数量</li>
  <li><code class="language-plaintext highlighter-rouge">write</code> 和 <code class="language-plaintext highlighter-rouge">write_nonblock</code> 不同，<code class="language-plaintext highlighter-rouge">write</code> 会多次调用 <code class="language-plaintext highlighter-rouge">write(2)</code> 写入所有请求的数据</li>
  <li><code class="language-plaintext highlighter-rouge">write_nonblock</code> 如果遇到阻塞会得到一个 <code class="language-plaintext highlighter-rouge">Errno::EAGAIN</code> 异常</li>
</ul>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">.</span><span class="nf">/</span><span class="n">code</span><span class="o">/</span><span class="n">snippets</span><span class="o">/</span><span class="n">write_nonblock</span><span class="p">.</span><span class="nf">rb</span>
<span class="nb">require</span> <span class="s1">'socket'</span>

<span class="n">client</span> <span class="o">=</span> <span class="no">TCPSocket</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s1">'localhost'</span><span class="p">,</span> <span class="mi">4481</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">=</span> <span class="s1">'Lorem ipsum'</span> <span class="o">*</span> <span class="mi">100_000</span>

<span class="n">written</span> <span class="o">=</span> <span class="n">client</span><span class="p">.</span><span class="nf">write_nonblock</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
<span class="nb">puts</span> <span class="n">written</span> <span class="o">&lt;</span> <span class="n">payload</span><span class="p">.</span><span class="nf">size</span> 
</code></pre></div></div>

<p>非阻塞，多次写入：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">.</span><span class="nf">/</span><span class="n">code</span><span class="o">/</span><span class="n">snippets</span><span class="o">/</span><span class="n">retry_partial_write</span><span class="p">.</span><span class="nf">rb</span>

<span class="nb">require</span> <span class="s1">'socket'</span>

<span class="n">client</span> <span class="o">=</span> <span class="no">TCPSocket</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s1">'localhost'</span><span class="p">,</span> <span class="mi">4481</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">=</span> <span class="s1">'Lorem ipsum'</span> <span class="o">*</span> <span class="mi">100_000</span>

<span class="k">begin</span>
  <span class="kp">loop</span> <span class="k">do</span>
    <span class="n">bytes</span> <span class="o">=</span> <span class="n">client</span><span class="p">.</span><span class="nf">write_nonblock</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>

    <span class="k">break</span> <span class="k">if</span> <span class="n">bytes</span> <span class="o">&gt;=</span> <span class="n">payload</span><span class="p">.</span><span class="nf">size</span>
    <span class="nb">puts</span> <span class="s2">"----</span><span class="si">#{</span><span class="n">bytes</span><span class="si">}</span><span class="s2">"</span>
    <span class="n">payload</span><span class="p">.</span><span class="nf">slice!</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">bytes</span><span class="p">)</span> <span class="c1"># 删除已经写入的数据</span>
    <span class="no">IO</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="kp">nil</span><span class="p">,</span> <span class="p">[</span><span class="n">client</span><span class="p">])</span>
  <span class="k">end</span>

<span class="k">rescue</span> <span class="no">Errno</span><span class="o">::</span><span class="no">EAGAIN</span>
  <span class="no">IO</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="kp">nil</span><span class="p">,</span> <span class="p">[</span><span class="n">client</span><span class="p">])</span>
  <span class="k">retry</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="113-非拥塞式接收">11.3 非拥塞式接收</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">accept</code> 只是从侦听队列中弹出一个连接</li>
  <li><code class="language-plaintext highlighter-rouge">accept_nonblock</code> 在侦听队列为空时不会阻塞，只是产生一个 <code class="language-plaintext highlighter-rouge">Errno::EAGAIN</code></li>
</ul>

<h3 id="114-非拥塞式连接">11.4 非拥塞式连接</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">connect_nonblock</code> 不能立即发起到远程主机的连接，他会在后台继续执行操作并产生 <code class="language-plaintext highlighter-rouge">Errno::EINPROGRESS</code></li>
</ul>

<hr />

<h2 id="第-12-章连接复用">第 12 章：连接复用</h2>

<ul>
  <li>连接复用指同时处理多个活动套接字，不是并行处理，无关多线程</li>
</ul>

<p>示例代码：<code class="language-plaintext highlighter-rouge">./code/snippets/native_multiplexing.rb</code></p>

<h2 id="121-select2">12.1 select(2)</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">IO.select</code> 的作用是接手若干个 <code class="language-plaintext highlighter-rouge">IO</code> 对象，告知哪个可以进行读写</li>
</ul>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">#</span> <span class="n">snippets</span><span class="o">/</span><span class="n">select_returns</span><span class="o">.</span><span class="n">rb</span>
<span class="n">for_reading</span> <span class="o">=</span> <span class="p">[</span><span class="o">&lt;</span><span class="n">TCPSocket</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">TCPSocket</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">TCPSocket</span><span class="o">&gt;</span><span class="p">]</span>
<span class="n">for_writing</span> <span class="o">=</span> <span class="p">[</span><span class="o">&lt;</span><span class="n">TCPSocket</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">TCPSocket</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">TCPSocket</span><span class="o">&gt;</span><span class="p">]</span>

<span class="n">ready</span> <span class="o">=</span> <span class="n">IO</span><span class="o">.</span><span class="k">select</span><span class="p">(</span><span class="n">for_reading</span><span class="p">,</span> <span class="n">for_writing</span><span class="p">,</span> <span class="n">for_writing</span><span class="p">)</span>

<span class="err">#</span> <span class="n">对于每个座位参数传入的数组均会返回一个数组</span>
<span class="err">#</span> <span class="n">在这里</span><span class="err">，</span> <span class="n">for_writing</span> <span class="n">中没有连接可写</span><span class="err">，</span><span class="n">for_reading</span> <span class="n">中有一个连接可读</span>
<span class="n">p</span> <span class="n">ready</span> <span class="err">#</span><span class="o">=&gt;</span> <span class="p">[[</span><span class="o">&lt;</span><span class="n">TCPSocket</span><span class="o">&gt;</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[]]</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">IO.select</code> 可以使用 3 个数组作为参数：
    <ul>
      <li>第一个参数是希望从中进行读取的 IO 对象数组</li>
      <li>第二个参数是希望进行写入的 IO 对象数组</li>
      <li>第三个是在异常条件下使用的 IO 对象数组，可以被忽略</li>
      <li><code class="language-plaintext highlighter-rouge">IO.select</code>  返回一个包含了3个元素的嵌套数组，分别对应它的参数列表</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">IO.select</code> 会阻塞，是一个同步方法调用</li>
  <li><code class="language-plaintext highlighter-rouge">IO.select</code> 还有第四个参数，一个以秒为单位的超时值，可以避免 <code class="language-plaintext highlighter-rouge">IO.select</code> 永久的阻塞下去， 如果超时会返回 <code class="language-plaintext highlighter-rouge">nil</code></li>
  <li>可以传递纯 ruby 对象给 <code class="language-plaintext highlighter-rouge">IO.select</code> ，只要它们实现了 <code class="language-plaintext highlighter-rouge">to_io</code> 方法并返回一个 IO 对象</li>
</ul>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">#</span> <span class="n">snippets</span><span class="o">/</span><span class="n">select_timeout</span><span class="o">.</span><span class="n">rb</span>
<span class="n">for_reading</span> <span class="o">=</span> <span class="p">[</span><span class="o">&lt;</span><span class="n">TCPSocket</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">TCPSocket</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">TCPSocket</span><span class="o">&gt;</span><span class="p">]</span>
<span class="n">for_writing</span> <span class="o">=</span> <span class="p">[</span><span class="o">&lt;</span><span class="n">TCPSocket</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">TCPSocket</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">TCPSocket</span><span class="o">&gt;</span><span class="p">]</span>

<span class="n">timeout</span> <span class="o">=</span> <span class="m">10</span>
<span class="n">ready</span> <span class="o">=</span> <span class="n">IO</span><span class="o">.</span><span class="k">select</span><span class="p">(</span><span class="n">for_reading</span><span class="p">,</span> <span class="n">for_writing</span><span class="p">,</span> <span class="n">for_writing</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span>

<span class="err">#</span> <span class="n">在这里</span> <span class="s">`IO.select`</span> <span class="n">在</span> <span class="m">10</span> <span class="n">秒钟内没有检测到任何状态的改变</span>
<span class="err">#</span> <span class="n">因此返回</span> <span class="no">nil</span><span class="p">,</span> <span class="n">而非嵌套数组</span>
<span class="n">p</span> <span class="n">ready</span> <span class="err">#</span><span class="o">=&gt;</span> <span class="no">nil</span>
</code></pre></div></div>

<h2 id="122-读写之外的事件">12.2 读/写之外的事件</h2>
<p><code class="language-plaintext highlighter-rouge">IO.select</code> 监视套接字的读写状态</p>

<h3 id="1221-eof">12.2.1 EOF</h3>
<p><code class="language-plaintext highlighter-rouge">EOF</code> 是 <code class="language-plaintext highlighter-rouge">end of file</code> ，如果在监视可读性时，接到 <code class="language-plaintext highlighter-rouge">EOF</code> ，该套接字会作为可读套接字数组的一部分被返回</p>

<h3 id="1222-accept">12.2.2 accept</h3>

<ul>
  <li>监视服务器套接字可读性时，如果收到接入连接，套接字可作为可读套接字数组的一部分返回</li>
</ul>

<h3 id="1222-connect">12.2.2 connect</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">connect_nonblock</code> 是非阻塞式连接，如果不能立刻完成连接，则会产生 <code class="language-plaintext highlighter-rouge">Errno::EIGPROGRESS</code></li>
  <li>使用 <code class="language-plaintext highlighter-rouge">IO.select</code> 了解后台连接是否已经完成
端口扫描器代码见 <code class="language-plaintext highlighter-rouge">./code/snippets/port_scanner.rb</code></li>
</ul>

<h3 id="1223-高性能复用">12.2.3 高性能复用</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">IO.select</code> 是 ruby 核心代码库，他是 ruby 进行复用唯一手段</li>
  <li>大多数系统支持多种复用方法， <code class="language-plaintext highlighter-rouge">select(2)</code> 几乎是最古老，也是用的最少的</li>
  <li><code class="language-plaintext highlighter-rouge">IO.select</code> 同它所监视的连接数呈线性关系，监视连接数越多，性能就越差</li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">select(2)</code> 系统调用受到 <code class="language-plaintext highlighter-rouge">FD_SETSIZE</code>（文件描述符数量大小） 的限制，无法对编号大于 FD_SETSIZE(多数系统上是 1024)的文件描述符进行监视</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">poll(2)</code> 系统调用与 <code class="language-plaintext highlighter-rouge">select(2)</code> 仅限于表面不同</li>
  <li><code class="language-plaintext highlighter-rouge">epoll(2)</code> 以及 BSD 的 <code class="language-plaintext highlighter-rouge">kqueue(2)</code> 系统调用比 <code class="language-plaintext highlighter-rouge">select(2)</code> 效果更好，性能更先进</li>
  <li><code class="language-plaintext highlighter-rouge">EvenMachine</code> 倾向于使用 <code class="language-plaintext highlighter-rouge">epoll(2)</code> 以及 BSD 的 <code class="language-plaintext highlighter-rouge">kqueue(2)</code></li>
  <li>ruby 的 gem <code class="language-plaintext highlighter-rouge">nio4r</code> 为 <code class="language-plaintext highlighter-rouge">select(2)</code>, <code class="language-plaintext highlighter-rouge">epoll(2)</code> 等提供了通用的接口</li>
</ul>

<hr />

<h2 id="第-13-章nagle-算法">第 13 章：Nagle 算法</h2>

<ul>
  <li>Nagle 算法是一种默认用于所有的 TCP 连接的优化</li>
  <li>这种优化适合那些不进行缓冲、每次只发送很小数据量的应用程序</li>
  <li>ruby 有缓冲，所以在 TCP 上实现的大部分常见协议会希望禁用 Nagle 算法</li>
</ul>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">server</span><span class="p">.</span><span class="nf">setsockopt</span><span class="p">(</span><span class="no">Socket</span><span class="o">::</span><span class="no">IPPROTO_TCP</span><span class="p">,</span> <span class="no">Socket</span><span class="o">::</span><span class="no">TCP_NODELAY</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<hr />

<h2 id="第-14-章消息划分">第 14 章：消息划分</h2>

<ul>
  <li>发送多条消息并复用连接，需要用某种方式表明消息之间的起止</li>
  <li>多消息重用连接与 <code class="language-plaintext highlighter-rouge">HTTP keep-alive</code> 特性背后的理念一致，在多个请求间保持连接开放(包括客户端和服务器协商的划分消息的方法)，通过避免打开新的连接来节省资源。</li>
</ul>

<p><strong>协议与消息</strong>：</p>

<ul>
  <li>协议定义了应该如何格式化消息</li>
  <li>比如：HTTP 协议既定义了消息边界(连续的新行)，也定义了用于消息内容(涉及请求行、头部等)的协议</li>
</ul>

<h3 id="141-使用新行">14.1 使用新行</h3>

<ul>
  <li>使用新行(newlines) 是一种划分消息的简单方法</li>
  <li>使用 ruby <code class="language-plaintext highlighter-rouge">IO#gets</code> 和 <code class="language-plaintext highlighter-rouge">IO#puts</code> 可以发送带新行的消息</li>
  <li><code class="language-plaintext highlighter-rouge">IO#gets</code> 和 <code class="language-plaintext highlighter-rouge">IO#puts</code>  在不同的操作系统中使用的行分隔符不一样，需要注意兼容性问题</li>
  <li>现实中使用新行划分消息的协议是 HTTP，用 <code class="language-plaintext highlighter-rouge">\r\n</code></li>
</ul>

<h3 id="142-使用内容长度">14.2 使用内容长度</h3>

<p>划分指定内容长度(content length):</p>

<ul>
  <li>发送方先计算出消息的长度，使用 pack 将其转换成固定宽度的整数</li>
  <li>消息接收方首先读取这个长度值，知道了消息的大小</li>
  <li>然后接收方严格读取长度值所指定的字节数，获得完整的消息</li>
</ul>

<p>代码详细见 cloudhash/server2.rb  cloudhash/client2.rb</p>

<hr />

<h2 id="第-15-章-超时">第 15 章： 超时</h2>

<p>如果套接字没能在 5 秒内完成数据写入，那就说明存在问题</p>

<h3 id="151-不可用的选项">15.1 不可用的选项</h3>

<ul>
  <li>ruby 标准库 <code class="language-plaintext highlighter-rouge">timeout</code> 提供了一种通用的超时机制</li>
  <li>操作系统提供了自带的套接字超时处理机制, ruby 1.9 之后 不能会用</li>
  <li>ruby 处理套接字超时建议使用 <code class="language-plaintext highlighter-rouge">IO.select</code></li>
</ul>

<h3 id="152-ioselect">15.2 IO.select</h3>

<ul>
  <li>除了读取超时，连接/接收的超时都可以用 <code class="language-plaintext highlighter-rouge">IO.select</code> 处理</li>
</ul>

<p>代码见 <code class="language-plaintext highlighter-rouge">snippet/read_timeout.rb</code></p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'socket'</span>
<span class="nb">require</span> <span class="s1">'timeout'</span>

<span class="n">timeout</span> <span class="o">=</span> <span class="mi">5</span> <span class="c1"># 秒</span>

<span class="no">Socket</span><span class="p">.</span><span class="nf">tcp_server_loop</span><span class="p">(</span><span class="mi">4481</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">connection</span><span class="o">|</span>

  <span class="k">begin</span>
    <span class="c1"># 发起一个初始化 read(2)。这一点很重要</span>
    <span class="c1"># 因为要求套接字上有被请求的数据，有数据可读时避免使用 select(2)</span>
    <span class="n">connection</span><span class="p">.</span><span class="nf">read_nonblock</span><span class="p">(</span><span class="mi">4096</span><span class="p">)</span>

  <span class="k">rescue</span> <span class="no">Errno</span><span class="o">::</span><span class="no">EAGAIN</span>
    <span class="c1"># 监视连接是否可读</span>
    <span class="k">if</span> <span class="no">IO</span><span class="p">.</span><span class="nf">select</span><span class="p">([</span><span class="n">connection</span><span class="p">],</span> <span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span>
      <span class="c1"># IO.select 会将套接字返回，不过我们并不关心返回值</span>
      <span class="c1"># 不返回 nil 就意味着套接字可读</span>
      <span class="k">retry</span>
    <span class="k">else</span>
      <span class="k">raise</span> <span class="no">Timeout</span><span class="o">::</span><span class="no">Error</span>  <span class="c1"># 使用 timeout 只是为了用 Timeout::Error 常量</span>
    <span class="k">end</span>

  <span class="k">end</span>

  <span class="n">connection</span><span class="p">.</span><span class="nf">close</span>
<span class="k">end</span>
</code></pre></div></div>

<hr />

<h2 id="第-16-章-dns-查询">第 16 章： DNS 查询</h2>

<h3 id="mri-和-gil">MRI 和 GIL</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Global Interpreter Lock, GIL</code> 全局解释锁，确保 ruby 解释器只做一件有潜在危险的事。多线程环境中，当一个线程进行活动时，其它线程全部处于阻塞状态</li>
  <li>如果一个线程进行阻塞式 IO, （例如一个阻塞式 read）, GIL 会释放 GIL 并让另一个线程继续执行</li>
  <li>只要代码块用到了 C 语言扩展 API, GIL 会阻塞其它代码的运行</li>
  <li>ruby 的 DNS 查询使用了一个 C 语言扩展，可能会被长时间阻塞，MRI 就不会释放 GIL</li>
</ul>

<p>resolv</p>

<ul>
  <li>resolv 为 DNS 查询提供了一套纯 Ruby 的替代方案，是的 MRI 能够为长期阻塞的 DNS 查询释放 GIL</li>
  <li>ruby 标准库使用 <code class="language-plaintext highlighter-rouge">resolv-replace</code> 猴子不定来使用 resolv</li>
</ul>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="sb">`resolv`</span> <span class="c1"># 库</span>
<span class="n">reequire</span> <span class="sb">`resolv-replace`</span> <span class="c1"># 猴子补丁</span>
</code></pre></div></div>

<hr />

<h2 id="第-17-章-ssl-套接字">第 17 章: SSL 套接字</h2>

<ul>
  <li>SSL 使用公钥加密提供了一套用于在套接字上进行安全的数据交换的机制</li>
  <li>套接字可以升级为 SSL，但一个套接字不能同时进行 SSL 和非 SSL 通信</li>
  <li>ruby 中使用标准库的 openssl 实现套接字转为 SSL 套接字</li>
</ul>

<h2 id="第-18-章-ssl-套接字">第 18 章: SSL 套接字</h2>

<ul>
  <li>TCP 套接字数据提供了一种有序的数据流。</li>
  <li>可以将 TCP 数据流想象成一个队列。套接字连接的一端向连接中写入数据，就相当于将数据入列。</li>
  <li>数据经过若干阶段（本地缓冲、网络传输、远程缓冲），然后在接收端的套接字出列。</li>
  <li>TCP 紧急数据，更多的时候被称作 “带外数据”(out-of-band data),支持将数据推到队列的前端，绕过其它已经在传输的数据，比便于另一端尽快接收</li>
</ul>

<h3 id="发送紧急数据">发送紧急数据</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'socket'</span>

<span class="n">socket</span> <span class="o">=</span> <span class="no">TCPSocket</span><span class="p">.</span><span class="nf">new</span> <span class="s1">'localhost'</span><span class="p">,</span> <span class="mi">4481</span>

<span class="c1"># 会用标准方法发送数据</span>
<span class="n">socket</span><span class="p">.</span><span class="nf">write</span> <span class="s1">'first'</span>
<span class="n">socket</span><span class="p">.</span><span class="nf">write</span> <span class="s1">'second'</span>

<span class="c1"># 发送紧急数据</span>
<span class="n">socket</span><span class="p">.</span><span class="nf">send</span> <span class="s1">'!'</span><span class="p">,</span><span class="no">Socket</span><span class="o">::</span><span class="no">MSG_OOB</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Socket#send</code> 将 <code class="language-plaintext highlighter-rouge">Socket::MSG_OOB</code> 常量作为标志。 OOB 指的就是带外数据</li>
  <li>发送方和接收方需要合作才可以处理带外数据</li>
</ul>

<h2 id="接收紧急数据">接收紧急数据</h2>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'socket'</span>

<span class="no">Socket</span><span class="p">.</span><span class="nf">tcp_server_loop</span><span class="p">(</span><span class="mi">4481</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">connection</span><span class="o">|</span>

  <span class="c1"># 优先接收紧急数据</span>
  <span class="n">urgent_data</span> <span class="o">=</span> <span class="n">connection</span><span class="p">.</span><span class="nf">recv</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="no">Socket</span><span class="o">::</span><span class="no">MSG_OOB</span><span class="p">)</span>
  <span class="n">data</span> <span class="o">=</span> <span class="n">connection</span><span class="p">.</span><span class="nf">readpartial</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<ul>
  <li>接收紧急数据，需要使用 <code class="language-plaintext highlighter-rouge">Socket#recv</code> 以及在发送紧急数据时用过的那个标志</li>
  <li>紧急数据会优先于 “普通” 数据使用，即使写入的比 “普通” 数据晚</li>
  <li>如果不存在未处理的紧急数据，调用 <code class="language-plaintext highlighter-rouge">connection.recv(1, Socket::MSG_OOB)</code> 会失败，并产生 <code class="language-plaintext highlighter-rouge">Errno::EINVAL</code></li>
</ul>

<h2 id="局限">局限</h2>

<ul>
  <li>TCP 实现对于紧急数据仅提供了有限的支持，一次只能发送一个字节的紧急数据。如果发送多个字节，只有最后一个字节会被视为紧急数据，之前的数据会被视为普通的 TCP 数据流</li>
</ul>

<h2 id="紧急数据和-ioselect">紧急数据和 IO.select</h2>

<ul>
  <li>如果套接字接收到了紧急数据，它们会被包含在 <code class="language-plaintext highlighter-rouge">IO.select</code>  所返回数组的第三个元素中</li>
  <li><code class="language-plaintext highlighter-rouge">IO.select</code> 会不停的报告有紧急数据，即便是所有的紧急数据已经处理完毕，所以需要特殊处理</li>
</ul>

<h2 id="so_oobinline-选项">SO_OOBINLINE 选项</h2>

<p><code class="language-plaintext highlighter-rouge">SO_OOBINLINE</code> 套接字选项，允许在带内接收带外数据，启用后回一句写入次序从队列读出</p>

<h2 id="tcp-sockets-编程20-串行化">TCP Sockets 编程(20): 串行化</h2>

<p>串行化架构处理流程：</p>

<ol>
  <li>客户端连接</li>
  <li>客户端/服务器交换请求及响应</li>
  <li>客户端断开连接</li>
  <li>返回到步骤(1)</li>
</ol>

<p>串行化的特点：简单化，没有锁，没有共享状态，处理完一个连接之后才能处理另一个，不能支持并发操作</p>

<h2 id="tcp-sockets-编程21-单连接进程">TCP Sockets 编程(21): 单连接进程</h2>

<p>单连接进程事件流程：</p>

<ol>
  <li>一个连接抵达服务器</li>
  <li>主服务器进程接受该练级</li>
  <li>衍生出一个和服务器一模一样的新子进程</li>
  <li>服务器进程返回步骤 1，由子进程并行处理连接</li>
</ol>

<p>优点：</p>

<ul>
  <li>简单，能并行处理多个客户端</li>
  <li>for 提供了一个父进程的所有东西的副本，没有锁和竞争条件</li>
</ul>

<p>缺点：</p>

<ul>
  <li>对 fork 出的子进程的数量没有施加限制，如果超出系统限制会崩溃</li>
  <li>只有 Unix 系统才支持 fork，windows 或 JRuby 中没法使用 fork</li>
</ul>

<h2 id="tcp-sockets-编程22-单连接线程">TCP Sockets 编程(22): 单连接线程</h2>

<p>线程与进程：</p>

<ul>
  <li>生成(<code class="language-plaintext highlighter-rouge">spawn</code>): 线程的成本低于进程，进程生成需创建原始进程所拥有的一切资源的副本，多个线程共享内存，不需要创建副本</li>
  <li>同步：因为线程共享内存，所以线程之间使用互斥量(mutex)、锁和同步访问。进程不需要这些</li>
  <li>并行：解释器对当前执行环境使用了一个全局解释锁 <code class="language-plaintext highlighter-rouge">GIL</code>,所以多线程无法实现真正的并行, 在 <code class="language-plaintext highlighter-rouge">MRI</code> 中，只有进程才能实现真正的并发
但ruby 中如果某个线程阻塞在 IO 上， ruby 能让其他的线程继续执行</li>
</ul>

<p>使用线程注意：</p>

<ul>
  <li>套接字如果分配给一个实例变量，会在所有活动线程之间共享该实例的内部状态</li>
  <li>使用线程进行套接字编程，必须让每个线程获得它自己的连接对象，这样可以减少麻烦</li>
</ul>

<h2 id="tcp-sockets-编程23-preforking">TCP Sockets 编程(23): Preforking</h2>

<p>Preforking 处理流程：</p>

<ol>
  <li>主服务器进程创建一个侦听套接字</li>
  <li>主服务器进程衍生出一大批子进程</li>
  <li>每个子进程在共享套接字上接受连接，然后进行独立处理</li>
  <li>主服务器进程随时关注子进程</li>
</ol>

<p>Preforking 优点：</p>
<ul>
  <li>多进程处理连接的负载均衡由操作系统处理</li>
  <li>子进程完全隔离，每个进程都拥有包括 ruby 解释器在内的所有资源的副本，单个进程的故障不会影响其他进程。</li>
</ul>

<p>缺点:</p>
<ul>
  <li>衍生进程越多，消耗的内存也越多</li>
</ul>

<h2 id="tcp-sockets-编程24-线程池">TCP Sockets 编程(24): 线程池</h2>

<ul>
  <li>线程池模式类似于 <code class="language-plaintext highlighter-rouge">preforking</code></li>
  <li>线程池在服务器启动后生产一批线程，将处理连接的任务交给独立线程来完成</li>
</ul>
]]></content>
	</entry>
	
	<entry>
		<title>《SQL 反模式》学习笔记</title>
		<link href="http://127.0.0.1/notes/2015/03/06/SQL-%E5%8F%8D%E6%A8%A1%E5%BC%8F-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html" />
		<updated>2015-03-06T00:00:00+08:00</updated>
		<id>http://127.0.0.1/notes/2015/03/06/SQL-%E5%8F%8D%E6%A8%A1%E5%BC%8F-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html</id>
		<content type="html"><![CDATA[<h3 id="cap-组合">CAP 组合</h3>

<ul>
  <li>一致性(Consistency)</li>
  <li>可用性(Availability)</li>
  <li>分区容忍性(Partition)</li>
  <li>CAP 原理认为这三要素最多能同时实现两点，不可能三者兼顾</li>
</ul>

<h2 id="第一部分-逻辑型数据库设计反模式">第一部分 逻辑型数据库设计反模式</h2>

<h2 id="反模式分类">反模式分类</h2>

<p>　　（1）逻辑数据库设计反模式</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     在开始编码之前，需要决定数据库中存储什么信息以及最佳的数据组织方式和内在关联方式。
     这包含了如何设计数据库的表、字段和关系。
</code></pre></div></div>

<p>　　（2）物理数据库设计反模式</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     在确定了需要存储哪些数据之后，使用你所知的RDBMS关系型数据库技术特性尽可能高效地实现数据库管理。
     这包含了定义表和索引，以及选择数据类型。也需要是要SQL的“数据定义语言”，比如Create Table语句。
</code></pre></div></div>

<p>　　（3）查询反模式</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     SQL的查询是使用“数据操作语言”来完成，比如：Insert、Select、Update和Delete语句。
</code></pre></div></div>

<p>　　（4）应用程序开发反模式</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     SQL应该会用在Java、.Net、C++、Php等语言构建的应用程序中，在应用程序中使用SQL的方式有好有坏。
</code></pre></div></div>

<h2 id="第一部分-逻辑型数据库设计反模式-1">第一部分 逻辑型数据库设计反模式</h2>

<h3 id="第二章乱穿马路">第二章：乱穿马路</h3>

<ul>
  <li>程序员通常使用逗号分隔的列表来避免在多对多的关系中创建交叉表，我将这种合计方式定义为一种反模式，称为乱穿马路(Jaywalking)</li>
</ul>

<h4 id="目标">目标：</h4>

<p>存储多值属性，即实现多对一的关系</p>

<h4 id="反模式格式化的逗号分隔列表">反模式：格式化的逗号分隔列表</h4>

<p>反模式：将多个值以格式化的逗号分隔符存储在一个字段中</p>

<p>反模式导致的问题：</p>

<ul>
  <li>所有外键合并在一个字段内，查询会变得异常困难。需要使用正则表达式模式匹配，无法使用索引，各个数据库中的语法不兼容</li>
  <li>关联查询：查询指定 产品的账号信息。简单的sql语句无法实现，而且无法使用索引，查询效率极低。</li>
  <li>聚合查询如 COUNT(),SUM() 等等是针对分组行而设计，逗号分隔的列表，需要用非正常方法实现</li>
  <li>删除一个条目，需要先提取老的列表，更新后并存储，过于复杂</li>
  <li>需要验证防止非法字段,合法数据无法保证</li>
  <li>需要选择合适的分隔符</li>
  <li>字段的长度限制会影响分类数量。</li>
</ul>

<h4 id="如何识别反模式">如何识别反模式</h4>

<ul>
  <li>字段存储的值有长度限制</li>
  <li>需要使用正则表达式来提取字符串中的组成部分，意味着你应该把这些数据分开存储</li>
  <li>内容中出现了令人困惑的分割符号</li>
</ul>

<h4 id="合理使用反模式">合理使用反模式</h4>

<ul>
  <li>处于性能优化的考虑，可能需要使用这种反规范化的模式</li>
  <li>只需要存储而不需要修改时，可以使用逗号分隔的存储格式</li>
</ul>

<h4 id="解决方案">解决方案：</h4>

<ul>
  <li>创建一张交叉表</li>
  <li>每个值都应该存储在各自的行与列中</li>
</ul>

<h3 id="第三章单纯的树">第三章：单纯的树</h3>

<ul>
  <li>树是一种存在递归关系的数据</li>
  <li>树形结构中，实例被称为 <code class="language-plaintext highlighter-rouge">节点(node)</code>，每个节点有多个子节点和一个父节点</li>
  <li>最上层的节点叫<code class="language-plaintext highlighter-rouge">根(root)</code>节点，它没有父节点</li>
  <li>最底层的没有子节点的节点叫做 <code class="language-plaintext highlighter-rouge">叶(leaf)</code></li>
  <li>中间的节点简单的称为 <code class="language-plaintext highlighter-rouge">非叶(noleaf)</code></li>
</ul>

<h4 id="目标分层存储与查询"><strong>目标</strong>：分层存储与查询</h4>

<ul>
  <li>层级数据中，可能需要查询与整个集合或者子集相关的特定对象，比如组织架构图、线程化评论等</li>
</ul>

<h4 id="反模式总是依赖父节点">反模式：总是依赖父节点</h4>

<p><strong>邻接表</strong>： 表中添加 <code class="language-plaintext highlighter-rouge">parent_id</code> 字段，引用同一张表中的其它回复。可以建一个外键来维护这种关系</p>

<p><strong>邻接表 ERD：</strong>
<img src="/assets/images/邻接表.png" alt="邻接表" /></p>

<ul>
  <li>树的特性是可以无限制的任意深度扩展，需要有办法获取任意深度的数据</li>
  <li>SQL 查询中联结的次数是有上限的</li>
  <li>邻接表插入一个节点非常的简单，但是删除一个节点会异常复杂</li>
</ul>

<h4 id="如何识别反模式-1">如何识别反模式</h4>

<ul>
  <li>只支持查询有限层级的数据</li>
  <li>数结构管理维护非常复杂</li>
  <li>需要定期清理树中的孤立节点数据</li>
  <li></li>
</ul>

<h3 id="解决方案使用其他树模型">解决方案：使用其他树模型</h3>

<h4 id="路径枚举">路径枚举</h4>

<ul>
  <li>通过将所有祖先的信息联合成一个字段 path，并保存为每个节点的一个属性</li>
</ul>

<p>优点：</p>

<ul>
  <li>查询方便</li>
  <li>插入一个叶子节点也可以非常的方便</li>
</ul>

<p>缺点：</p>

<ul>
  <li>数据库不能确保路径的格式总是正确或者路径中的结点确实存在</li>
  <li>存在长度限制，并不能无限扩展</li>
</ul>

<p>实现代码 mysql:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 创建路径枚举</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">Comments</span> <span class="p">(</span>
  <span class="n">comment_id</span> <span class="nb">SERIAL</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
  <span class="n">path</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">1000</span><span class="p">),</span>
  <span class="n">author</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">1000</span><span class="p">),</span>
  <span class="k">comment</span> <span class="nb">TEXT</span> <span class="k">NOT</span> <span class="k">NULL</span>
<span class="p">);</span>

<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">Comments</span> <span class="p">(</span><span class="n">comment_id</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">author</span><span class="p">,</span> <span class="k">comment</span><span class="p">)</span> <span class="k">VALUES</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nv">"1/"</span><span class="p">,</span> <span class="nv">"Fran"</span><span class="p">,</span> <span class="nv">"这个Bug的成因是什么"</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">Comments</span> <span class="p">(</span><span class="n">comment_id</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">author</span><span class="p">,</span> <span class="k">comment</span><span class="p">)</span> <span class="k">VALUES</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nv">"1/2/"</span><span class="p">,</span> <span class="nv">"Ollie"</span><span class="p">,</span> <span class="nv">"我觉得是一个空指针"</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">Comments</span> <span class="p">(</span><span class="n">comment_id</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">author</span><span class="p">,</span> <span class="k">comment</span><span class="p">)</span> <span class="k">VALUES</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="nv">"1/2/3/"</span><span class="p">,</span> <span class="nv">"Fran"</span><span class="p">,</span> <span class="nv">"不，我查过了"</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">Comments</span> <span class="p">(</span><span class="n">comment_id</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">author</span><span class="p">,</span> <span class="k">comment</span><span class="p">)</span> <span class="k">VALUES</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="nv">"1/4/"</span><span class="p">,</span> <span class="nv">"Kukla"</span><span class="p">,</span> <span class="nv">"我们需要查无效输入"</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">Comments</span> <span class="p">(</span><span class="n">comment_id</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">author</span><span class="p">,</span> <span class="k">comment</span><span class="p">)</span> <span class="k">VALUES</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="nv">"1/4/5/"</span><span class="p">,</span> <span class="nv">"Fran"</span><span class="p">,</span> <span class="nv">"是的，那是个问题"</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">Comments</span> <span class="p">(</span><span class="n">comment_id</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">author</span><span class="p">,</span> <span class="k">comment</span><span class="p">)</span> <span class="k">VALUES</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="nv">"1/4/6/"</span><span class="p">,</span> <span class="nv">"Frank"</span><span class="p">,</span> <span class="nv">"好，查一下吧"</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">Comments</span> <span class="p">(</span><span class="n">comment_id</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">author</span><span class="p">,</span> <span class="k">comment</span><span class="p">)</span> <span class="k">VALUES</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="nv">"1/4/6/7/"</span><span class="p">,</span> <span class="nv">"Frank"</span><span class="p">,</span> <span class="nv">"解决了"</span><span class="p">);</span>

<span class="c1">-- ancestors.sql</span>
<span class="k">SELECT</span> <span class="o">*</span>
<span class="k">FROM</span> <span class="n">Comments</span> <span class="k">AS</span> <span class="k">c</span>
<span class="k">WHERE</span> <span class="s1">'1/4/6/7/'</span> <span class="k">LIKE</span> <span class="k">c</span><span class="p">.</span><span class="n">path</span> <span class="o">||</span> <span class="s1">'%'</span><span class="p">;</span> <span class="c1">-- mysql 不能用，语法不同</span>

<span class="c1">-- descendants.sql</span>
<span class="k">SELECT</span> <span class="o">*</span>
<span class="k">FROM</span> <span class="n">Comments</span> <span class="k">AS</span> <span class="k">c</span>
<span class="k">WHERE</span> <span class="k">c</span><span class="p">.</span><span class="n">path</span> <span class="k">LIKE</span> <span class="s1">'1/4/'</span> <span class="o">||</span> <span class="s1">'%'</span><span class="p">;</span> 

<span class="c1">-- count.sql</span>
<span class="k">SELECT</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
<span class="k">FROM</span> <span class="n">Comments</span> <span class="k">AS</span> <span class="k">c</span>
<span class="k">WHERE</span> <span class="k">c</span><span class="p">.</span><span class="n">path</span> <span class="k">LIKE</span> <span class="s1">'1/4/'</span> <span class="o">||</span> <span class="s1">'%'</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="k">c</span><span class="p">.</span><span class="n">author</span><span class="p">;</span>

<span class="c1">-- Insert.sql</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">Comments</span> <span class="p">(</span><span class="n">author</span><span class="p">,</span> <span class="k">comment</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'Ollie'</span><span class="p">,</span> <span class="s1">'Good job!'</span><span class="p">);</span>
<span class="k">SELECT</span> <span class="o">@</span><span class="n">PATH</span><span class="p">:</span><span class="o">=</span><span class="n">CONCAT</span><span class="p">((</span><span class="k">SELECT</span> <span class="n">path</span> <span class="k">FROM</span> <span class="n">Comments</span>   <span class="k">WHERE</span> <span class="n">comment_id</span> <span class="o">=</span> <span class="mi">7</span><span class="p">),</span> <span class="n">LAST_INSERT_ID</span><span class="p">(),</span> <span class="s1">'/'</span><span class="p">);</span>
<span class="k">UPDATE</span> <span class="n">Comments</span>  <span class="k">SET</span> <span class="n">path</span><span class="o">=@</span><span class="n">PATH</span> <span class="k">WHERE</span> <span class="n">comment_id</span> <span class="o">=</span> <span class="n">LAST_INSERT_ID</span><span class="p">();</span>

</code></pre></div></div>

<h4 id="嵌套集">嵌套集</h4>

<p>使用  nsleft 和 nsright 两个数字来编码每个节点， nsleft 的数值小于该节点所有后代的 ID，同
时 nsright 的值大于该节点所有后代的 ID</p>

<p>优点：</p>

<ul>
  <li>删除方便，原非叶节点被删除，后代会自动代替被删除节点</li>
</ul>

<p>缺点：</p>

<ul>
  <li>获取直接父亲或直接后代的查询非常不便，需要加入 depth(层级) 来弥补缺陷</li>
  <li>插入和移动节点比较复杂</li>
</ul>

<p>实现代码 mysql:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">Comments</span> <span class="p">(</span>
  <span class="n">comment_id</span> <span class="nb">SERIAL</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
  <span class="n">nsleft</span> <span class="nb">INTEGER</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="n">nsright</span> <span class="nb">INTEGER</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="n">author</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">1000</span><span class="p">),</span>
  <span class="k">comment</span> <span class="nb">TEXT</span> <span class="k">NOT</span> <span class="k">NULL</span>
<span class="p">);</span>

<span class="c1">-- 插入</span>
<span class="c1">-- 根据“嵌套集合模型”的数学原理，子节点的左界是当前节点的右界，子节点的右界是当前节点的右界加1，并且所有在当前节点右侧的节点的左右界都加 2</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">Comments</span> <span class="p">(</span><span class="n">comment_id</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">nsleft</span><span class="p">,</span> <span class="n">nsright</span><span class="p">,</span> <span class="n">author</span><span class="p">,</span> <span class="k">comment</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nv">"Fran"</span><span class="p">,</span> <span class="nv">"这个 Bug 的成因是什么"</span><span class="p">);</span>

<span class="k">UPDATE</span> <span class="n">Comments</span> <span class="k">SET</span> <span class="n">nsleft</span><span class="o">=</span><span class="n">nsleft</span><span class="o">+</span><span class="mi">2</span> <span class="k">WHERE</span> <span class="n">nsleft</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">;</span>
<span class="k">UPDATE</span> <span class="n">Comments</span> <span class="k">SET</span> <span class="n">nsright</span><span class="o">=</span><span class="n">nsright</span><span class="o">+</span><span class="mi">2</span> <span class="k">WHERE</span> <span class="n">nsright</span><span class="o">&gt;=</span><span class="mi">2</span><span class="p">;</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">Comments</span> <span class="p">(</span><span class="n">comment_id</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">nsleft</span><span class="p">,</span> <span class="n">nsright</span><span class="p">,</span> <span class="n">author</span><span class="p">,</span> <span class="k">comment</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nv">"Ollie"</span><span class="p">,</span> <span class="nv">"我觉得是一个空指针"</span><span class="p">);</span>

<span class="k">UPDATE</span> <span class="n">Comments</span> <span class="k">SET</span> <span class="n">nsleft</span><span class="o">=</span><span class="n">nsleft</span><span class="o">+</span><span class="mi">2</span> <span class="k">WHERE</span> <span class="n">nsleft</span><span class="o">&gt;</span><span class="mi">3</span><span class="p">;</span>
<span class="k">UPDATE</span> <span class="n">Comments</span> <span class="k">SET</span> <span class="n">nsright</span><span class="o">=</span><span class="n">nsright</span><span class="o">+</span><span class="mi">2</span> <span class="k">WHERE</span> <span class="n">nsright</span><span class="o">&gt;=</span><span class="mi">3</span><span class="p">;</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">Comments</span> <span class="p">(</span><span class="n">comment_id</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">nsleft</span><span class="p">,</span> <span class="n">nsright</span><span class="p">,</span> <span class="n">author</span><span class="p">,</span> <span class="k">comment</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nv">"Fran"</span><span class="p">,</span> <span class="nv">"不，我查过了"</span><span class="p">);</span>

<span class="k">UPDATE</span> <span class="n">Comments</span> <span class="k">SET</span> <span class="n">nsleft</span><span class="o">=</span><span class="n">nsleft</span><span class="o">+</span><span class="mi">2</span> <span class="k">WHERE</span> <span class="n">nsleft</span><span class="o">&gt;</span><span class="mi">6</span><span class="p">;</span>
<span class="k">UPDATE</span> <span class="n">Comments</span> <span class="k">SET</span> <span class="n">nsright</span><span class="o">=</span><span class="n">nsright</span><span class="o">+</span><span class="mi">2</span> <span class="k">WHERE</span> <span class="n">nsright</span><span class="o">&gt;=</span><span class="mi">6</span><span class="p">;</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">Comments</span> <span class="p">(</span><span class="n">comment_id</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">nsleft</span><span class="p">,</span> <span class="n">nsright</span><span class="p">,</span> <span class="n">author</span><span class="p">,</span> <span class="k">comment</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nv">"Kukla"</span><span class="p">,</span> <span class="nv">"我们需要查无效输入"</span><span class="p">);</span>

<span class="k">UPDATE</span> <span class="n">Comments</span> <span class="k">SET</span> <span class="n">nsleft</span><span class="o">=</span><span class="n">nsleft</span><span class="o">+</span><span class="mi">2</span> <span class="k">WHERE</span> <span class="n">nsleft</span><span class="o">&gt;</span><span class="mi">7</span><span class="p">;</span>
<span class="k">UPDATE</span> <span class="n">Comments</span> <span class="k">SET</span> <span class="n">nsright</span><span class="o">=</span><span class="n">nsright</span><span class="o">+</span><span class="mi">2</span> <span class="k">WHERE</span> <span class="n">nsright</span><span class="o">&gt;=</span><span class="mi">7</span><span class="p">;</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">Comments</span> <span class="p">(</span><span class="n">comment_id</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">nsleft</span><span class="p">,</span> <span class="n">nsright</span><span class="p">,</span> <span class="n">author</span><span class="p">,</span> <span class="k">comment</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nv">"Ollie"</span><span class="p">,</span> <span class="nv">"是的，那是个问题"</span><span class="p">);</span>

<span class="k">UPDATE</span> <span class="n">Comments</span> <span class="k">SET</span> <span class="n">nsleft</span><span class="o">=</span><span class="n">nsleft</span><span class="o">+</span><span class="mi">2</span> <span class="k">WHERE</span> <span class="n">nsleft</span><span class="o">&gt;</span><span class="mi">9</span><span class="p">;</span>
<span class="k">UPDATE</span> <span class="n">Comments</span> <span class="k">SET</span> <span class="n">nsright</span><span class="o">=</span><span class="n">nsright</span><span class="o">+</span><span class="mi">2</span> <span class="k">WHERE</span> <span class="n">nsright</span><span class="o">&gt;=</span><span class="mi">9</span><span class="p">;</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">Comments</span> <span class="p">(</span><span class="n">comment_id</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">nsleft</span><span class="p">,</span> <span class="n">nsright</span><span class="p">,</span> <span class="n">author</span><span class="p">,</span> <span class="k">comment</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nv">"Fran"</span><span class="p">,</span> <span class="nv">"好，查一下吧"</span><span class="p">);</span>

<span class="k">UPDATE</span> <span class="n">Comments</span> <span class="k">SET</span> <span class="n">nsleft</span><span class="o">=</span><span class="n">nsleft</span><span class="o">+</span><span class="mi">2</span> <span class="k">WHERE</span> <span class="n">nsleft</span><span class="o">&gt;</span><span class="mi">10</span><span class="p">;</span>
<span class="k">UPDATE</span> <span class="n">Comments</span> <span class="k">SET</span> <span class="n">nsright</span><span class="o">=</span><span class="n">nsright</span><span class="o">+</span><span class="mi">2</span> <span class="k">WHERE</span> <span class="n">nsright</span><span class="o">&gt;=</span><span class="mi">10</span><span class="p">;</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">Comments</span> <span class="p">(</span><span class="n">comment_id</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">nsleft</span><span class="p">,</span> <span class="n">nsright</span><span class="p">,</span> <span class="n">author</span><span class="p">,</span> <span class="k">comment</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nv">"Kukla"</span><span class="p">,</span> <span class="nv">"解决了"</span><span class="p">);</span>

<span class="c1">-- 查询所有叶节点</span>
<span class="c1">-- 根据此模型，叶节点就是右界比左界大1的那些节点，SQL语句很简单。</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">Comments</span> <span class="k">WHERE</span> <span class="n">nsright</span> <span class="o">=</span> <span class="n">nsleft</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">-- 取得单条路径</span>
<span class="k">SELECT</span> <span class="n">parent</span><span class="p">.</span><span class="n">comment_id</span><span class="p">,</span> <span class="n">parent</span><span class="p">.</span><span class="k">comment</span> <span class="k">FROM</span> <span class="n">Comments</span>  <span class="k">AS</span> <span class="n">node</span><span class="p">,</span> <span class="n">Comments</span> <span class="k">AS</span> <span class="n">parent</span>
  <span class="k">WHERE</span> <span class="n">parent</span><span class="p">.</span><span class="n">nsleft</span> <span class="o">&lt;=</span> <span class="n">node</span><span class="p">.</span><span class="n">nsleft</span> <span class="k">AND</span> <span class="n">node</span><span class="p">.</span><span class="n">nsleft</span> <span class="o">&lt;=</span> <span class="n">parent</span><span class="p">.</span><span class="n">nsright</span> <span class="k">AND</span> <span class="n">node</span><span class="p">.</span><span class="n">comment_id</span> <span class="o">=</span> <span class="mi">7</span>
  <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">parent</span><span class="p">.</span><span class="n">nsleft</span><span class="p">;</span>

<span class="c1">-- 查询节点的深度</span>
<span class="k">SELECT</span> <span class="n">depth</span> <span class="k">FROM</span> <span class="n">Comments</span> <span class="k">WHERE</span> <span class="n">comment_id</span><span class="o">=</span><span class="mi">7</span><span class="p">;</span>

<span class="c1">-- 整棵树及其深度</span>
<span class="k">SELECT</span> <span class="n">depth</span><span class="p">,</span> <span class="n">CONCAT</span><span class="p">(</span> <span class="n">REPEAT</span><span class="p">(</span><span class="s1">'- '</span><span class="p">,</span> <span class="n">depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="k">comment</span><span class="p">)</span> <span class="k">AS</span> <span class="n">name</span> <span class="k">FROM</span> <span class="n">Comments</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">nsleft</span><span class="p">;</span>

<span class="c1">-- 子树及深度</span>
<span class="k">SELECT</span> <span class="n">depth</span><span class="p">,</span> <span class="n">CONCAT</span><span class="p">(</span> <span class="n">REPEAT</span><span class="p">(</span><span class="s1">'- '</span><span class="p">,</span> <span class="n">depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="k">comment</span><span class="p">)</span> <span class="k">AS</span> <span class="k">comment</span> <span class="k">FROM</span> <span class="n">Comments</span> <span class="k">WHERE</span> <span class="n">nsleft</span><span class="o">&gt;=</span><span class="mi">2</span> <span class="k">AND</span> <span class="n">nsright</span><span class="o">&lt;=</span><span class="mi">11</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">nsleft</span><span class="p">;</span>

<span class="c1">-- 直接的子节点</span>
<span class="c1">-- 查询根节点的直接子节点</span>
<span class="k">SELECT</span> <span class="n">comment_id</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="k">comment</span> <span class="k">FROM</span> <span class="n">Comments</span> <span class="k">WHERE</span> <span class="n">nsleft</span><span class="o">&gt;</span><span class="mi">1</span> <span class="k">AND</span> <span class="n">nsright</span><span class="o">&lt;</span><span class="mi">14</span> <span class="k">AND</span> <span class="n">depth</span><span class="o">=</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">nsleft</span><span class="p">;</span>

<span class="c1">-- 直接的父节点</span>
<span class="k">SELECT</span> <span class="n">parent</span><span class="p">.</span><span class="n">comment_id</span><span class="p">,</span> <span class="n">parent</span><span class="p">.</span><span class="k">comment</span> <span class="k">FROM</span> <span class="n">Comments</span> <span class="k">AS</span> <span class="n">node</span><span class="p">,</span> <span class="n">Comments</span> <span class="k">AS</span> <span class="n">parent</span>
  <span class="k">WHERE</span> <span class="n">parent</span><span class="p">.</span><span class="n">nsleft</span> <span class="o">&lt;</span> <span class="n">node</span><span class="p">.</span><span class="n">nsleft</span> <span class="k">AND</span> <span class="n">node</span><span class="p">.</span><span class="n">nsleft</span> <span class="o">&lt;</span> <span class="n">parent</span><span class="p">.</span><span class="n">nsright</span> <span class="k">AND</span> <span class="n">node</span><span class="p">.</span><span class="n">comment_id</span> <span class="o">=</span> <span class="mi">7</span>
  <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">parent</span><span class="p">.</span><span class="n">nsleft</span> <span class="k">DESC</span> <span class="k">LIMIT</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>

<h4 id="闭包表">闭包表</h4>

<p>Closure Tree 闭包表，额外创建了一张 TreePaths 的表，以空间换取时间的思路，它包含两列，每一列都是一个指向 Comments 中的 CommentId 的外键，明晰表示两点间的关系</p>

<p>实现代码 mysql:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1">-- 创建评论表</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">Comments</span> <span class="p">(</span>
  <span class="n">id</span> <span class="nb">SERIAL</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
  <span class="k">comment</span> <span class="nb">TEXT</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="n">author</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
<span class="p">)</span> <span class="k">DEFAULT</span> <span class="n">CHARSET</span> <span class="o">=</span> <span class="n">utf8</span><span class="p">;</span>

<span class="c1">-- 创建关系表</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">comments_closure</span> <span class="p">(</span>
  <span class="n">ancestor</span> <span class="nb">INT</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>    <span class="c1">-- 祖先节点</span>
  <span class="n">descendant</span> <span class="nb">INT</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>  <span class="c1">-- 后代节点</span>
  <span class="n">depth</span> <span class="nb">INT</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>       <span class="c1">-- 层级</span>
  <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">ancestor</span><span class="p">,</span> <span class="n">descendant</span><span class="p">)</span>
<span class="p">)</span>

<span class="c1">-- 插入数据</span>

<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">Comments</span> <span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">author</span><span class="p">,</span> <span class="k">comment</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nv">"Fran"</span><span class="p">,</span> <span class="nv">"这个 Bug 的成因是什么"</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">comments_closure</span> <span class="p">(</span><span class="n">ancestor</span><span class="p">,</span> <span class="n">descendant</span><span class="p">)</span>
  <span class="k">SELECT</span> <span class="n">t</span><span class="p">.</span><span class="n">ancestor</span><span class="p">,</span> <span class="mi">1</span> <span class="k">FROM</span> <span class="n">comments_closure</span> <span class="k">AS</span> <span class="n">t</span> <span class="k">WHERE</span> <span class="n">t</span><span class="p">.</span><span class="n">descendant</span><span class="o">=</span><span class="mi">1</span> <span class="k">UNION</span> <span class="k">ALL</span> <span class="k">SELECT</span> <span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">;</span>


<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">Comments</span> <span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">author</span><span class="p">,</span> <span class="k">comment</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nv">"Ollie"</span><span class="p">,</span> <span class="nv">"我觉得是一个空指针"</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">comments_closure</span> <span class="p">(</span><span class="n">ancestor</span><span class="p">,</span> <span class="n">descendant</span><span class="p">)</span>
  <span class="k">SELECT</span> <span class="n">t</span><span class="p">.</span><span class="n">ancestor</span><span class="p">,</span> <span class="mi">2</span> <span class="k">FROM</span> <span class="n">comments_closure</span> <span class="k">AS</span> <span class="n">t</span> <span class="k">WHERE</span> <span class="n">t</span><span class="p">.</span><span class="n">descendant</span><span class="o">=</span><span class="mi">1</span> <span class="k">UNION</span> <span class="k">ALL</span> <span class="k">SELECT</span> <span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">;</span>

<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">Comments</span> <span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">author</span><span class="p">,</span> <span class="k">comment</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="nv">"Fran"</span><span class="p">,</span> <span class="nv">"不，我查过了"</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">comments_closure</span> <span class="p">(</span><span class="n">ancestor</span><span class="p">,</span> <span class="n">descendant</span><span class="p">)</span>
  <span class="k">SELECT</span> <span class="n">t</span><span class="p">.</span><span class="n">ancestor</span><span class="p">,</span> <span class="mi">3</span> <span class="k">FROM</span> <span class="n">comments_closure</span> <span class="k">AS</span> <span class="n">t</span> <span class="k">WHERE</span> <span class="n">t</span><span class="p">.</span><span class="n">descendant</span><span class="o">=</span><span class="mi">2</span> <span class="k">UNION</span> <span class="k">ALL</span> <span class="k">SELECT</span> <span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">;</span>


<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">Comments</span> <span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">author</span><span class="p">,</span> <span class="k">comment</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="nv">"Kukla"</span><span class="p">,</span> <span class="nv">"我们需要查无效输入"</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">comments_closure</span> <span class="p">(</span><span class="n">ancestor</span><span class="p">,</span> <span class="n">descendant</span><span class="p">)</span>
  <span class="k">SELECT</span> <span class="n">t</span><span class="p">.</span><span class="n">ancestor</span><span class="p">,</span> <span class="mi">4</span> <span class="k">FROM</span> <span class="n">comments_closure</span> <span class="k">AS</span> <span class="n">t</span> <span class="k">WHERE</span> <span class="n">t</span><span class="p">.</span><span class="n">descendant</span><span class="o">=</span><span class="mi">1</span> <span class="k">UNION</span> <span class="k">ALL</span> <span class="k">SELECT</span> <span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">;</span>

<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">Comments</span> <span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">author</span><span class="p">,</span> <span class="k">comment</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="nv">"Ollie"</span><span class="p">,</span> <span class="nv">"是的，那是个问题"</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">comments_closure</span> <span class="p">(</span><span class="n">ancestor</span><span class="p">,</span> <span class="n">descendant</span><span class="p">)</span>
  <span class="k">SELECT</span> <span class="n">t</span><span class="p">.</span><span class="n">ancestor</span><span class="p">,</span> <span class="mi">5</span> <span class="k">FROM</span> <span class="n">comments_closure</span> <span class="k">AS</span> <span class="n">t</span> <span class="k">WHERE</span> <span class="n">t</span><span class="p">.</span><span class="n">descendant</span><span class="o">=</span><span class="mi">4</span> <span class="k">UNION</span> <span class="k">ALL</span> <span class="k">SELECT</span> <span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">;</span>


<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">Comments</span> <span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">author</span><span class="p">,</span> <span class="k">comment</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="nv">"Fran"</span><span class="p">,</span> <span class="nv">"好，查一下吧"</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">comments_closure</span> <span class="p">(</span><span class="n">ancestor</span><span class="p">,</span> <span class="n">descendant</span><span class="p">)</span>
  <span class="k">SELECT</span> <span class="n">t</span><span class="p">.</span><span class="n">ancestor</span><span class="p">,</span> <span class="mi">6</span> <span class="k">FROM</span> <span class="n">comments_closure</span> <span class="k">AS</span> <span class="n">t</span> <span class="k">WHERE</span> <span class="n">t</span><span class="p">.</span><span class="n">descendant</span><span class="o">=</span><span class="mi">4</span> <span class="k">UNION</span> <span class="k">ALL</span> <span class="k">SELECT</span> <span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">;</span>

<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">Comments</span> <span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">author</span><span class="p">,</span> <span class="k">comment</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="nv">"Kukla"</span><span class="p">,</span> <span class="nv">"解决了"</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">comments_closure</span> <span class="p">(</span><span class="n">ancestor</span><span class="p">,</span> <span class="n">descendant</span><span class="p">)</span>
  <span class="k">SELECT</span> <span class="n">t</span><span class="p">.</span><span class="n">ancestor</span><span class="p">,</span> <span class="mi">7</span> <span class="k">FROM</span> <span class="n">comments_closure</span> <span class="k">AS</span> <span class="n">t</span> <span class="k">WHERE</span> <span class="n">t</span><span class="p">.</span><span class="n">descendant</span><span class="o">=</span><span class="mi">6</span> <span class="k">UNION</span> <span class="k">ALL</span> <span class="k">SELECT</span> <span class="mi">7</span><span class="p">,</span><span class="mi">7</span><span class="p">;</span>

<span class="c1">-- 查询后代</span>
<span class="c1">-- 查询 #4 的后代</span>
<span class="k">SELECT</span> <span class="k">c</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="n">Comments</span> <span class="k">AS</span> <span class="k">c</span> <span class="k">JOIN</span> <span class="n">comments_closure</span> <span class="k">AS</span> <span class="n">t</span> <span class="k">ON</span> <span class="k">c</span><span class="p">.</span><span class="n">id</span><span class="o">=</span><span class="n">t</span><span class="p">.</span><span class="n">descendant</span> <span class="k">WHERE</span> <span class="n">t</span><span class="p">.</span><span class="n">ancestor</span><span class="o">=</span><span class="mi">4</span><span class="p">;</span>

<span class="c1">-- 查询祖先，#6 的祖先</span>
<span class="k">SELECT</span> <span class="k">c</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="n">Comments</span> <span class="k">AS</span> <span class="k">c</span> <span class="k">JOIN</span> <span class="n">comments_closure</span> <span class="k">AS</span> <span class="n">t</span> <span class="k">ON</span> <span class="k">c</span><span class="p">.</span><span class="n">id</span><span class="o">=</span><span class="n">t</span><span class="p">.</span><span class="n">ancestor</span> <span class="k">WHERE</span> <span class="n">t</span><span class="p">.</span><span class="n">descendant</span><span class="o">=</span><span class="mi">6</span><span class="p">;</span>


<span class="c1">-- 删除一个叶子节点， #7</span>
<span class="k">DELETE</span> <span class="k">FROM</span> <span class="n">comments_closure</span> <span class="k">WHERE</span> <span class="n">descendant</span><span class="o">=</span><span class="mi">7</span><span class="p">;</span>

<span class="c1">-- 删除一颗完整的树,比如 #4 he 它的所有后代</span>
<span class="k">DELETE</span> <span class="k">FROM</span> <span class="n">comments_closure</span> <span class="k">WHERE</span> <span class="n">descendant</span> <span class="k">IN</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">descendant</span> <span class="k">FROM</span> <span class="n">comments_closure</span> <span class="k">WHERE</span> <span class="n">ancestor</span><span class="o">=</span><span class="mi">4</span><span class="p">);</span>

</code></pre></div></div>

<h2 id="第-4-章需要-id">第 4 章:需要 ID</h2>

<h3 id="41-目标建立主键规范">4.1 目标：建立主键规范</h3>

<ul>
  <li>主键是数据库确保数据行在整张表中唯一性的保障，它是定位到一条记录并且确保不会重复存储的逻辑机制。</li>
  <li>主键也同时可以被外键引用来建立表与表之间的关系。</li>
</ul>

<p>主键约束是很重要的情况：</p>

<ul>
  <li>确保一张表中的数据不会出现重复行；</li>
  <li>在查询中引用单独的一行记录；</li>
  <li>支持外键。</li>
</ul>

<h4 id="数据库伪主键实现">数据库伪主键实现</h4>

<p>一个对于表的域模型无意义的新列来存储一个伪值，这种类型的主键列我们通常称其为伪主键或者代理键。</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">特性</th>
      <th style="text-align: left">支持的数据库</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">AUTO_INCREMENT</td>
      <td style="text-align: left">MySQL</td>
    </tr>
    <tr>
      <td style="text-align: left">GENERATOR</td>
      <td style="text-align: left">Firebird, InterBase</td>
    </tr>
    <tr>
      <td style="text-align: left">IDENTITY</td>
      <td style="text-align: left">DB2, Derby, Microsoft SQL Server, Sybase</td>
    </tr>
    <tr>
      <td style="text-align: left">ROWID</td>
      <td style="text-align: left">SQLite</td>
    </tr>
    <tr>
      <td style="text-align: left">SEQUENCE</td>
      <td style="text-align: left">DB2, Firebird, Informix, Ingres, Oracle,PostgreSQL</td>
    </tr>
    <tr>
      <td style="text-align: left">SERIAL</td>
      <td style="text-align: left">MySQL, PostgreSQL</td>
    </tr>
  </tbody>
</table>

<h3 id="反模式以不变应万变">反模式：以不变应万变</h3>

<ul>
  <li>主键的列名叫做id；</li>
  <li>数据类型是32位或者64位整型；</li>
  <li>主键的值是自动生成来确保唯一的。</li>
</ul>

<h4 id="允许重复项">允许重复项</h4>

<p>id 这一列作为主键，约束就不再是bug_id和product_id的组合必须唯一</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">BugsProducts</span> <span class="p">(</span>
<span class="n">id</span> <span class="nb">SERIAL</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
<span class="n">bug_id</span> <span class="nb">BIGINT</span> <span class="nb">UNSIGNED</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
<span class="n">product_id</span> <span class="nb">BIGINT</span> <span class="nb">UNSIGNED</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
<span class="k">FOREIGN</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">bug_id</span><span class="p">)</span> <span class="k">REFERENCES</span> <span class="n">Bugs</span><span class="p">(</span><span class="n">bug_id</span><span class="p">),</span>
<span class="k">FOREIGN</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">product_id</span><span class="p">)</span> <span class="k">REFERENCES</span> <span class="n">Products</span><span class="p">(</span><span class="n">product_id</span><span class="p">)</span>
<span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">BugsProducts</span> <span class="p">(</span><span class="n">bug_id</span><span class="p">,</span> <span class="n">product_id</span><span class="p">)</span>
<span class="k">VALUES</span> <span class="p">(</span><span class="mi">1234</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1234</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1234</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">-- 重复项也是可以输入的</span>
</code></pre></div></div>

<p>但是，当你在bug_id和product_id这两列上应用了唯一性约束，id这一列就会变成多余的</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">BugsProducts</span> <span class="p">(</span>
<span class="n">id</span> <span class="nb">SERIAL</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
<span class="n">bug_id</span> <span class="nb">BIGINT</span> <span class="nb">UNSIGNED</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
<span class="n">product_id</span> <span class="nb">BIGINT</span> <span class="nb">UNSIGNED</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
<span class="k">UNIQUE</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">bug_id</span><span class="p">,</span> <span class="n">product_id</span><span class="p">),</span>
<span class="k">FOREIGN</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">bug_id</span><span class="p">)</span> <span class="k">REFERENCES</span> <span class="n">Bugs</span><span class="p">(</span><span class="n">bug_id</span><span class="p">),</span>
<span class="k">FOREIGN</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">product_id</span><span class="p">)</span> <span class="k">REFERENCES</span> <span class="n">Products</span><span class="p">(</span><span class="n">product_id</span><span class="p">)</span>
<span class="p">);</span>
</code></pre></div></div>

<h4 id="使用using关键字">使用USING关键字</h4>

<p>SQL 支持简洁的表达式来表示两张表的联结。如果两张表都有同样的列名，就可以用如下的表达式查询：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">Bugs</span> <span class="k">JOIN</span> <span class="n">BugsProducts</span> <span class="k">USING</span> <span class="p">(</span><span class="n">bug_id</span><span class="p">);</span>
</code></pre></div></div>

<h4 id="使用组合键之难">使用组合键之难</h4>

<ul>
  <li>序列通过将运算和事务在逻辑上分离来解决并发问题。</li>
  <li>序列确保即使在多并发下，每次调用都会返回不同的值</li>
</ul>

<p>内置函数来获取一个序列生成的最后一个值:</p>
<ul>
  <li>MySQL 中的这个函数叫做 LAST_INSERT_ID()；</li>
  <li>Microsoft SQL Server 使用叫做S COPE_IDENTITY() 的函数</li>
  <li>Oracle 中称为 SequenceName.CURRVAL()</li>
</ul>

<h3 id="其它">其它</h3>

<p>如果使用框架的话，比如 rails 之类的，后面的就不要看了，虽然组合键作为主键是可以的，但是框架也可以帮我们做重复项的约束，所以使用伪主键也是没问题的</p>

<h2 id="第-5-章-不用钥匙的入口">第 5 章: 不用钥匙的入口</h2>

<p>MySQL默认的存储引擎是MyISAM，并不支持外键约束，数据库的设计中有很多的逻辑关系，但无法保证引用完整性</p>

<h3 id="目标简化数据库架构">目标：简化数据库架构</h3>

<p>不使用外键的原因:</p>

<ul>
  <li>数据更新有可能和约束冲突。</li>
  <li>当前的数据库设计如此灵活，以致于不支持引用完整性约束。</li>
  <li>数据库为外键建立的索引会影响性能。</li>
  <li>当前使用的数据库不支持外键。</li>
  <li>定义外键的语法并不简单，还需要查阅。</li>
</ul>

<h3 id="反模式无视约束">反模式：无视约束</h3>

<p>省略外键约束能使得数据库设计更加简单、灵活，或者执行更加高效, 但是,必须增加额外的代码来手动维护引用完整性</p>

<h3 id="合理使用反模式-1">合理使用反模式</h3>

<p>被迫使用不支持外键约束的数据库产品:</p>

<ul>
  <li>MySQL的MyISAM存储引擎</li>
  <li>或者 SQLite 3.6.19 早的版本</li>
</ul>

<h3 id="55-解决方案声明约束">5.5 解决方案：声明约束</h3>

<h2 id="第6章-实体属性值">第6章 实体—属性—值</h2>

<p>按日期来统计记录条数:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">date_reported</span><span class="p">,</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
<span class="k">FROM</span> <span class="n">Bugs</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">date_reported</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="目标支持可变的属性">目标：支持可变的属性</h3>

<p>Bug和FeatureRequest有一些公共属性，我们将其提炼为一个基类，称为Issue</p>

<p><img src="./屏幕快照 2017-03-07 上午9.20.14.png" alt="Alt text" /></p>

<h3 id="反模式使用泛型属性表">反模式：使用泛型属性表</h3>

<p>EAV（Entity，Attribute，Value）模型</p>

<p><img src="./屏幕快照 2017-03-07 上午9.44.48.png" alt="Alt text" /></p>

<p>好处：</p>

<ul>
  <li>这两张表的列都很少。</li>
  <li>新增的属性不会对现有的表结构造成影响，不需要新增列。</li>
  <li>避免了由于空值而造成的表内容混乱。</li>
</ul>

<p>缺点：</p>

<ul>
  <li>EVA 模型设计上的简单化并不足以弥补其造成的使用上的难度</li>
  <li>查询操作更加啰唆，而且不够清晰</li>
  <li>无法声明强制属性</li>
  <li>无法使用SQL的数据类型</li>
  <li>无法确保引用完整性</li>
  <li>无法配置属性名</li>
  <li>必须使用外联结来进行查询，随着属性的数量不断增多，联结的数量也不断增长，查询的开销也成指数级地增长</li>
</ul>

<h3 id="合理使用反模式-2">合理使用反模式</h3>

<ul>
  <li>最好不要用 EAV 模型</li>
  <li>如果你有非关系数据管理的需求，最好的答案是使用非关系技术 Redis, Berkeley DB, CouchDB, Hadoop和HBase 等等</li>
</ul>

<h3 id="解决方案模型化子类型">解决方案：模型化子类型</h3>

<h4 id="单表继承">单表继承</h4>

<p>将所有相关的类型都存在一张表中，为所有类型的所有属性都保留一列。同时，使用一个属性来定义每一行表示的子类型。</p>

<h4 id="实体表继承">实体表继承</h4>

<p>为每个子类型创建一张独立的表。每个表包含那些属于基类的共有属性，同时也包含子类型特殊化的属性</p>

<h4 id="类表继承">类表继承</h4>

<p>模拟了继承，把表当成面向对象里的类。创建一张基类表，包含所有子类型的公共属性。对于每个子类型，创建一个独立的表，通过外键和基类表相连。</p>

<h4 id="半结构化数据模型">半结构化数据模型</h4>

<ul>
  <li>使用一个BLOB列来存储</li>
  <li>数据，用XML或者JSON格式——同时包含了属性的名字和值。Martin Fowler称这个模式为：序列化大对象块（Serialized LOB）。</li>
  <li>例如：rails 的序列化 hash 以及利用 pg 的 <code class="language-plaintext highlighter-rouge">jsonb</code></li>
</ul>

<h2 id="第-7-章多态关联">第 7 章：多态关联</h2>

<p>评论有两张表，Bugs 和 FeatureRequests 是类似的实体，想要按行联结不同的表</p>

<h3 id="目标引用多个父表">目标：引用多个父表</h3>

<p><img src="./屏幕快照 2017-03-15 上午9.34.59.png" alt="Alt text" /></p>

<ul>
  <li>Comments表中的一条记录即可能匹配Bugs表中的某条记录，</li>
  <li>也可能匹配于FeatureReqeuests表中的某条记录</li>
</ul>

<h3 id="反模式">反模式：</h3>

<ul>
  <li>使用多用途外键。这种设计也叫做多态关联，或者杂乱关联。</li>
  <li>多态关联和EAV有着相似的特征：元数据对象的名字是存储在字符串中的。</li>
  <li>在多态关联中，父表的名字是存储在issue_type列中的。有时这样的设计被称为：混合数据与元数据</li>
</ul>

<p>查询示例：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span>
<span class="k">FROM</span> <span class="n">Bugs</span> <span class="k">AS</span> <span class="n">b</span> <span class="k">JOIN</span> <span class="n">Comments</span> <span class="k">AS</span> <span class="k">c</span>
<span class="k">ON</span> <span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">issue_id</span> <span class="o">=</span> <span class="k">c</span><span class="p">.</span><span class="n">issue_id</span> <span class="k">AND</span> <span class="k">c</span><span class="p">.</span><span class="n">issue_type</span> <span class="o">=</span> <span class="s1">'Bugs'</span><span class="p">)</span>
<span class="k">WHERE</span> <span class="n">b</span><span class="p">.</span><span class="n">issue_id</span> <span class="o">=</span> <span class="mi">1234</span><span class="p">;</span>                                                                                                                                                                                                                                  
</code></pre></div></div>

<h3 id="如何识别反模式当出现以下情况时可能是反模式">如何识别反模式：当出现以下情况时，可能是反模式</h3>

<p>（1）这种标记框架可以让你将标记(或者其他属性)和数据库中的任何其他资源联系起来。就像EAV的设计一样，应该怀疑任何生成有无线扩展性的设计。
（2）不能在数据库中声明外键。
（3）使用混合数据与元数据设计，父表的名字是存储在 issue_type 这样的列中</p>

<h3 id="合理使用反模式-3">合理使用反模式</h3>

<ul>
  <li>尽可能地避免使用多态关联——应该使用外键约束等来确保引用完整性，多态关联通常过度依赖上层程序代码而不是数据库的元数据</li>
  <li>使用一个成熟的框架，框架通过良好的逻辑封装来减少使用多态关联的风险</li>
</ul>

<h3 id="解决方案让关系变得简单">解决方案：让关系变得简单</h3>

<ul>
  <li>解决方案将变得异常的简单：多态关联是一个反向关联</li>
  <li>为每个父表创建一张独立的交叉表</li>
  <li>创建共用的超级表, 通过创建一个基类表，并让所有的父表都从这个基类表扩展出来的方法来解决这个问题</li>
</ul>

<h2 id="第-8-章多列属性">第 8 章：多列属性</h2>

<h3 id="目标存储多值属性">目标：存储多值属性</h3>

<h3 id="反模式创建多个列">反模式：创建多个列</h3>

<ul>
  <li>比如用户有多个电话、手机、email 地址等</li>
  <li>在多个列中查询需要使用 <code class="language-plaintext highlighter-rouge">IN</code> 或 <code class="language-plaintext highlighter-rouge">OR</code></li>
  <li>添加或删除值需要繁琐的查询</li>
  <li>确保唯一性比较困难</li>
  <li>字段列数无法预计，增加列非常麻烦</li>
</ul>

<h3 id="如何识别反模式-2">如何识别反模式</h3>

<ul>
  <li>乱穿马路和多值属性，这两个反模式都是解决同一个目标的解决方案——存储一个具有多个值的属性</li>
  <li>乱穿马路是多对多关系的存储</li>
</ul>

<p>当出现以下情况时，可能是反模式：</p>

<ul>
  <li>你需要决定为标签这样的多值属性定义多少列?</li>
  <li>如何在SQL查询中同时搜索多列？</li>
</ul>

<h3 id="合理使用反模式-4">合理使用反模式</h3>

<ul>
  <li>一个属性可能有固定数量的候选值，并且对应的存储位置和顺序都是固定的</li>
</ul>

<h3 id="解决方案创建从属表">解决方案：创建从属表</h3>

<ul>
  <li>最好的解决方案是创建一张从属表，仅使用一列来存储多值属性。将多个值存在多行中而不是多列里</li>
  <li>在从属表中定义一个外键，将这个值和目标表中的主键Id关联起来</li>
</ul>

<h2 id="第-9-章元数据分裂">第 9 章：元数据分裂</h2>

<h3 id="目标支持可扩展性">目标：支持可扩展性</h3>

<ul>
  <li>数据量增长，数据库的查询性能下降，索引作用有限</li>
  <li>需要优化数据库的结构来提升查询性能，以及需要支持表的平滑扩展</li>
</ul>

<h3 id="反模式克隆表与克隆列">反模式：克隆表与克隆列</h3>

<ul>
  <li>将一张很长的表拆分成多张较小的表，使用表中某一个特定的数据字段来给这些拆分出来
的表命名。</li>
  <li>将一个列拆分成多个子列，使用别的列中的不同值给拆分出来的列命名</li>
  <li>通过将年份追加在基本表名之后，我们其实是将数据和元数据标识合并在了一起</li>
  <li>EAV和多态关联反模式中看到的混合数据和元数据的方式正好相反, 将元数据标识（列名和表名）当做字符串存储</li>
</ul>

<p>缺点：</p>

<ul>
  <li>不断产生的新表</li>
  <li>无法管理数据完整性</li>
  <li>同步数据，需要复杂的操作来修改数据</li>
  <li>无法确保唯一性，数据存在不同的表中</li>
  <li>跨表查询麻烦</li>
  <li>同步元数据：拆表后，改变一个表的结构，需要同时修改所有的</li>
  <li>不能用简单的外键来管理引用完整性</li>
  <li>标识元数据分裂列</li>
</ul>

<h3 id="如何识别反模式-3">如何识别反模式</h3>

<p>元数据分裂反模式在你的数据库中繁衍生长的暗示:</p>

<ul>
  <li>我们需要每……创建一张表（或者列）</li>
  <li>数据库所支持的最大数量的表（或者列）是多少</li>
  <li>将数据表根据年份创建一张新表，导致查询和添加失败</li>
  <li>“我要怎样同时查询很多张表？每张表的列都是一样的。”
如果你需要查询很多结构一样的表，就应该将数据全都存在一个表中，使用一个额外的属
性列来分组数据</li>
  <li>我要怎样将表名作为一个变量传递？我在查询时需要根据年份动态地生成这些表名</li>
</ul>

<h3 id="合理使用反模式-5">合理使用反模式</h3>

<ul>
  <li>手动分割表的一个合理使用场景是归档数据——将历史数据从日常使用的数据中移除,当然除非你不需要再使用或者查询数据了</li>
</ul>

<h3 id="解决方案分区及标准化">解决方案：分区及标准化</h3>

<ul>
  <li>除了手动拆分这张表，还有更好的办法来提升查询性能，这些方法就包括了水平分区、垂直分区以及使用关联表</li>
  <li>水平分区：使用水平分区或者分片的数据库特性来分割大数据量的表，没有手动分割表的缺陷，可以使用简单的 SQL 查询,比如，使用 MySQL5.1 所支持的分区特性</li>
  <li>垂直分区: 垂直分区就是根据列来对表进行拆分。当某些列非常庞大或者很少使用的时候，对表进行按列拆分会比较有优势。</li>
  <li>多列属性中使用的解决方案与垂直分区类似，解决元数据分裂的改进方案就是创建关联
表。</li>
  <li>别让数据繁衍元数据</li>
</ul>

]]></content>
	</entry>
	
</feed>