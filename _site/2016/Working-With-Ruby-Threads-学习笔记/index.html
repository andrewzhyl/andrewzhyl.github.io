<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Andrew's Blog - 《working with ruby threads 》学习笔记</title>
  <link rel="shortcut icon" href="/assets/images/favicon.ico">
  <link rel="stylesheet" href="/assets/css/style.css">
  <link rel="alternate" type="application/rss+xml" title="My Blog" href="/rss.xml">
  <link rel="stylesheet" href="/assets/css/highlight.css">
</head>
<body>

  <nav class="main-nav">
    
        <a href="/"> <span class="arrow">←</span> Home </a>
    

    
        
            <a href="/about">About </a>
        
    
    <a class="cta" href="/feed.xml">Subscribe</a>
</nav>

  

  <section id="wrapper" class="">
    <article class="post">
    <header>
        <h1>《working with ruby threads 》学习笔记</h1>
        <h2 class="headline">September 8, 2016</h2>
    </header>
    <section id="post-body">
        
<hr />
<p>title:  “《Working With Ruby Threads》学习笔记”
date:   2016-09-21 09:08:00
description: ‘《Working With Ruby Threads》’
—</p>

<h1 id="working-with-ruby-threads">《Working With Ruby Threads》学习笔记</h1>

<h2 id="introduction">Introduction</h2>

<h3 id="why-care">why care?</h3>

<ul>
  <li>在多核 CPU上，代码必须构建在充分利用多核的架构上才能跑的更快</li>
</ul>

<h3 id="the-promise-of-multi-threading">The promise of multi-threading</h3>

<ul>
  <li>多进程 copy 内存，多线程共享内存</li>
  <li>多线程比多进程开销更小，多线程可以有更多的并发单元</li>
  <li>多线程必须基于线程安全</li>
</ul>

<h2 id="youre-always-in-a-thread">第1章: You’re Always in a Thread</h2>

<pre><code class="language-bash">$ irb
&gt; Thread.main
=&gt; #&lt;Thread:0x007fdc830677c0 run&gt;
&gt; Thread.current == Thread.main =&gt; true
</code></pre>

<ul>
  <li><code>Thread.main</code> 总是指向主线程</li>
  <li>主线程退出，其它线程也会终止，并且 ruby 进程会退出</li>
</ul>

<pre><code class="language-bash">$ irb
&gt; Thread.main
=&gt; #&lt;Thread:0x007fdc830677c0 run&gt;
&gt; Thread.current == Thread.main =&gt; true
</code></pre>

<h2 id="threads-of-execution">第2章：Threads of Execution</h2>

<h3 id="shared-address-space">Shared address space</h3>

<ul>
  <li>线程共享一个作用域</li>
  <li>所有 ruby 的线程会映射为一个 native，操作系统线程</li>
</ul>

<pre><code class="language-bash">$ top -l1 -pid 8409 -stats pid,th
</code></pre>
<p>以上命令可以查看进程 id 为 8409 的线程数量</p>

<h3 id="non-deterministic-context-switching">Non-deterministic context switching(非确定的环境切换)</h3>

<p>In order to provide fair access, the thread scheduler can ‘pause’ a thread at any time, suspending its current state
为了提供公平的访问，线程调度能在任意时间 “暂停” 一个线程，暂停它的当前状态</p>

<p><code>||=</code> 语句不是线程安全的，因为线程可能在任何时间被阻止，如果 A 线程运行 <code>||=</code> 获得了初始值并且暂停，可能会出现失去 B 线程赋值的情况</p>

<pre><code class="language-ruby"># This statement
results ||= Queue.new

# when broken down, becomes something like
if @results.nil? 
 temp = Queue.new 
 @results = temp
end
</code></pre>

<p>A race condition involves two threads racing to perform an operation on some shared state.
一个竞争条件是在共享状态下，包含两个线程竞争去执行一个同样的操作</p>

<ul>
  <li><strong><code>重要原则：</code></strong>Any time that you have two or more threads trying to modify the same thing at the same time, you’re going to have issues.</li>
  <li>This is because the thread scheduler can interrupt a thread at any time.</li>
</ul>

<p>针对重要原则的两个策略：</p>

<p>1) don’t allow concurrent modification
2) protect concurrent modification</p>

<h2 id="lifecycle-of-a-thread">第三章：Lifecycle of a Thread</h2>

<h3 id="threadnew">Thread.new</h3>

<pre><code class="language-ruby">Thread.new { ... }
Thread.fork { ... } 
Thread.start(1, 2) { |x, y| x + y }
</code></pre>
<p>Thread.new 及其别名方法</p>

<h3 id="threadjoin">Thread#join</h3>

<ul>
  <li>Once you’ve spawned a thread, you can use #join to wait for it to finish</li>
  <li>Without #join, the main thread would exit before the sub-thread can execute its block. Using #join provides a guarantee in this situation.</li>
  <li>Calling #join on the spawned thread will join the current thread of execution with the spawned one</li>
  <li>使用 #join 的时候，异常会在 #join 的时候才抛出，主线程也会执行但不会立即输出</li>
</ul>

<h3 id="threadstatus">Thread#status</h3>

<p><code>Thread#value</code> 的几个可能值:</p>

<ul>
  <li><code>run</code>: Threads currently running have this status.</li>
  <li><code>sleep</code>: Threads currently sleeping, blocked waiting for a mutex, or waiting on
IO, have this status.(线程当前睡眠状态，阻塞等待一个同步锁，或者 IO)</li>
  <li><code>false</code>: Threads that finished executing their block of code, or were successfully killed, have this status.(线程已经执行完毕，或者成功被杀掉)</li>
  <li>
    <table>
      <tbody>
        <tr>
          <td><code>nil</code>: Threads that raised an unhandled exception have this status. wwrt</td>
          <td>33(线程抛出一个未处理的异常，会有返回状态)</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li><code>aborting</code>: Threads that are currently running, yet dying, have this status(线程当前运行中，但是死掉了了)</li>
</ul>

<h3 id="threadstop">Thread.stop</h3>

<ul>
  <li>这个方法会使线程进入 sleep 状态，然后告诉线程调度器去执行另一个线程</li>
  <li>线程会一直处于 sleep 状态，直到调用 <code>Thread#wakeup</code></li>
</ul>

<pre><code class="language-ruby">require 'thread'

thread = Thread.new do
  Thread.stop
  puts "Hello there"
end

# wait for the thread trigger its stop
puts "----" until thread.status == 'sleep'

thread.wakeup
thread.join

# 输出------
# ----
# ----
...
# ----
# ----
# ----
# Hello there
# [Finished in 1.6s]
</code></pre>

<h3 id="threadpass">Thread.pass</h3>

<p><code>Thread.pass</code> 类似于 <code>Thread.stop</code> 但是他仅仅是让线程调度器去调度另一个线程，不会使当前线程处于 sleep</p>

<h3 id="avoid-threadraise">Avoid Thread#raise</h3>

<ul>
  <li>不推荐使用这个方法，因为会有严重的问题</li>
</ul>

<h3 id="avoid-threadkill">Avoid Thread#kill</h3>

<ul>
  <li>不推荐使用这个方法，跟 <code>Thread#raise</code> 一样，会有严重的问题</li>
</ul>

<h2 id="concurrent--parallel">第四章：Concurrent != Parallel</h2>

<ul>
  <li>concurrent and parallel are not the same thing
    <ol>
      <li>Do multiple threads run your code concurrently? Yes.</li>
      <li>Do multiple threads run your code in parallel? Maybe.</li>
    </ol>
  </li>
  <li>单核 CPU 执行多个任务是并发的，但是并不一定有顺序执行快</li>
  <li>多核 CPU 执行多个任务是并行的，但是也可以因为某个任务出现问题，然后由其它的线程或进程接管</li>
  <li>并行一定是并发的，并发不一定是并行</li>
</ul>

<h3 id="you-cant-guarantee-anything-will-be-parallel">You can’t guarantee anything will be parallel</h3>

<ul>
  <li>making it execute in parallel is out of your hands. That responsibility is left to the underlying thread scheduler(你亲手让程序并行执行，但是具体的并行的责任是交给底层的调度器来执行的)</li>
  <li>多核 CPU 系统中执行多线程程序，也有可能会在一个 CPU 内核执行，这是由线程调度器决定的</li>
  <li>线程采用公平排队的方式，所有的线程都可以或多或少的使用可用的资源，但是不能有代码来决定</li>
</ul>

<p>扩展阅读
- https://blog.golang.org/concurrency-is-not-parallelism
- https://blog.engineyard.com/2011/ruby-concurrency-and-you</p>

<h2 id="the-gil-and-mri">第五章：The GIL and MRI</h2>

<ul>
  <li>MRI allows concurrent execution of Ruby code, but prevents parallel execution of Ruby code</li>
</ul>

<h3 id="the-global-lock">The global lock</h3>

<p><code>GIT</code> 别名：<code>Global Interpreter Lock</code>， <code>GVL (Global VM Lock)</code>，  <code>Global Lock</code></p>

<ul>
  <li>每个 MRI 进程都仅有一个 <code>GIL</code>,多个进程都有它自己的 <code>GIL</code></li>
  <li>进程中产生多个线程，这些线程会共享 <code>GIL</code></li>
  <li>ruby 多线程中，单一线程会在任意给定时间获得 <code>GIL</code>，其它线程需要等待它释放<code>GIT</code></li>
  <li>MRI ruby 不能够实现并行</li>
  <li>即使是没有 <code>GIL</code> 的语言，比如 JAVA,使用多线程也会需要有对相同的公共资源进行访问和修改，如果需要加锁控制，也不能利用到多核并行</li>
  <li>利用多进程实现并行，是 ruby 常用的方式</li>
</ul>

<h3 id="the-special-case-blocking-ioio-">The special case: blocking IO(特殊情况：IO 阻塞)</h3>

<ul>
  <li>ruby 中有 <code>GIL</code> 会阻止并行执行，但是 <code>IO 阻塞</code> 会释放 <code>GIL</code></li>
  <li>MRI doesn’t let a thread hog the GIL when it hits blocking IO(当它触发阻塞 IO 的时候，MRI 不会让线程贪婪占用 GIL)</li>
  <li>因为 ruby 有 <code>GIL</code> ，所以它等于去除了操作系统并行执行的能力，但是等于所有的情况下都不能并行</li>
</ul>

<pre><code class="language-ruby">require 'open-uri'
3.times.map do 
  Thread.new do
    open('http://zombo.com') 
  end
end.each(&amp;:value)
</code></pre>

<p>运行以上代码，假设我们已经生成了所有的线程，他们都试图获取 <code>GIL</code> 来执行代码，Thread A 获得了 <code>GIL</code>,它创建了一个套接字并且试图打开一个连接到 <code>zombo.com</code>,这是线程 A 等待响应，并释放了 <code>GIL</code>, 线程 B 将获得 <code>GIL</code> 并且和线程 A 执行同样的步骤</p>

<p>There are three reasons that the GIL exists(几种 GIL 存在的原因 ):</p>

<ol>
  <li>为了在竞争条件下保护 MRI 核心部件
  竞争条件会引起很多问题，这同样的问题会出现在 MRI的 C 内核, ,最简单的办法就是减少竞争的数量，防止多个线程同时运行</li>
  <li>To facilitate the C extension API(为了便于使用 C 扩展 API)
 只要代码块用到了 C 语言扩展 API, GIL 会阻塞其它代码的运行，因为 C 扩展可能不是线程安全的，GIL 的存在保证了线程安全</li>
  <li>To reduce the likelihood of race conditions in your Ruby code(尽可能的减少竞争条件)</li>
</ol>

<p>…未完</p>

    </section>
</article>
<footer id="post-meta" class="clearfix">
    <a href="http://twitter.com/andrewzhyl">
        <img class="avatar" src="/assets/images/avatar.png">
        <div>
            <span class="dark">andrewzhyl</span>
            <span>记录一些东西</span>
        </div>
    </a>

    <section id="sharing">
        <a class="twitter" href="https://twitter.com/intent/tweet?text=http://andrewzhyl.github.io/2016/Working-With-Ruby-Threads-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ - 《working with ruby threads 》学习笔记 by @andrewzhyl"><span class="icon-twitter"> Tweet</span></a>

<a class="facebook" href="#" onclick="
    window.open(
      'https://www.facebook.com/sharer/sharer.php?u='+encodeURIComponent(location.href),
      'facebook-share-dialog',
      'width=626,height=436');
    return false;"><span class="icon-facebook-rect"> Share</span>
</a>
    </section>
</footer>

<!-- Disqus comments -->


<!-- Archive post list -->





  </section>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
  <script src="/assets/js/main.js"></script>
  <script src="/assets/js/highlight.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <script>
  //   (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  //   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  //   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  //   })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  //   ga('create', '', 'auto');
  //   ga('send', 'pageview');
  </script>
</body>
</html>



