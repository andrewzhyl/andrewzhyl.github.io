<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Andrew's Blog - 《理解 UNIX 进程》学习笔记</title>
  <link rel="shortcut icon" href="/assets/images/favicon.ico">
  <link rel="stylesheet" href="/assets/css/style.css">
  <link rel="alternate" type="application/rss+xml" title="My Blog" href="/rss.xml">
  <link rel="stylesheet" href="/assets/css/highlight.css">
</head>
<body>

  <nav class="main-nav">
    
        <a href="/"> <span class="arrow">←</span> Home </a>
    

    
        
            <a href="/about">About </a>
        
    
    <a class="cta" href="/feed.xml">Subscribe</a>
</nav>

  

  <section id="wrapper" class="">
    <article class="post">
    <header>
        <h1>《理解 UNIX 进程》学习笔记</h1>
        <h2 class="headline">August 13, 2016</h2>
    </header>
    <section id="post-body">
        <h1 id="network-programming-with-go">《Network Programming with Go》学习笔记</h1>

<p>~需要修改。。。。~</p>

<h2 id="architecture">第一章： Architecture(体系结构)</h2>
<p>### Protocol Layers（协议层）</p>

<p><strong>ISO OSI Protocol</strong>
<img src="./1473431812089.png" alt="Alt text" /></p>

<p>每层的功能：
- <code>网络层</code>提供交换及路由技术
- <code>传输层</code>提供了终端系统之间的数据透明传输，并且负责端到端的错误恢复及流程控制
- <code>会话层</code>用来建立、管理、以及终止应用程序之间的连接
- <code>表现层</code>提供数据表现差异的独立性（例如加密）
- <code>应用层</code>支持应用程序和用户程序</p>

<p><strong>TCP/IP Protocol</strong></p>

<p><img src="./1473431977093.png" alt="Alt text" /></p>

<h3 id="gateways">Gateways（网关）</h3>

<p>网关是一个统称，它用于连接起一个或多个网络。
- 其中的<code>中继器</code>在物理层面上进行操作，它将信息从一个子网复制到另一个子网上。
- <code>桥接</code>在数据连接层面上进行操作，它在网络之间复制帧。
- <code>路由器</code>在网络层面上进行操作，它不仅在网络之间复制信息，还决定了信息的传输路线。</p>

<h3 id="packet-encapsulation">Packet encapsulation（数据包封装）</h3>

<ul>
  <li>在OIS或TCP/IP协议栈层与层之间的通信，是通过将数据包从一个层发送到下一个层，最终穿过整个网络的。
-每一层都有必须保持其自身层的管理信息。
-从上层接收到的数据包在向下传递时，会添加头信息。</li>
  <li>在接收端，这些头信息会在向上传递时移除。</li>
</ul>

<p>TFTP（普通文件传输协议）将文件从一台计算机移动到另一台上。它使用IP协议上的UDP协议，该协议可通过以太网发送。看起来就像这样：
<img src="./1473434814430.png" alt="Alt text" /></p>

<h3 id="connection-models">Connection Models(连接模型)</h3>

<ul>
  <li>Connection oriented 面向连接模型</li>
  <li>Connectionless 无连接模型</li>
  <li>面向连接模型即为会话建立单个连接，沿着连接进行双向通信，例如 TCP</li>
  <li>在无连接系统中，消息的发送彼此独立。这类似于普通的邮件。无连接模型的消息可能不按顺序抵达。例子就是IP协议</li>
  <li>面向连接的传输可通过无连接模型——基于IP的TCP协议建立。</li>
  <li>无连接传输可通过面向连接模型——基于IP的HTTP协议建立。</li>
</ul>

<h3 id="communications-models">Communications Models(通信模型)</h3>

<p><strong>Communications Models(消息传递)</strong>
- 并发语言大多使用消息传递的机制，比如 Unix的管道
- Parlog 能在并发的进程之间，将任意的逻辑数据结构当做消息来发送
- 消息传递是分布式系统最基本的机制</p>

<p><img src="./1473674193873.png" alt="Alt text" /></p>

<h3 id="distributed-computing-models">Distributed Computing Models(分布式计算模型)</h3>

<p><img src="./1473674216217.png" alt="Alt text" /></p>

<p>考虑分布式系统的组件是否等价,三种模型：
- 点对点（peer-to-peer）: 若两个组件等价，且均可发起并响应信息
- 过滤器（filter）:有一个组件将信息传至另一个组件，它在修改该信息后会传至第三个组件。
例如：中间组件通过SQL从数据库中获取信息，并将其转换为HTML表单提供给第三个组件（它可能是个浏览器）。
- 客户端-服务器(客户端-服务器): 最常见的就是不对等的情况：客户端向服务器发送请求，然后服务端响应</p>

<h3 id="clientserver-system">Client/Server System</h3>

<p><img src="./1473674889739.png" alt="Alt text" /></p>

<h3 id="clientserver-application">Client/Server Application</h3>
<p><img src="./1473674904487.png" alt="Alt text" /></p>

<h3 id="server-distribution">Server Distribution（服务器分布）</h3>

<p>单一客户端，单个服务器：
<img src="./1473675214266.png" alt="Alt text" /></p>

<p>多个客户端，单一服务器：
<img src="./1473675235161.png" alt="Alt text" />
主站只需接收请求并处理一次，而无需将它们传递给其它服务器来处理。当客户端可能并发时，这就是个通用的模型</p>

<p>单一客户端，多个服务器，例如当业务逻辑服务器从数据库服务器获取信息时
<img src="./1473675269067.png" alt="Alt text" /></p>

<h3 id="component-distribution">Component Distribution</h3>

<p>分解一些应用的一个简单有效的方式就是把它们看做三部分：</p>

<p>Presentation component 表现组件
Application logic 应用逻辑
Data access 数据访问</p>

<p><strong>表现组件</strong>负责与用户进行交互，即显示数据和采集输入，可以是 GUI 界面，也可以是命令行界面
<strong>应用逻辑组件</strong>负责解释用户的响应，根据应用业务规则，准备查询并管理来自其组件的响应
<strong>数据访问组件</strong>负责存储并检索数据。这一般是通过数据库进行，不过也不一定</p>

<p><img src="./1473676063281.png" alt="Alt text" /></p>

<p>Example: Distributed Database：
Gartner第一种分类
<img src="./1473676645585.png" alt="Alt text" /></p>

<p>例如 google map 会下载附近的地图为浏览器中的小型数据库，当用户移动了地图时，可以快速响应</p>

<p>Example: Network File Service 网络文件服务
<img src="./1473676805222.png" alt="Alt text" /></p>

<p>Gartner第二种分类允许远程客户端访问已共享的文件系统
这类系统的例子：NFS、Microsoft共享和DCE等等。</p>

<p>Example: Web:
<img src="./1473676919558.png" alt="Alt text" />
Gartner第三种分类的一个例子就是Web上的小型Java应用</p>

<p>Example: Terminal Emulation
<img src="./1473677181590.png" alt="Alt text" /></p>

<p>Gartner第四种分类就是终端仿真。这允许远程系统在本地系统上作为普通的终端：
Telnet就是最常见的例子。</p>

<p><strong>Three Tier Models</strong>:
可以有三层、四层甚至多层。下图展示了一些可能的三层模型:
<img src="./1473677365117.png" alt="Alt text" /></p>

<h3 id="middleware-model-">Middleware model 中间件模型</h3>

<p><img src="./1473677961430.png" alt="Alt text" /></p>

<p>中间件示例</p>

<ul>
  <li>像终端模拟器、文件传输或电子邮件这样的基础服务</li>
  <li>像RPC这样的基础服务</li>
  <li>像DCE、网络O/S这样的一体化服务</li>
  <li>像CORBA、OLE/ActiveX这样的分布式对象服务</li>
  <li>像RMI、Jini这样的移动对象服务</li>
  <li>万维网</li>
</ul>

<p>中间件的功能包括：</p>

<ul>
  <li>在不同计算机上初始化过程</li>
  <li>进行会话管理</li>
  <li>允许客户端定位服务器的目录服务</li>
  <li>进行远程数据访问</li>
  <li>允许服务器处理多个客户端的并发控制</li>
  <li>保证安全性和完整性</li>
  <li>监控</li>
  <li>终止本地处理和远程处理</li>
</ul>

<h3 id="continuum-of-processing">Continuum of Processing</h3>
<p>Gartner模型基于将一个应用分解为表现组件、应用逻辑和数据处理。一个更细粒度的分解方式为:
<img src="./1473678080293.png" alt="Alt text" /></p>

<h3 id="points-of-failure">Points of Failure</h3>

<p>分布式应用一般运行在复杂的环境中。这使得它比单一计算机上的独立应用更易发生故障。故障点包括：</p>

<ul>
  <li>The client side of the application could crash</li>
  <li>The client system may have h/w problems</li>
  <li>The client’s network card could fail</li>
  <li>Network contention could cause timeouts</li>
  <li>There may be network address conflicts</li>
  <li>Network elements such as routers could fail</li>
  <li>Transmission errors may lose messages</li>
  <li>The client and server versions may be incompatable</li>
  <li>The server’s network card could fail</li>
  <li>The server system may have h/w problems</li>
  <li>The server s/w may crash</li>
  <li>The server’s database may become corrupted</li>
</ul>

<h3 id="acceptance-factors">Acceptance Factors</h3>

<ul>
  <li>Reliability</li>
  <li>Performance</li>
  <li>Responsiveness</li>
  <li>Scalability</li>
  <li>Capacity</li>
  <li>Security</li>
</ul>

<h3 id="transparency">Transparency</h3>
<p>分布式系统的“圣杯”就是提供以下几点：</p>

<ul>
  <li>access transparency</li>
  <li>location transparency</li>
  <li>migration transparency</li>
  <li>replication transparency</li>
  <li>concurrency transparency</li>
  <li>scalability transparency</li>
  <li>performance transparency</li>
  <li>failure transparency</li>
</ul>

<h3 id="eight-fallacies-of-distributed-computing">Eight fallacies of distributed computing:分布式计算的八个误区</h3>

<ul>
  <li>The network is reliable.</li>
  <li>Latency is zero.</li>
  <li>Bandwidth is infinite.</li>
  <li>The network is secure.</li>
  <li>Topology doesn’t change.</li>
  <li>There is one administrator.</li>
  <li>Transport cost is zero.</li>
  <li>The network is homogeneous.</li>
</ul>

<h2 id="socket-level-programming">第3章： Socket-level Programming(套接字层编程)</h2>

<h3 id="the-tcpip-stack">The TCP/IP stack</h3>

<p>The TCP/IP stack is shorter than the OSI one:
<img src="./1473773483879.png" alt="Alt text" /></p>

<ul>
  <li>TCP is a connection-oriented protocol,</li>
  <li>UDP (User Datagram Protocol) is a connectionless protocol.</li>
</ul>

<h4 id="ip-datagrams">IP datagrams</h4>

<ul>
  <li>IP 是无连接协议</li>
  <li>IP datagrams 之间的关联必须由高层协议来提供支持</li>
  <li>IP层包头支持数据校验，在包头包括源地址和目的地址</li>
  <li>IP层包头支持数据校验，在包头包括源地址和目的地址</li>
</ul>

<h4 id="udptcp">UDP&amp;TCP</h4>

<ul>
  <li>UDP是无连接的，不可靠的。它包括IP数据报的内容和端口号的校验</li>
  <li>TCP是构建于IP之上的面向链接的协议。它提供了一个虚电路使得两个应用进程可以通过它来通信。它通过端口号来识别主机上的服务</li>
</ul>

<h3 id="internet-addresses">Internet addresses</h3>

<ul>
  <li>IPV4 由四位数字组成，各自的范围在 0~255,每一组数字可以用 8 位二进制数字来表示，合计共需 32 位二进制</li>
  <li>IPv6使用128位地址，即使表达同样的地址，字节数变得很麻烦，由’:’分隔的4位16进制组成。一个典型的例子如：2002:c0e8:82e7:0:0:0:c0e8:82e7。</li>
</ul>

<h3 id="ip-address-type">IP address type</h3>

<pre><code class="language-go">type IPAddr {
    IP IP
}
</code></pre>

<p>IPAddr 最主要的用法是 DNS 查询
<code>go
func ResolveIPAddr(net, addr string) (*IPAddr, os.Error)
</code></p>

<pre><code class="language-go">  addr, err := net.ResolveIPAddr("ip","www.google.com")
  if err != nil {
    fmt.Println("Resolution error", err.Error())
    os.Exit(1)
  }
  fmt.Println("Resolved address is ", addr.String())
  // 输出
  // Resolved address is  243.185.187.39
</code></pre>

<p><strong>Host lookup</strong></p>

<p><code>ResolveIPAddr</code> 执行一个 DNS 查找，返回单个的 IP 地址</p>

<p><code>LookupHost</code> 执行 DNS 查找，返回字符串切片，ipv4 和 ipv6 的 ip 地址</p>

<p><code>LookupCNAME</code>返回公认的主机名称</p>

<h3 id="services">3.4 Services</h3>

<p>端口号：This is an unsigned integer between 1 and 65,535</p>

<p>“standard” ports：</p>

<ul>
  <li>Telnet usually uses port 23 with the TCP protocol.</li>
  <li>DNS uses port 53, either with TCP or with UDP.</li>
  <li>FTP uses ports 21 and 20</li>
  <li>HTTP usually uses port 80, but it often uses ports 8000, 8080 and 8088, all with TCP</li>
  <li>The X Window System often takes ports 6000-6007, both on TCP and UDP.</li>
</ul>

<p>unix 系统中常用的端口列在 <code>/etc/services</code>
<code>LookupPort</code> 方法查询整个端口
<code>go
func LookupPort(network, service string) (port int, err os.Error)
</code></p>

<p><strong>The type TCPAddr</strong>:</p>

<p><code>TCPAddr</code> 是一个包含 IP 和 Port 的结构
<code>go
type TCPAddr struct {
    IP   IP
    Port int
}
</code></p>

<p><code>ResolveTCPAddr</code> 创建一个 <code>TCPAddr</code>
<code>go
func ResolveTCPAddr(net, addr string) (*TCPAddr, os.Error)
</code>
<code>net</code> 可选： <code>tcp</code>, <code>tcp4</code> or <code>tcp6</code>
<code>addr</code>:  主机名或 IP 地址，中间是 <code>:</code>,后面跟端口号，本机的话，可以简写 <code>:80</code></p>

<h3 id="tcp-sockets">3.5 TCP Sockets</h3>

<p><code> net.TCPConn</code> 支持在客户端和服务端，全双工可读可写的通信</p>

<pre><code class="language-go">func (c *TCPConn) Write(b []byte) (n int, err os.Error)
func (c *TCPConn) Read(b []byte) (n int, err os.Error)
</code></pre>

<p><strong>TCP client</strong>：</p>

<pre><code class="language-go">func DialTCP(net string, laddr, raddr *TCPAddr) (c *TCPConn, err os.Error)
</code></pre>

<ul>
  <li><code>DialTCP</code> 函数可以建立 TCP 连接</li>
  <li>客户端和服务器使用 <code>TCPConn</code>  交换信息，请求或者响应，直到关闭连接</li>
  <li><code>laddr</code> 是本机地址， <code>raddr</code> 是远程服务地址</li>
  <li><code>net</code> 是可选的  <code>tcp4</code>, <code>tcp6</code> or <code>tcp</code></li>
</ul>

<pre><code class="language-go">func ListenTCP(net string, laddr *TCPAddr) (l *TCPListener, err os.Error)
func (l *TCPListener) Accept() (c Conn, err os.Error)
</code></pre>

<p><code>ListenTCP</code> 函数，侦听本地的地址在指定端口，<code>Accept</code> 阻塞，然后等待客户端连接</p>

<h3 id="controlling-tcp-connections">3.6 Controlling TCP connections</h3>

<pre><code class="language-go">func (c *TCPConn) SetTimeout(nsec int64) os.Error
</code></pre>

<p>客户端和服务器设置超时用 <code>SetTimeout</code>，函数在 “net” 包</p>

<p><strong>Staying alive:</strong></p>

<pre><code class="language-go">func (c *TCPConn) SetKeepAlive(keepalive bool) os.Error
</code></pre>
<p><code>SetKeepAlive</code> 可以设置客户端保持连接，函数在 “net” 包</p>

<h3 id="udp-datagrams">3.7 UDP Datagrams</h3>

<p>UDP 的函数：</p>

<pre><code class="language-go">func ResolveUDPAddr(net, addr string) (*UDPAddr, os.Error)
func DialUDP(net string, laddr, raddr *UDPAddr) (c *UDPConn, err os.Error)
func ListenUDP(net string, laddr *UDPAddr) (c *UDPConn, err os.Error)
func (c *UDPConn) ReadFromUDP(b []byte) (n int, addr *UDPAddr, err os.Error
func (c *UDPConn) WriteToUDP(b []byte, addr *UDPAddr) (n int, err os.Error)
</code></pre>

<h3 id="server-listening-on-multiple-sockets">3.8 Server listening on multiple sockets</h3>

<ul>
  <li>go 的底层利用的是系统调用 <code>select(2)</code></li>
  <li><code>select(2)</code> 可以检测同时等待的多个 I/O,告诉哪个可以读写</li>
</ul>

<pre><code class="language-gcode">/* c 函数*/
int select(int maxfd, fd_set *readfds, fd_set *writefds, fe_set *exceptfds, const struct timeval *timeout);
</code></pre>
<ul>
  <li>select 的第一个参数是文件描述符集中要被检测的比特数，这个值必须至少比待检测的最大文件描述符大1</li>
  <li>参数 readfds 指定了被读监控的文件描述符集</li>
  <li>参数 writefds 指定了被写监控的文件描述符集</li>
  <li>参数exceptfds指定了被例外条件监控的文件描述符集。</li>
  <li>参数timeout起了定时器的作用：到了指定的时间，无论是否有设备准备好，都返回调用</li>
</ul>

<p>未完。。。。</p>

    </section>
</article>
<footer id="post-meta" class="clearfix">
    <a href="http://twitter.com/andrewzhyl">
        <img class="avatar" src="/assets/images/avatar.png">
        <div>
            <span class="dark">andrewzhyl</span>
            <span>记录一些东西</span>
        </div>
    </a>

    <section id="sharing">
        <a class="twitter" href="https://twitter.com/intent/tweet?text=http://andrewzhyl.github.io/2016/Network-Programming-with-Go-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/ - 《理解 UNIX 进程》学习笔记 by @andrewzhyl"><span class="icon-twitter"> Tweet</span></a>

<a class="facebook" href="#" onclick="
    window.open(
      'https://www.facebook.com/sharer/sharer.php?u='+encodeURIComponent(location.href),
      'facebook-share-dialog',
      'width=626,height=436');
    return false;"><span class="icon-facebook-rect"> Share</span>
</a>
    </section>
</footer>

<!-- Disqus comments -->


<!-- Archive post list -->





  </section>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
  <script src="/assets/js/main.js"></script>
  <script src="/assets/js/highlight.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <script>
  //   (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  //   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  //   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  //   })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  //   ga('create', '', 'auto');
  //   ga('send', 'pageview');
  </script>
</body>
</html>



